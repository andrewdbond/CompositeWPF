[
  {
    "Id": "635516",
    "ThreadId": "263439",
    "Html": "\r\n<p>I'm running into a bit of an issue here.</p>\r\n<p>.NET 4's MEF does not support ExportFactor&lt;T&gt; or ComponentInitializer for the desktop version. So I downloaded Glenn Block's solution (binary) and referenced it to my project. The project compiles, but I always get issues:</p>\r\n<p>1) If I use the ComponentInitializer.SatisfyImports(this); statement, my imports are not shared. I noticed this when I tried to use the EventAggregator and found that they were different instances even if I import them with CreationPolicy.Shared.</p>\r\n<p>2) If I use the ExportFactory&lt;T&gt; I get an Import/Export Cardinality Mismatch error. Apparently, it doesn't like it when I Import an ExportFactory: [Import] private ExportFactory&lt;IOrderViewModel&gt; _orderFactory; even though I have my ViewModels\r\n exported properly.</p>\r\n<p>&nbsp;</p>\r\n<p>So, I thought maybe I should use the MEF 2 Preview 3 from the codeplex. This causes issues as well... so I recompile Prism v4 using the Codeplex MEF 2 Preview 3 library... it compiles fine, but I still get the same issues as before, only the output is easier\r\n to read.</p>\r\n<p>&nbsp;</p>\r\n<p>I'm really lost. How can I export non-shared instances of a ViewModel that needs to contain the single instance of the EventAggregator? Right now I have some hacky workaround where I import shared instances and call a &quot;Reset()&quot; method on them which resets\r\n all the variables... problem is that they are still the same instance. If I don't want the same instance I either run into the issue that I can't use any MEF Imports in the class (because I'm doing new()) or even if I do and use the ComponentInitializer I\r\n get different instances imported. Is there any working solution to get the following working:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> Foo : NotificationObject, IPartImportsSatisfiedNotification\r\n{\r\n    [Import] <span style=\"color:blue\">private</span> IEventAggregator _ea;\r\n    <span style=\"color:blue\">private</span> ObservableCollection&lt;IOrderViewModel&gt; _orders = <span style=\"color:blue\">new</span> ObservableCollection&lt;IOrderViewModel&gt;();\r\n\r\n    <span style=\"color:green\">//From an event</span>\r\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> AddOrder(IOrderViewModel order)\r\n    {\r\n        _orders.Add(order);\r\n    }\r\n\r\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> OnImportsSatisfied()\r\n    {\r\n        <span style=\"color:green\">//Subscribe to events</span>\r\n    }    \r\n}\r\n\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> OrderViewModel : NotificationObject, IPartImportsSatisfiedNotification,  IOrderViewModel\r\n{\r\n    [Import] <span style=\"color:blue\">private</span> IEventAggregator _ea;\r\n\r\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> DoEvent() { ... }\r\n\r\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> OnImportsSatisfied()\r\n    {\r\n        <span style=\"color:green\">//Subscribe to events</span>\r\n    }    \r\n}\r\n\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> BarViewModel : NotificationObject\r\n{\r\n    [Import] <span style=\"color:blue\">private</span> IEventAggregator _ea;\r\n\r\n    <span style=\"color:green\">//Somewhere in code - Publishes an Event to add orders and to DoEvent()s.</span>\r\n}\r\n</pre>\r\n</div>\r\n<p></p>\r\n",
    "PostedDate": "2011-06-30T10:13:16.54-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "635549",
    "ThreadId": "263439",
    "Html": "<p>Hi,</p>\r\n<p>Based on my understanding of your scenario, one possible way to avoid obtaining a new instance of the <strong>EventAggregator</strong> could be subscribing using strong references.</p>\r\n<p>This concept is explained in the <em><a href=\"http://msdn.microsoft.com/en-us/library/ff921122(v=PandP.40).aspx#sec14\">Subscribing Events</a> </em>section, specifically <a href=\"http://msdn.microsoft.com/en-us/library/ff921122(v=PandP.40).aspx#sec17\">here</a> from <a href=\"http://msdn.microsoft.com/en-us/library/ff921122(v=PandP.40).aspx\">Chapter 9: Communicating Between Loosely Coupled Components</a></p>\r\n<p>On the other hand, you import your dependencies in the <strong>ctor</strong> of your view models ensuring the injection of your composable parts. For example, like this:</p>\r\n<p><span style=\"font-size: 9pt;\">\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">public</span> <span style=\"color: blue;\">class</span> OrderViewModel : NotificationObject, IOrderViewModel\r\n{\r\n    [ImportingConstructor]\r\n    <span style=\"color: blue;\">public</span> OrderViewModel(IEventAggregator eventAggregator)\r\n    {\r\n        &hellip;\r\n        eventAggregator.GetEvent&lt;&hellip;.&gt;().Subscribe(&hellip;)\r\n    }\r\n    \r\n    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> DoEvent() { ... }   \r\n}\r\n</pre>\r\n</div>\r\n</span></p>\r\n<p>Take into account that if you subscribe using strong references, you will have to manually unsubscribes if it no longer wants to receive events.</p>\r\n<p>Thanks,</p>\r\n<p>Miguel Bronzovic<br /><a href=\"http://blogs.southworks.net/mbronzovic\">http://blogs.southworks.net/mbronzovic</a></p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-06-30T11:31:50.61-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]