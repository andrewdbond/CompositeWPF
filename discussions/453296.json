[
  {
    "Id": "1080156",
    "ThreadId": "453296",
    "Html": "I am trying to navigate between 2 views in 2 different modules within one region in my shell.\r<br />\n<br />\nOne view is essentially a main menu/home screen (additional features and modules will be added in the future) and the other view is the primary use case for the application (data entry).\r<br />\n<br />\nRight now I register each view in the Module Definition with my Unity container.<br />\n<pre><code>container.RegisterType&lt;Object, F5472View&gt;(ViewNames.F5472View);\ncontainer.RegisterType&lt;Object, MainMenuView&gt;(ViewNames.MainMenuView);</code></pre>\n\nAnd I use RequestNavigate to change views<br />\n<pre><code>regionManager.RequestNavigate(RegionNames.ContentRegion, ViewNames.F5472View);\nregionManager.RequestNavigate(RegionNames.ContentRegion, ViewNames.MainMenuView);</code></pre>\n\nMy ViewModels for each View currently implement IRegionMemberLifetime and set KeepAlive to true, so I only ever have 1 instance of each view and viewmodel. However I would like to implement INavigationAware so I can some initilization and handle confirmation and saving process before I navigate to or from a view.\r<br />\n<br />\nWhen I implement the interface my navigation breaks. I still RequestNavigate in the same manner but the navigation no longer happens. I believe the issue comes from IsNavigationTarget but I cannot figure out how to use it properly?\r<br />\n<br />\nCan both these interfaces be implemented and used together? Or should only one of them be used? Do these interfaces play nicely with the TransientLifetimeManager and/or ContainerControlledLifetimeManager? Before using the IRegionMemberLifetime I tried using the ContainerControlled and the same issue happened, navigation would fail (no error) despite using the same approach and what seems to be the approach in most tutorials.\r<br />\n<br />\nThanks for any help and insights!<br />\n",
    "PostedDate": "2013-08-13T09:27:55.893-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1080198",
    "ThreadId": "453296",
    "Html": "Hi,\r<br />\n<br />\nAs far as I know, you should be able to implement both <strong>IRegionMemberLifetime</strong> and <strong>INavigationAware</strong> interfaces in your view models without problems.\r<br />\nSo far with the information you provided I am not being able to find what is the cause behind the problem you are experiencing; but as a starting point you could check the following:<br />\n<ul>\n<li>Is your &quot;<strong><em>ContentRegion</em></strong>&quot; an <strong>ItemsControl</strong>? Is so, try changing it to a <strong>ContentControl</strong> and check if this behavior keeps appearing.</li>\n<li>\nIn the <strong>IsNavigationTarget</strong> of your view models try changing between returning <strong><em>true</em></strong> and <strong><em>false</em></strong> to check if this behavior changes depending on that value.<br />\n</li>\n</ul>\nIf there is no new clues after checking those points, then it could be useful if you could provide us with your sample so that we can analyze what is causing the problem in deep.\r<br />\n<br />\nThanks,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-08-13T11:06:36.54-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1080231",
    "ThreadId": "453296",
    "Html": "Thank you for the reply. I am using a ContentControl and I double checked so that was not an issue, but I have been doing what you suggested in trying different values true/false with IsNavigationTarget and KeepAlive values. By doing this (and putting MessageBox's inside the INavigationAware methods, I was able to better see when those methods were being fired).\r<br />\n<br />\nMost interesting is that IsNavigationTarget does not get called on the very first NavigationRequest to the view. Subsequent navigations back and forth do call IsNavigationTarget. I am not sure why but by trying different values and watching the execution I have been able to get the navigation to work they way I would like. This leads to a small follow up question, its not a technical problem as much as a question if this is what the Prism usage was meant to support.\r<br />\n<br />\nI am not using the ContainerControlledLifetimeManager, but rather the TransientLifetimeManager with my Views from this project. However I do want only one instance of the view/viewmodel to be resolved. I am doing this now by using the IRegionMemberLifetime to keep the view in the region, and that same view is being activated if I ever return to it, instead of resolving a new instance (like the TransientLifetimeManager typically does). Is this an appropriate usage of IRegionMemberLifetime or is it more of a hack and am I missing out on benefits of using the proper LifetimeManager? \r<br />\n<br />\nMy biggest reason for trying to avoid the ContainerControlledManager is for future use cases that will have modules with multiple views (this current module has 1 view). In essence every time a user selects an option from the main menu a new instance of the chosen view should be activated, but if that view is split into (3 views for example) the user should be able to go between those 3 views always using the same instances. Once the user returns to the main menu and a new action chosen, a new view should be resolved. It seems that the ContainerControlledLifetimeManager would not allow for that use case.<br />\n",
    "PostedDate": "2013-08-13T12:52:26.85-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1080721",
    "ThreadId": "453296",
    "Html": "Hi,\r<br />\n<br />\nThe first time you navigate to a view its <strong>IsNavigationTarget</strong> method will not be checked, mainly because <strong>Prism</strong> doesn't need to use it at that point. The <strong>IsNavigationTarget</strong> method is used to check if an instance of the required view that is deactivated inside the region is the target of the navigation request, according to the parameters passed, etc. If no view of that type in the region return <strong><em>true</em></strong> in their <strong>IsNavigationTarget</strong> method, then <strong>Prism</strong> will instead create a new instance of said view. At this point, there is no reason to check the <strong>IsNavigationTarget</strong> of the new view, as it has been explicitly created to be the navigation target.\r<br />\n<br />\nWhen navigating using regions you will find that a view can be <strong>active</strong> (it is being shown in the region,) <strong>deactivated</strong> (it is not being shown, but is still kept alive by the region) or <strong>removed</strong> from the region (the region no longer has a reference to the view). The function of the <strong>IRegionMemberLifetime</strong> is to specify if a view should also be removed from the region the moment it's deactivated, or should it be kept deactivated in the region so that it could be reused later. However, this is different from the lifetime you can set in the container.\r<br />\n<br />\nFirst of all, the effect of the <strong>IRegionMemberLifetime</strong> is limited to the region containing the view only and does not have any effect on the instances of different regions. Second, the <strong>IRegionMemberLifetime</strong> will not ensure that the same instance of the view will be used for all the navigation requests in the region, meaning that there could be several instances of the view in the region at the same time. This is where <strong>IsNavigationTarget</strong> comes into play. By keeping the instance alive and returning <strong><em>true</em></strong> in the <strong>IsNavigationTarget</strong> method, Prism will navigate to that existing view instead of creating a new one. Also, you can check the parameters passed in the navigation request before returning <strong><em>true</em></strong> or <strong><em>false</em></strong> in the <strong>IsNavigationRequest</strong>, giving you the flexibility to decide if you want to reuse a view or create a new one.\r<br />\n<br />\nI hope this helps to give a more in deep understanding of the navigation API used by Prism.\r<br />\n<br />\nThanks,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-08-14T13:40:39.64-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1087958",
    "ThreadId": "453296",
    "Html": "Hi Damian,\r<br />\n<br />\nI'm implementing IRegionMemberLifeTime and INavigationAware in my view models in order to being able to reuse views if no refresh is required. So, KeepAlive property returns true and IsNavigationTarget checks the navigation parameters to decide if current instance is suitable to be reused. The point is that there are instances that become no longer userful but still remain as deactivated at region. I've tried to set KeepActive to false at IsNavigationTarget as soon as the instance becomes unusefull but with no success. I'd like to clean up old unuseful instances in order to avoid memory leaks\r<br />\n<br />\nThanks\r<br />\n<br />\nBest Regards\r<br />\n<br />\nDan√≠<br />\n",
    "PostedDate": "2013-09-03T14:59:55.823-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1088343",
    "ThreadId": "453296",
    "Html": "Hi Dani,\r<br />\n<br />\nBased on my understanding, the <strong>RegionMemberLifetimeBehavior</strong> (which is in charge of removing the views with <strong>KeepAlive</strong> = <strong><em>false</em></strong>) only acts when the corresponding view is deactivated. Therefore, if you change the <strong>KeepAlive</strong> property of an already deactivated view, the behavior won't remove it even if the active view was changed. You can see this in the <strong>OnActiveViewsChanged</strong> method of the aforementioned behavior:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">void</span> OnActiveViewsChanged(<span style=\"color:Blue;\">object</span> sender, NotifyCollectionChangedEventArgs e)\n{\n    <span style=\"color:Blue;\">if</span> (e.Action != NotifyCollectionChangedAction.Remove) <span style=\"color:Blue;\">return</span>;\n\n    <span style=\"color:Blue;\">var</span> inactiveViews = e.OldItems;\n    <span style=\"color:Blue;\">foreach</span> (<span style=\"color:Blue;\">var</span> inactiveView <span style=\"color:Blue;\">in</span> inactiveViews)\n    {\n        <span style=\"color:Blue;\">if</span> (!ShouldKeepAlive(inactiveView))\n        {\n            <span style=\"color:Blue;\">this</span>.Region.Remove(inactiveView);\n        }\n    }\n}\r\n</pre></div>A possible approach to discard the unused views could be to manually remove them from the region. For example, when the view no longer is needed, instead of setting the <strong>KeepAlive</strong> property to <strong><em>false</em></strong> it could publish an event using the <strong>EventAggregator</strong>. The parent view model would be subscribed to this event and remove the corresponding view.\r<br />\n<br />\nAnother approach could be to change the aforementioned method of the behavior so that it would check the <strong>KeepAlive</strong> property of all the views and not only of the deactivated one. You can replace the original behavior overriding the <strong>ConfigureDefaultRegionBehaviors</strong> method of you <strong>Bootstrapper</strong>.\r<br />\nYou can find more information about this in the following section of the Prism documentation: <a href=\"http://msdn.microsoft.com/en-us/library/gg430866%28v=pandp.40%29.aspx#sec28\" rel=\"nofollow\">Appendix E - Extending Prism - Region Behaviors</a>\r<br />\n<br />\nThanks,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-09-04T10:28:35.407-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]