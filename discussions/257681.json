[
  {
    "Id": "612958",
    "ThreadId": "257681",
    "Html": "\r\n<p>Hello All, I am currently at a loss for the best way to approach this.&nbsp; Using the UI Composition QuickStart as a guide I am trying to basically create three regions each using the same view and viewmodel but showing different data based on a filter\r\n of Status.&nbsp; I am using MEF and I am setting the creation policy to non-shared so I get multiple instances of the view.&nbsp; I am also using event aggregation as in the UI Composition example to pass data along.&nbsp; In this case a selected Project.&nbsp;\r\n So far I have everything working except the additional filtering of the views in each region.</p>\r\n<p>Here are the objects:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">enum</span> Status {NotStarted, InProgress, Complete};\r\n\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> Task\r\n{\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> Id {<span style=\"color:blue\">get</span>;<span style=\"color:blue\">set</span>;}\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">string</span> Name {<span style=\"color:blue\">get</span>;<span style=\"color:blue\">set</span>;}\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> ProjectId {<span style=\"color:blue\">get</span>;<span style=\"color:blue\">set</span>;}\r\n<span style=\"color:blue\">public</span> Status Status {<span style=\"color:blue\">get</span>;<span style=\"color:blue\">set</span>;}\r\n}\r\n\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> Project\r\n{\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> Id {<span style=\"color:blue\">get</span>;<span style=\"color:blue\">set</span>;}\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">string</span> Name {<span style=\"color:blue\">get</span>;<span style=\"color:blue\">set</span>;}\r\n}\r\n\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> TaskCollection : ObservableCollection&lt;Task&gt;\r\n{ }\r\n</pre>\r\n</div>\r\n<p>I have a &quot;SummaryView&quot; like the UI Comp. example which holds each region:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>&lt;ItemsControl x:Name=&quot;NotStartedTasksItemsControl&quot;\r\n  prism:RegionManager.RegionName=&quot;NotStartedTasksRegion&quot;\r\n  prism:RegionManager.RegionContext=&quot;{Binding CurrentProject}&quot;/&gt;\r\n&lt;ItemsControl x:Name=&quot;InProgressTasksItemsControl&quot; <br>  prism:RegionManager.RegionName=&quot;InProgressTasksRegion&quot;\r\n  prism:RegionManager.RegionContext=&quot;{Binding CurrentProject}&quot;/&gt;\r\n&lt;ItemsControl x:Name=&quot;CompletedTasksItemsControl&quot; <br>  prism:RegionManager.RegionName=&quot;CompletedTasksRegion&quot;\r\n  prism:RegionManager.RegionContext=&quot;{Binding CurrentProject}&quot;/&gt;\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>I am creating regions in ModuleInit.cs as follows:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>_regionManager.RegisterViewWithRegion(RegionNames.NotStartedTasksRegion, () =&gt; _serviceLocator.GetInstance{TaskListView}());\r\n_regionManager.RegisterViewWithRegion(RegionNames.InProgressTasksRegion, () =&gt; _serviceLocator.GetInstance{TaskListView}());\r\n_regionManager.RegisterViewWithRegion(RegionNames.CompletedTasksRegion, () =&gt; _serviceLocator.GetInstance{TaskListView}());\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>{} == &lt; and &gt;</p>\r\n<p>As you can see I am passing the current selected Project to each Region via regioncontext.&nbsp; And using a similar technique to the ui comp. example I do indeed get each region with the list of Tasks for the project.&nbsp; But I would like to filter each\r\n region / view based on the status.&nbsp; Right now it simply repeats the same items in each region.&nbsp;</p>\r\n<p>It is possible my current implementation is wrong and that I should be doing this another way.&nbsp; If so, please let me know.&nbsp; But so far I could not find a way to pass additional information to filter the results by status.&nbsp; I really do not\r\n want to have to create a view/viewmodel for each status, that seems too much.&nbsp; I had thought about using some type of service/controller to pass the additional information, but I would need some way to &quot;trigger&quot; this passing of information.&nbsp;</p>\r\n<p>Some other thoughts that might work:</p>\r\n<p>1. using datatemplate on the tasklist view to somehow filter.&nbsp; <br>\r\n2. some how pass more than selected project in regioncontext? but how to make it know which status to filter on got me stumped.<br>\r\n3. build time machine to go to future in which I have the answer then go back in time to implement it.</p>\r\n<p>If anyone has thoughts on how to best approach this I would be very appreciative.&nbsp; Also, If there is any additional information required please let me know and I will provide it.</p>\r\n<p>Thank you.</p>\r\n",
    "PostedDate": "2011-05-15T06:41:16.573-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "613016",
    "ThreadId": "257681",
    "Html": "<p>Update:&nbsp; Ok I was able to get this to work but it is really hacky and I am not sure if this adheres to the MVVM pattern.</p>\r\n<p>What I am doing is using the event PropertyChanged event on the RegionContext and search out the region name.&nbsp; I then convert the name to the status enum and pass it to the viewmodel.&nbsp; Because this happens before the actual processing of the datacontext it works.&nbsp; But as I said, I do not like this and hope someone else has a better idea.</p>\r\n<p>In the ViewModel code behind:</p>\r\n<p>RegionContext.GetObservableContext(this).PropertyChanged += new PropertyChangedEventHandler(TaskListView_PropertyChanged);<br />void TaskListView_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var r = (RegionManager.GetObservableRegion(this.Parent).Value).Name;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Status status = r.Contains(\"NotStarted\") ? Status.NotStarted : r.Contains(\"InProgress\") ? Status.InProgress : r.Contains(\"Complete\") ? Status.Complete : Status.NotStarted;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ViewModel.Status = status; // &lt;-- Must be before setting Project or it will not filter on this additional criteria.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ViewModel.CurrentProject = RegionContext.GetObservableContext(this).Value as Project;<br />}</p>\r\n<p>I wish there was a more elegant way to pass this additional criteria to the view/viewmodel that is shared among the three regions.&nbsp; Once again any thoughts, help, or information is much appreciated.</p>",
    "PostedDate": "2011-05-15T10:26:20.687-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "613120",
    "ThreadId": "257681",
    "Html": "<p>I think you are trying to do this</p>\r\n<p>- Load a project</p>\r\n<p>- Assign it as the region context for each region</p>\r\n<p>- Each region filters the tasks in the project based on status</p>\r\n<p>The best way to achieve this is using the INavigationAware interface. Since you are using MEF you have an export on the view like below. Your view model implement this interface. And you would load the views in your region as follows</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>[Export(<span style=\"color: #a31515;\">\"MyView\"</span>)]\r\n[PartCreationPolicy(CreationPolicy.NonShared)]\r\n<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">partial</span> <span style=\"color: blue;\">class</span> MyView : UserControl\r\n{\r\n   [ImportingConstructor]\r\n   <span style=\"color: blue;\">public</span> MyView(IMyViewModel viewModel)\r\n   {\r\n       InitializeComponent();\r\n       DataContext = viewModel;\r\n   }\r\n}\r\n\r\n[Export(<span style=\"color: blue;\">typeof</span>(IMyViewModel))]\r\n[PartCreationPolicy(CreationPolicy.NonShared)]\r\n<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">class</span> MyViewModel : IMyViewModel, INaviagtionAware\r\n{\r\n   <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">string</span> _status;\r\n\r\n  <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> OnNavigatedTo(NavigationContext navigationContext)\r\n{\r\n  <strong>_status = navigationContext.Parameters[<span style=\"color: #a31515;\">\"Status\"</span>];</strong>\r\n}\r\n <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">bool</span> IsNavigationTarget(NavigationContext navigationContext)\r\n        {\r\n            <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">true</span>;\r\n        }\r\n\r\n        <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> OnNavigatedFrom(NavigationContext navigationContext)\r\n        {\r\n            \r\n        }\r\n}\r\n\r\n[ModuleExport(<span style=\"color: #a31515;\">\"MyModule\"</span>, <span style=\"color: blue;\">typeof</span>(Module))]\r\n<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">class</span> Module : IModule\r\n    {\r\n        <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> Initialize(IRegionManager regionManager)\r\n        {\r\n            _regionManager.RequestNavigate(RegionNames.NotStartedTasksRegion, <span style=\"color: blue;\">new</span> Uri(<span style=\"color: #a31515;\">\"MyView\"</span> + <span style=\"color: blue;\">new</span> UriQuery {{<span style=\"color: #a31515;\">\"Status\"</span>, Status.NotStarted}}, UriKind.Relative));\r\n_regionManager.RequestNavigate(RegionNames.InProgressTasksRegion, <span style=\"color: blue;\">new</span> Uri(<span style=\"color: #a31515;\">\"MyView\"</span> + <span style=\"color: blue;\">new</span> UriQuery {{<span style=\"color: #a31515;\">\"Status\"</span>, Status.InProgress}}, UriKind.Relative));\r\n_regionManager.RequestNavigate(RegionNames.CompletedTasksRegion, <span style=\"color: blue;\">new</span> Uri(<span style=\"color: #a31515;\">\"MyView\"</span> + <span style=\"color: blue;\">new</span> UriQuery {{<span style=\"color: #a31515;\">\"Status\"</span>, Status.Completed}}, UriKind.Relative));\r\n        }\r\n    }\r\n\r\n</pre>\r\n</div>\r\n</p>\r\n<p>If you see above in the Module Initialize I'm using RequestNavigate and loading views into the regions. Here you can make use of the UriQuery to pass parameters to each view/viewmodel which implements INaviagtionAware. The above code will create new instances of the view/view model in the regions and pass different parameters to them. Now in your view model OnNavigatedTo you will pick the Status from the navigationContext and apply that as a filter on your regionContext (CurrentProject).</p>\r\n<p>Hope this helps.</p>\r\n<p>Cheers.</p>",
    "PostedDate": "2011-05-15T22:25:25.007-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "613317",
    "ThreadId": "257681",
    "Html": "<p>Hello gan_s,</p>\r\n<p>Thank you for your reply.&nbsp; I did not think about using INavigationAware.&nbsp; For some reason I was stuck on one way of doing things.&nbsp; I did try to implement your idea and initially it did not work.&nbsp; But then I moved the calls to RequestNavigate to my controller class and it worked?&nbsp; I am not sure why that would be.&nbsp; The controller class is very similar to the MainRegionController.cs class in the UI Composition QuickStart.&nbsp; I added the calls to RequestNavigate right after setting the view's datacontext:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\">//...</span>\r\n<span style=\"color: green;\">// Set the current project property on the view model.</span>\r\nTaskSummaryViewModel viewModel = view.DataContext <span style=\"color: blue;\">as</span> TaskSummaryViewModel;\r\n\r\n<span style=\"color: blue;\">if</span> (viewModel != <span style=\"color: blue;\">null</span>)\r\n{\r\n    viewModel.CurrentProject = selectedProject;\r\n}\r\n            <span style=\"color: blue;\">this</span>.regionManager.RequestNavigate(RegionNames.NotStartedTasksRegion, <span style=\"color: blue;\">new</span> Uri(<span style=\"color: #a31515;\">\"TaskListView\"</span> + <span style=\"color: blue;\">new</span> UriQuery { { <span style=\"color: #a31515;\">\"Status\"</span>, TaskStatus.NotStarted.ToString() } }, UriKind.Relative));\r\n<span style=\"color: green;\">//...</span>\r\n</pre>\r\n</div>\r\n</p>\r\n<p>Not sure why it would work here, but not in the ModuleInit class.&nbsp; Will need to do some digging.&nbsp; But thank you for this information, definitely feels better than the method I was using.</p>\r\n<p>aromano</p>",
    "PostedDate": "2011-05-16T05:47:36.5-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "613365",
    "ThreadId": "257681",
    "Html": "<p>Glad it works for you. To debug inject the aggregatecatalog in the Module constructor. Then before doing the RequestNavigate in the Initialize just check the Parts in the aggregatecatalog that have been downloaded. If your view you are trying to navigate to does not show up in it then it probably hasnt been composed yet and thats why you're RequestNavigate did not work in the Initialize. If not then something to look further into :) !</p>",
    "PostedDate": "2011-05-16T07:19:41.78-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]