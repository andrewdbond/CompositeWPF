[
  {
    "Id": "624432",
    "ThreadId": "260542",
    "Html": "\r\n<p>Dear experts,</p>\r\n<p>My goal is to assign a region to an itemscontrol and populate this region with multiple instances of the same view, each instance contains different data from the underlying model. I'm working according to the MVVM pattern, so my view has an associated view\r\n model and a model. To make things more concrete I will explain my situation by an example.</p>\r\n<p>Consider a canvas in which I want to show rectangles. Because each rectangle has quite some logic I didn't want to put all this in a DataTemplate. Therefore I created a view and viewmodel that define a single rectangle. At first the ViewModel had a constructor\r\n which has a 'Model model' parameter, but as MEF is unable to import views that require a parameter this could not hold. When reading through the documentation I saw that it is possible to pass parameters using the RequestNavigate() method so I went ahead and\r\n implemented it this way:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>        <span style=\"color:blue\">&lt;</span><span style=\"color:#a31515\">ItemsControl</span>\r\n            <span style=\"color:red\">Style</span><span style=\"color:blue\">=</span><span style=\"color:black\">&quot;</span><span style=\"color:blue\">{StaticResource NoScrollViewerItemsControlStyle}</span><span style=\"color:black\">&quot;</span>\r\n            <span style=\"color:red\">prism:RegionManager.RegionName</span><span style=\"color:blue\">=</span><span style=\"color:black\">&quot;</span><span style=\"color:blue\">TestRegion</span><span style=\"color:black\">&quot;</span>\r\n            <span style=\"color:blue\">/&gt;</span>\r\n</pre>\r\n</div>\r\n<p>The NoScrollViewerItemsControlsStyle modifies the itemscontrol in such a way that it is possible to place the rectangle views on a canvas.</p>\r\n<p>Now to populate this items control I used:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>foreach(var rectangle in RectangleModel.Rectangles)<br>       _regionManager.RequestNavigate(<span style=\"color:#a31515\">&quot;TestRegion&quot;</span>,\r\n                    <span style=\"color:blue\">new</span> Uri(<span style=\"color:#a31515\">&quot;RectangleView?Id=&quot;</span> &#43; rectangle.Id, UriKind.Relative));<br><br></pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Now by implementing the INavigationAware interface on the RectangleViewModel it is possible to pass the right model to the RectangleViewModel by implementing the OnNavigatedTo method correctly.</p>\r\n<p>Before I started doing that i first implemented the IsNavigationTarget as follows</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>        <span style=\"color:blue\">public</span> <span style=\"color:blue\">bool</span> IsNavigationTarget(NavigationContext navigationContext)\r\n        {\r\n            <span style=\"color:blue\">return</span> <span style=\"color:blue\">false</span>;\r\n        }\r\n</pre>\r\n</div>\r\nto make sure the itemscontrol gets filled with all of my RectangleViews. (If i did not do this only one view was added)\r\n<p></p>\r\n<p>But it isn't :-(. It comes up with the following error:</p>\r\n<p><strong>View already exists in region.</strong></p>\r\n<p><strong>Q: What am I doing wrong? I guess it should be possible to load multiple views into the itemscontrol</strong></p>\r\n<p><br>\r\n<strong>&nbsp;</strong>Many thanks in advance!</p>\r\n",
    "PostedDate": "2011-06-07T14:47:12.02-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "624706",
    "ThreadId": "260542",
    "Html": "<p>Ok I'm a bit further now.</p>\r\n<p>I went on reading the documentation after feeling bad about using Navigation techniques to populate the itemscontrol, because if you think about it it isn't really navigation. It was only some sort of hack because MEF's view discovery doesn't support loading views who's viewmodel requires parameters. (In my case the associated model). I found the following passage [Page 91 of Prismv4.pdf documentation]:</p>\r\n<p>Use view injection in the following situations:<br />(...)<br />You need to display multiple instances of the same views in a region, where each view instance is bound to different data.<br />(...)</p>\r\n<p>So view injection is the technique I'm looking for. Unfortunately the documentation only requests a view from the container by talking to the container directly as shown below:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\">// View injection</span>\r\nIRegion region = regionManager.Regions[<span style=\"color: #a31515;\">\"MainRegion\"</span>];\r\n<span style=\"color: blue;\">var</span> ordersView = container.Resolve&lt;OrdersView&gt;();\r\nregion.Add(ordersView, <span style=\"color: #a31515;\">\"OrdersView\"</span>);\r\nregion.Activate(ordersView);\r\n</pre>\r\n</div>\r\n<p>Maybe I'm wrong but having the container reference published throughout the application for this kind of stuff doesn't feel right. I searched this forum for a solution and found the following:<br />http://compositewpf.codeplex.com/discussions/239160</p>\r\n<p>&nbsp;</p>\r\n<p>They use the ServiceLocator to obtain a view from MEF. With this my actual code became:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>            <span style=\"color: blue;\">foreach</span> (IRectangle rectangle <span style=\"color: blue;\">in</span> modelSource.Rectangles)\r\n            {\r\n                <span style=\"color: blue;\">var</span> view = ServiceLocator.Current.GetInstance&lt;RectangleView&gt;();\r\n                view.ViewModel.Model = rectangle;\r\n                IRegion region = _regionManager.Regions[<span style=\"color: #a31515;\">\"TestRegion\"</span>];\r\n                region.Add(view);\r\n            }\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Now, as expected setting a breakpoint on the IRegion = region line I see a instance requested via MEF of RectangleView of which the ViewModel is property is populated by MEF also, great!<br />The Model propety of the ViewModel is also set.<br /><br />But now I still get the same warning: <strong>View already exists in region. </strong>when the second rectangle view is added to the itemscontrol!?! I don't get it!</p>\r\n<p>The documentation even has an example in which they do roughly the same (Page 296):</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>ActivityView activityView1 = Container.Resolve&lt;ActivityView&gt;();\r\nActivityView activityView2 = Container.Resolve&lt;ActivityView&gt;();\r\nactivityView1.CustomerId = <span style=\"color: #a31515;\">\"Customer1\"</span>;\r\nactivityView2.CustomerId = <span style=\"color: #a31515;\">\"Customer2\"</span>;\r\nIRegion rightRegion = RegionManager.Regions[<span style=\"color: #a31515;\">\"RightRegion\"</span>];\r\nrightRegion.Add(activityView1);\r\nrightRegion.Add(activityView2);\r\n</pre>\r\n</div>\r\n</p>\r\n<p><strong>What goes wrong?</strong></p>",
    "PostedDate": "2011-06-08T06:27:31.643-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "624717",
    "ThreadId": "260542",
    "Html": "<p>Hi,</p>\r\n<p>The problem you're experiencing might be caused by the fact that you have registered your <strong>RectangleView </strong>as a singleton instance.</p>\r\n<p>When you call the <strong>RequestNavigate</strong> method, the navigation mechanism internally uses the service locator to retrieve an instance of your view. If you are using MEF and you have registered your view as a Shared instance (which is the default behavior the <strong>Export</strong> attribute has), the service locator will retrieve the same instance on each request, thus causing the error you're experiencing.</p>\r\n<p>You could try decorating your class with the <strong>PartCreationPolicy</strong> attribute, and specify that the creation policy is <strong>NonShared</strong>. To illustrate this:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>[Export(<span style=\"color: #a31515;\">\"RectangleView\"</span>)]\r\n[PartCreationPolicy(CreationPolicy.NonShared)]\r\n<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">class</span> RectangleView\r\n\r\n{\r\n\r\n(...)\r\n\r\n}</pre>\r\n</div>\r\n<p>I hope you find this helpful.</p>\r\n<p>Guido Leandro Maliandi <br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-06-08T06:39:17.023-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "624746",
    "ThreadId": "260542",
    "Html": "<p>Hello mister Maliandi!</p>\r\n<p>Thank you very much for your reply. This was indeed the problem and it's now working as expected!! :-) Woehoe!!</p>\r\n<p>I stay with the view-injection approach as it is better than 'misusing' the Navigation functionality for my goal.</p>\r\n<p>The only 'problem'&nbsp; I now experience with view injection as compared to view discovery is that the <strong>_regionManager.RegisterViewWithRegion()</strong> function waits untill the region is added to visual tree before it applies view discovery. By using view injection, and thus directly assigning views by calling <strong>_regionManager.AddToRegion()</strong> I have to do this myself. What i have came up with is the following:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>_regionManager.Regions.CollectionChanged += Regions_CollectionChanged;\r\n</pre>\r\n</div>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>        <span style=\"color: blue;\">void</span> Regions_CollectionChanged(<span style=\"color: blue;\">object</span> sender, NotifyCollectionChangedEventArgs e)\r\n        {\r\n            <span style=\"color: blue;\">if</span> (e.Action == NotifyCollectionChangedAction.Add)\r\n            {\r\n                <span style=\"color: blue;\">foreach</span> (<span style=\"color: blue;\">var</span> newItem <span style=\"color: blue;\">in</span> e.NewItems)\r\n                {\r\n                    IRegion addedRegion = (IRegion) newItem;\r\n                    <span style=\"color: blue;\">if</span> (addedRegion.Name == <span style=\"color: #a31515;\">\"TestRegion\"</span>)\r\n                    {\r\n                        populateViews();\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">void</span> populateViews()\r\n        {\r\n<pre>            <span style=\"color: blue;\">foreach</span> (IRectangle rectangle <span style=\"color: blue;\">in</span> modelSource.Rectangles)\r\n            {\r\n                <span style=\"color: blue;\">var</span> view = ServiceLocator.Current.GetInstance&lt;RectangleView&gt;();\r\n                view.ViewModel.Model = rectangle;\r\n                IRegion region = _regionManager.Regions[<span style=\"color: #a31515;\">\"TestRegion\"</span>];\r\n                region.Add(view);\r\n            }</pre>\r\n}</pre>\r\n</div>\r\n<p>Is this the recommended approach for view injection or am i missing something trivial?</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks!</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-06-08T07:16:49.343-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "624838",
    "ThreadId": "260542",
    "Html": "<p>Hi,</p>\r\n<p>The approach you're following is a valid possiblity to achieve the proposed scenario using view injection.</p>\r\n<p>I hope you find this helpful.</p>\r\n<p>Guido Leandro Maliandi <br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-06-08T10:01:19.2-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "624881",
    "ThreadId": "260542",
    "Html": "<p>Thank you very much again.</p>\n<p>I stumbled upon another issue I need some hints/tips for. With my itemscontrol now correctly filled I want to create another itemscontrol that is filled with the same views. The purpose of this new itemscontrol is to be scaled such that all rectangles fit  into a small overview window:</p>\n<p>&nbsp;</p>\n<div style=\"color: black; background-color: white;\">\n<pre>            <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">ItemsControl</span>\n                <span style=\"color: red;\">Style</span><span style=\"color: blue;\">=</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">{StaticResource NoScrollViewerItemsControlStyle}</span><span style=\"color: black;\">\"</span>\n                <span style=\"color: red;\">prism:RegionManager.RegionName</span><span style=\"color: blue;\">=</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">MainRegion</span><span style=\"color: black;\">\"</span> &lt;!-- Original TestRegion --&gt;\n                <span style=\"color: blue;\">/&gt;</span>\n\n            <span style=\"color: green;\">&lt;!-- The code to resize this itemscontrol (and with that all it's containing items) down is in place and working correctly --&gt;</span>\n            <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">ItemsControl</span>\n                <span style=\"color: red;\">Style</span><span style=\"color: blue;\">=</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">{StaticResource NoScrollViewerItemsControlStyle}</span><span style=\"color: black;\">\"</span>\n                <span style=\"color: red;\">prism:RegionManager.RegionName</span><span style=\"color: blue;\">=</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">OverviewRegion</span><span style=\"color: black;\">\"</span>\n                <span style=\"color: blue;\">/&gt;</span>\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>Now to fill both itemscontrol with the same views my approach is as follows:</p>\n<p>&nbsp;</p>\n<div style=\"color: black; background-color: white;\">\n<pre>        <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">void</span> PopulateViews()\n        {\n            IRegion mainRegion = _regionManager.Regions[<span style=\"color: #a31515;\">\"MainRegion\"</span>];\n            IRegion overviewRegion = _regionManager.Regions[<span style=\"color: #a31515;\">\"OverviewRegion\"</span>];\n\n            <span style=\"color: blue;\">foreach</span> (IRectangle rectangle <span style=\"color: blue;\">in</span> modelSource.Rectangles)\n            {\n                <span style=\"color: blue;\">var</span> view = ServiceLocator.Current.GetInstance&lt;RectangleView&gt;();\n                view.ViewModel.Model = rectangle;\n                mainRegion.Add(view);\n                overviewRegion.Add(view);\n            }\n        }\n</pre>\n</div>\n<p>I also adjusted Regions_CollectionChanged to start PopulateViews() only when both mentioned regions are registered in the visual tree.<br /> <br /> Unfortunately the result is that only the region to which the views have been added as last (in this case the OverviewRegion) will show the views, so the MainRegion becomes empty.<br /> I tried added 'mainRegion.Activate(view)', but this has no effect. The weird thing is that when debugging I do see all the rectangles present in both <strong>mainRegion.ActiveViews</strong> and <strong>overviewRegion.ActiveViews. </strong> When i alter the method to the following:</p>\n<p>&nbsp;</p>\n<div style=\"color: black; background-color: white;\">\n<pre>        <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">void</span> PopulateViews()\n        {\n            IRegion mainRegion = _regionManager.Regions[<span style=\"color: #a31515;\">\"MainRegion\"</span>];\n            IRegion overviewRegion = _regionManager.Regions[<span style=\"color: #a31515;\">\"OverviewRegion\"</span>];\n\n            <span style=\"color: blue;\">foreach</span> (IRectangle rectangle <span style=\"color: blue;\">in</span> modelSource.Rectangles)\n            {\n                <span style=\"color: blue;\">var</span> view = ServiceLocator.Current.GetInstance&lt;RectangleView&gt;();\n                view.ViewModel.Model = rectangle;\n                mainRegion.Add(view);\n\n                <span style=\"color: blue;\">var</span> view2 = ServiceLocator.Current.GetInstance&lt;RectangleView&gt;();\n                view2.ViewModel.Model = rectangle;\n                overviewRegion.Add(view2);\n            }\n        }\n</pre>\n</div>\n<p>It works but this 'fix' means having a lot unnecessarily view and viewmodel copies.<strong><br /> </strong></p>\n<p>&nbsp;</p>\n<p>Do i have to work with scoped regions for this to work? I read about them in the manual but they do not seem to apply to my situation.</p>\n<p>Hope someone can help!</p>\n<p>Many thanks.<br /> <br /></p>\n<p>Note: If someone feels this has to be in a separate thread I will make one, but I also do not want to spam these forums :-)</p>",
    "PostedDate": "2011-06-08T11:20:37.93-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "624898",
    "ThreadId": "260542",
    "Html": "<p>Hi,</p>\r\n<p>It's OK to post the question in this thread. You can't have the same instance of a view added two times to the visual tree. In order to achieve the scenario you're mentioning, you need to add two different instances of the view.</p>\r\n<p>I hope you find this helpful.</p>\r\n<p>Guido Leandro Maliandi <br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-06-08T11:52:53.313-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "624909",
    "ThreadId": "260542",
    "Html": "<p>Thanks again for your quick response.</p>\n<p>Hmmm interesting, are the views added to the visual tree when assigning them to a region? I thought, at least in case of the itemscontrol, they get collected in the Region.Views property, then, when activated added to the Region.ActiveViews property and  this is somehow bound to the itemscontrol ItemsSource property. [This could explain why the ItemsSource must be unspecified when defining a region.]</p>\n<p>In my situation adding different instances of the views to each usercontrol will mean a lot of extra objects. Therefore I ditched the regions for the itemscontrols and instead created a public ObservableCollection property which gets filled with the views  by view injection (is this still called view injection now?).</p>\n<p>&nbsp;</p>\n<div style=\"color: black; background-color: white;\">\n<pre>        <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">void</span> PopulateViews()\n        {\n            <span style=\"color: blue;\">foreach</span> (IRectangle rectangle <span style=\"color: blue;\">in</span> modelSource.Rectangles)\n            {\n                <span style=\"color: blue;\">var</span> view = ServiceLocator.Current.GetInstance&lt;RectangleView&gt;();\n                view.ViewModel.Model = rectangle;\n                MyObservColl.Add(view);\n            }\n        }\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>This new property is then bound to the ItemsSource of both itemscontrols. This works ok, i think having regions for my situation was a little bloated after all as the regions would never contain other views than these rectangles.</p>\n<p>I am still curious what you think about this final solution.</p>\n<p>Many thanks</p>\n<p>&nbsp;</p>\n<p><strong>------- EDIT ------</strong></p>\n<p>Whoops, I am terribly sorry. Now that i have worked it out completely it seems like binding the same ObservableCollection to both itemcontrols ItemsSource also only let the last bounded itemscontrol view the items. The only solution is to don't share the collection and thus making a new one for the second itemscontrol. You were right... SORRY.</p>\n<p>I guess i will have to go that way then, I will stay with data binding instead of using regions for the aforementioned reason.</p>",
    "PostedDate": "2011-06-08T12:20:42.76-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]