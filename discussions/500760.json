[
  {
    "Id": "1169460",
    "ThreadId": "500760",
    "Html": "Gostrowsky, asked me to repost this here from the Prism v1.0 thread:<br />\n<br />\nThe CommandParameter is passed as a null to the CanExecute method when using an MVVM architecture to generate the ContextMenus.  The regular commands seem to function properly if the CanExecute function is disabled (which isn't really an option).<br />\n<br />\nI've got a View Model used to generate the context menu (as per the MVVM goals).  The code that creates the context menu looks like this:<br />\n<pre><code>                    &lt;Grid&gt;\n                        &lt;Grid.ContextMenu&gt;\n                            &lt;ContextMenu ItemsSource=&quot;{Binding ListViewMenuItems}&quot;/&gt;\n                        &lt;/Grid.ContextMenu&gt;\n                    &lt;/Grid&gt;</code></pre>\n\nThe DataTemplate used to create the menu items looks like this:<br />\n<pre><code>        &lt;Style.Resources&gt;\n            &lt;DataTemplate DataType=&quot;{x:Type local:MenuItemViewModel}&quot;&gt;\n                &lt;MenuItem Header=&quot;{Binding Header}&quot;\n                          Icon=&quot;{Binding Icon}&quot;\n                          CommandParameter=&quot;{Binding CommandParameter}&quot;\n                          Command=&quot;{Binding Command}&quot;/&gt;\n            &lt;/DataTemplate&gt;\n        &lt;/Style.Resources&gt;</code></pre>\n\nand, finally, the View Model for the menu items looks like this:<br />\n<pre><code>    public class MenuItemViewModel : NotificationObject\n    {\n        private Object headerField;\n        private Object iconField;\n        private ICommand commandField;\n        private Object commandParameterField;\n\n        public Object Header\n        {\n            get\n            {\n                return this.headerField;\n            }\n            set\n            {\n                if (this.headerField != value)\n                {\n                    this.headerField = value;\n                    this.RaisePropertyChanged(&quot;Header&quot;);\n                }\n            }\n        }\n\n        public Object Icon\n        {\n            get\n            {\n                return this.iconField;\n            }\n            set\n            {\n                if (this.iconField != value)\n                {\n                    this.iconField = value;\n                    this.RaisePropertyChanged(&quot;Icon&quot;);\n                }\n            }\n        }\n\n        public ICommand Command\n        {\n            get\n            {\n                return this.commandField;\n            }\n            set\n            {\n                if (this.commandField != value)\n                {\n                    this.commandField = value;\n                    this.RaisePropertyChanged(&quot;Command&quot;);\n                }\n            }\n        }\n\n        public Object CommandParameter\n        {\n            get\n            {\n                return this.commandParameterField;\n            }\n            set\n            {\n                if (this.commandParameterField != value)\n                {\n                    this.commandParameterField = value;\n                    this.RaisePropertyChanged(&quot;CommandParameter&quot;);\n                }\n            }\n        }\n    }</code></pre>\n\nAnd the implementation of the MenuItemViewModel property looks like like this:<br />\n<pre><code>        public override ObservableCollection&lt;Object&gt; ListViewMenuItems\n        {\n            get\n            {\n                var list = new ObservableCollection&lt;Object&gt;();\n                list.Add(new MenuItemViewModel\n                {\n                    Header = &quot;Delete&quot;,\n                    Command = GlobalCommands.Delete,\n                    CommandParameter = this\n                });\n                return list;\n            }\n        }</code></pre>\n\nNote that the delete command is a CompositeCommand and the CommandParameter is set to the ViewModel that I want to be passed to the command handler to determine if it can be deleted.  The CommandParameter will always be set and will always point to a valid view model.<br />\n<br />\nThe first time, and then randomly after the first time, the DelegateCommand CanExecute handler gets a null when it is called:<br />\n<pre><code>            this.deleteCommandField = new DelegateCommand&lt;IExplorerItem&gt;(this.DeleteItem, this.CanDeleteItem);\n            GlobalCommands.Delete.RegisterCommand(this.deleteCommandField);</code></pre>\n\n<pre><code>        private Boolean CanDeleteItem(IExplorerItem explorerItem)\n        {\n            CustomerNode customerNode = explorerItem as CustomerNode;\n            if (customerNode != null)\n            {\n                return customerNode.Children.Count == 0;\n            }\n            return false;\n        }</code></pre>\n\n",
    "PostedDate": "2014-01-15T09:06:58.48-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1174241",
    "ThreadId": "500760",
    "Html": "Hi DRAirey1,\r<br />\n<br />\nAn answer has been posted on the thread you mentioned above regarding the CommandParamater's behaviour:<br />\n<h1></h1>\n<ul>\n<li>\n<a href=\"https://compositewpf.codeplex.com/discussions/47338\" rel=\"nofollow\">Patch available: Automatically call RaiseCanExecuteChanged() when CommandParameter changes</a><br />\n</li>\n</ul>\nHowever, I noticed that the problem you describe slightly differs from the other discussion. It seems that you are able to get the <strong><em>CanExecute</em></strong> command called. Instead, you are getting null parameters sometimes, but sometimes the parameter is properly set, is this correct?\r<br />\n<br />\nThe reason of getting a null reference the first time would be related to the initialization order. I would suggest you to verify if you set the <strong>DataContext</strong> <strong>ViewModel</strong> after initializing the <strong>View</strong> component, and the <strong><em>CommandParameter's</em></strong> <strong>ViewModel</strong> was already instantiated.\r<br />\n<br />\nFollowing Damian's solution in the disscussion linked above, in order to call the <strong><em>canExecute</em></strong> method when the <strong>CommandParameter</strong> changes, you could trigger the <strong><em>RaiseCanExecuteChanged</em></strong> event by listening to the List <strong><em>SelectionChanged</em></strong> or <strong><em>CollectionChanged</em></strong> event.\r<br />\n<br />\nI hope this helps you,\r<br />\nRegards.\r<br />\n<br />\nGabriel Ostrowsky\r<br />\n<a href=\"https://blogs.southworks.net/gostrowsky\" rel=\"nofollow\">https://blogs.southworks.net/gostrowsky</a><br />\n",
    "PostedDate": "2014-01-17T09:13:55.95-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1185622",
    "ThreadId": "500760",
    "Html": "Hello DRAirey1,\r<br />\n<br />\nI am able to reproduce the passing of null in the CommandParameter the first time CanExecute is called on the DelegateCommand. However, I haven't been able to reproduce the random passing of null. I always see a non-null parameter being passed to CanExecute after the initial call.\r<br />\n<br />\nMy bigger concern is how you are using CompositeCommand in the first place. \r<br />\nCompositeCommand is meant to aggregate the functionality of child ICommand instances. For example, if you had multiple controls on your app surface at the same time, all with the ability to delete, you could register all these delete commands with a composite delete command. The composite delete command would not pass any context (command parameter) to its registered child commands. The composite command would simply listen to CanExecuteChanged events of all of its children and respond by calling CanExecute on all of its children and if all return true, then the composite command's CanExecute would return true, raising the CanExecuteChanged if necessary). You can see here that the composite command would not have context of all the various things that could be deleted. It merely aggregates the enablement of all its registered child commands.\r<br />\n<br />\n-Francis<br />\n",
    "PostedDate": "2014-01-20T17:11:05.583-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1188408",
    "ThreadId": "500760",
    "Html": "Also, there seems to be a problem with CommandParameter binding order. Sounds like once Command is bound, CanExecute is called. If CommandParameter isn't bound yet, null gets passed.\r<br />\n<br />\n<a href=\"http://stackoverflow.com/questions/335849/wpf-commandparameter-is-null-first-time-canexecute-is-called\" rel=\"nofollow\">http://stackoverflow.com/questions/335849/wpf-commandparameter-is-null-first-time-canexecute-is-called</a><br />\n",
    "PostedDate": "2014-01-21T12:32:22.01-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]