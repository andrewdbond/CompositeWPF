[
  {
    "Id": "677198",
    "ThreadId": "273991",
    "Html": "\r\n<p>Hi there,</p>\r\n<p>I am attempting to introduce versioning to my PRISM-based application and I am struggling to understand what effect the &quot;Version&quot; property in my module catalog has - because no matter what value I set in there, and no matter what version I have set on my\r\n Module XAP assemblies, the modules are loaded without error. I would have expected my application to throw an error if I specified an invalid version.</p>\r\n<p>I have my modules defined in a module catalog, like so:</p>\r\n<p>&nbsp;&nbsp;&nbsp; &lt;Modularity:ModuleInfoGroup InitializationMode=&quot;WhenAvailable&quot;&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Modularity:ModuleInfo Ref=&quot;CBS_ResearchBrowser_AdvancedSearch.xap&quot; ModuleName=&quot;AdvancedSearchImpl&quot; ModuleType=&quot;CBS_ResearchBrowser_AdvancedSearch.AdvancedSearchImpl, CBS_ResearchBrowser_AdvancedSearch,\r\n<strong>Version=1.0.0.0</strong>, Culture=neutral, PublicKeyToken=null&quot; /&gt;<br>\r\n&nbsp; &nbsp; ...</p>\r\n<p>&nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>\r\n&nbsp;&nbsp;&nbsp; &lt;/Modularity:ModuleInfoGroup&gt;&nbsp;&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>In my bootstrapper, I read this catalog as follows and it works OK:</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override IModuleCatalog CreateModuleCatalog()<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var catalog = Microsoft.Practices.Prism.Modularity.ModuleCatalog.CreateFromXaml(new Uri(&quot;/CBS_ResearchBrowser;component/ModuleCatalog.xaml&quot;, UriKind.Relative));<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return catalog;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;</p>\r\n<p>In the assembly.cs of each of my modules, I have the Assembly version defined as &quot;1.0.*&quot; - so the version number changes/refreshes each time I do a new build. Therefore, I don't understand how my application is able to load my modules, when I have specified\r\n Version=1.0.0.0 - because no such version of the XAP files exist !</p>\r\n<p>Am I missing something? Ideally I would like to be able to specify the appropriate version of each of my Modules in the Catalog XAML, which would allow me the flexibility to drop in and specify new versions of individual modules. Surely this is possible?</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks,</p>\r\n<p>Joe.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<div id=\"_mcePaste\" style=\"left:-10000px; top:0px; width:1px; height:1px; overflow:hidden\">\r\n&nbsp;&nbsp;&nbsp; &lt;/Modularity:ModuleInfoGroup&gt;&nbsp;</div>\r\n",
    "PostedDate": "2011-09-27T08:10:50.247-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "677373",
    "ThreadId": "273991",
    "Html": "<p>Hi,</p>\r\n<p>As far as I know, this behavior you are describing could appear when using <strong>MEF</strong>.</p>\r\n<p>Based on my understanding, <strong>MEF</strong> uses the <strong>ModuleName</strong> property to find and resolve modules without requiring the <strong>ModuleType</strong> property. Therefore, as the <strong>version</strong> is specified in the <strong>ModuleType</strong> property, <strong>MEF</strong> does not take the <strong>version</strong> into account when finding modules. On the other hand, when using <strong>Unity</strong>, the <strong>ModuleType</strong> property is required to obtain the modules, so if the <strong>version</strong> changes, <strong>Unity</strong> should not be able to find them.</p>\r\n<p>If this is your scenario, you might find the following thread useful where a similar issue is addressed:</p>\r\n<ul>\r\n<li><a href=\"http://compositewpf.codeplex.com/discussions/247248\">Module loading error (Unable to locate the module with type ...)</a></li>\r\n</ul>\r\n<p>I hope you find this useful,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\" target=\"_blank\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2011-09-27T13:42:15.263-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "677621",
    "ThreadId": "273991",
    "Html": "<p>Thanks Damian,</p>\r\n<p>I think you are right - the thread you linked to looks just like the problem I am having.</p>\r\n<p>The \"solution\" posted however, is a little sketchy on detail. It mentions that the following single line of code is placed into a Custom Module Initializer.</p>\r\n<pre><strong>Type type = Type.GetType(moduleInfo.ModuleType, <span style=\"color: blue;\">false</span>, <span style=\"color: blue;\">true</span>);</strong></pre>\r\n<p>My question is - where exactly do I put this code and what is a Custom Module Initializer? I assume this custom class would over-ride the MEF ModuleInitializer somehow? I don't have much custom code in my application really. My bootstrapper class extends <strong>MefBootstrapper</strong> and that's about it (code posted below). Where/how would I integrate a custom module initializer?</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><strong></strong><br /><br />&nbsp;&nbsp;&nbsp; public class ResearchBrowserBootStrapper : MefBootstrapper<br />&nbsp;&nbsp;&nbsp; {<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void InitializeShell()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.InitializeShell();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set the visual root of the Silverlight application<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the Shell (application's main view)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application.Current.RootVisual = (UIElement)Shell;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override DependencyObject CreateShell()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Container.GetExportedValue&lt;Shell&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void ConfigureAggregateCatalog()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.ConfigureAggregateCatalog();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Prism's AggregateCatalog is a catalog of all MEF composable parts within the application.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We add the parts corresponding to the current assembly to it<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AggregateCatalog.Catalogs.Add(new AssemblyCatalog(typeof(CommonModule).Assembly));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AggregateCatalog.Catalogs.Add(new AssemblyCatalog(this.GetType().Assembly));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override IModuleCatalog CreateModuleCatalog()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var modules = Microsoft.Practices.Prism.Modularity.ModuleCatalog.CreateFromXaml(new Uri(\"/CBS_ResearchBrowser;component/ModuleCatalog.xaml\", UriKind.Relative));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return modules;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />}\r\n<br /><br /><br /></pre>\r\n</div>",
    "PostedDate": "2011-09-28T03:35:03.713-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "677708",
    "ThreadId": "273991",
    "Html": "<p>Hi,</p>\r\n<p>The module initializer <em>\"Handles loading of a module based on a type\"</em>, that is to say, it is responsible for obtaining the class that implements the <strong>IModule </strong>interface from your module's project, and calling the <strong>Initialize </strong>method.</p>\r\n<p>In the case of MEF, since module initialization is done through a different mechanism, there is a <strong>MefModuleInitializer</strong>, which inherits from the <strong>ModuleInitializer</strong> class. Following the suggestion from Adrien in the aforementioned thread, you could place the line he mentioned inside the <strong>MefModuleInitializer.CreateModule</strong> method. If you wish to avoid modifying the Prism Library, you could create a class of your own that inherits from the <strong>MefModuleInitializer</strong> class, overrides the <strong>CreateModule </strong>method and performs the check mentioned by Adrien. As mentioned in the <strong>MefModuleInitializer</strong> class description,</p>\r\n<p>\"<em>Exports the ModuleInitializer using the Managed Extensibility Framework (MEF).</em><br /><em>This allows the MefBootstrapper to provide this class as a default implementation.</em><br /><em>If another implementation is found, this export will not be used.</em>\"</p>\r\n<p>, you can decorate your custom class with the <strong>Export</strong> attribute, specifying the <strong>IModuleInitializer </strong>interface as the contract type, which should replace the default implementation.</p>\r\n<p>The resulting code would look like this:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre> [Export(<span style=\"color: blue;\">typeof</span>(IModuleInitializer))]\r\n    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">class</span> MefModuleInitializerWithFix : MefModuleInitializer\r\n    {\r\n        [ImportingConstructor]\r\n        <span style=\"color: blue;\">public</span> MefModuleInitializerWithFix(IServiceLocator serviceLocator, ILoggerFacade loggerFacade, DownloadedPartCatalogCollection downloadedPartCatalogs, AggregateCatalog aggregateCatalog)\r\n            : <span style=\"color: blue;\">base</span>(serviceLocator, loggerFacade, downloadedPartCatalogs, aggregateCatalog) { }\r\n\r\n        <span style=\"color: blue;\">protected</span> <span style=\"color: blue;\">override</span> Prism.Modularity.IModule CreateModule(Prism.Modularity.ModuleInfo moduleInfo)\r\n        {\r\n            Type type = <span style=\"color: blue;\">null</span>;\r\n\r\n           \r\n            type = Type.GetType(moduleInfo.ModuleType, <span style=\"color: blue;\">false</span>, <span style=\"color: blue;\">true</span>);\r\n\r\n            <span style=\"color: blue;\">if</span> (type == <span style=\"color: blue;\">null</span>)\r\n            {\r\n                <span style=\"color: green;\">// Throw an exception in case the type is not found</span>\r\n            }\r\n            <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">base</span>.CreateModule(moduleInfo);\r\n        }\r\n    }\r\n</pre>\r\n</div>\r\n</p>\r\n<p>Please take into account that, although the second parameter in the <strong>Type.GetType </strong>method is set to false (which means that, in case the type is not found, no exception should be thrown), if you have a type conflict, an exception will be thrown as well. So, in order to cover this scenario as well, your code could look like this:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre> [Export(<span style=\"color: blue;\">typeof</span>(IModuleInitializer))]\r\n    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">class</span> MefModuleInitializerWithFix : MefModuleInitializer\r\n    {\r\n        [ImportingConstructor]\r\n        <span style=\"color: blue;\">public</span> MefModuleInitializerWithFix(IServiceLocator serviceLocator, ILoggerFacade loggerFacade, DownloadedPartCatalogCollection downloadedPartCatalogs, AggregateCatalog aggregateCatalog)\r\n            : <span style=\"color: blue;\">base</span>(serviceLocator, loggerFacade, downloadedPartCatalogs, aggregateCatalog) { }\r\n\r\n        <span style=\"color: blue;\">protected</span> <span style=\"color: blue;\">override</span> Prism.Modularity.IModule CreateModule(Prism.Modularity.ModuleInfo moduleInfo)\r\n        {\r\n            Type type = <span style=\"color: blue;\">null</span>;\r\n            <span style=\"color: blue;\">try</span>\r\n            {\r\n                type = Type.GetType(moduleInfo.ModuleType, <span style=\"color: blue;\">false</span>, <span style=\"color: blue;\">true</span>);\r\n            }\r\n            <span style=\"color: blue;\">catch</span> (FileNotFoundException ex)\r\n            {\r\n                <span style=\"color: green;\">// Throw an exception in case there is a type conflict</span>\r\n            }\r\n\r\n            <span style=\"color: blue;\">if</span> (type == <span style=\"color: blue;\">null</span>)\r\n            {\r\n                <span style=\"color: green;\">// Throw an exception in case the type is not found</span>\r\n            }\r\n            <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">base</span>.CreateModule(moduleInfo);\r\n        }\r\n    }\r\n</pre>\r\n</div>\r\n</p>\r\n<p>I hope you find this helpful.</p>\r\n<p>Guido Leandro Maliandi <br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-09-28T07:24:46.48-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "677739",
    "ThreadId": "273991",
    "Html": "<p>Thanks so much Guido, that works for me perfectly!! I had already thought about extending the MefModuleInitializer class, but I couldn't work out in my head how to tell my application that it should use my class rather than the MEF version.</p>\r\n<p>Now I can use my module Catalog to control the versions of my individual modules. However, now I wonder... if I have 2 versions of the same XAP file, I cannot put these 2 same-named XAP's in the same web-application directory, can I?</p>\r\n<p>e.g. Suppose I upgrade my catalog to point to a newer version of my module, version 2.0.0.0:</p>\r\n<p>&lt;Modularity:ModuleInfo  Ref=\"CBS_ResearchBrowser_AdvancedSearch.xap\"  ModuleName=\"AdvancedSearchImpl\"  ModuleType=\"CBS_ResearchBrowser_AdvancedSearch.AdvancedSearchImpl,  CBS_ResearchBrowser_AdvancedSearch, <strong>Version=2.0.0.0</strong>, Culture=neutral, PublicKeyToken=null\" /&gt;</p>\r\n<p>Is it possible, I wonder, to maintain two separate copies of the module XAP (version 1 and version 2) and for my application to locate and load the appropriate version at runtime?</p>\r\n<p>I'm guessing that this could be difficult, as the XAP's would need to be in different locations, right?</p>",
    "PostedDate": "2011-09-28T08:34:24.777-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "677754",
    "ThreadId": "273991",
    "Html": "<p>Hi,</p>\r\n<p>Yes, it seems that you won't be able to put the same assembly with different versions in the same directory, as the XAP packages would have the same file name. You could, however, define some custom logic in your module catalog to check in different places to search for the appropriate file and only load it into the catalog if it is the correct one.</p>\r\n<p>The specific implementation details will depend on your scenario, but you might find it helpful to know that you can access the list of <strong>ModuleInfo</strong>s (which are the objects that contain the necessary metadata to define a Prism module) from the <strong>ModuleCatalog </strong>instance stored in the bootstrapper, modify it according to your needs, and create a new ModuleCatalog passing the modified list as the source. You could override the ConfigureModuleCatalog method to achieve that. The resulting code might look like this:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">protected</span> <span style=\"color: blue;\">override</span> <span style=\"color: blue;\">void</span> ConfigureModuleCatalog()\r\n        {\r\n            <span style=\"color: blue;\">base</span>.ConfigureModuleCatalog();\r\n            <span style=\"color: blue;\">var</span> originalModuleInfoList = <span style=\"color: blue;\">this</span>.ModuleCatalog.Modules;\r\n\r\n            <span style=\"color: blue;\">var</span> newModuleList = ApplyModifications(originalModuleInfoList);\r\n\r\n            <span style=\"color: blue;\">this</span>.ModuleCatalog = <span style=\"color: blue;\">new</span> ModuleCatalog(newModuleList);\r\n        }\r\n</pre>\r\n</div>\r\n</p>\r\n<p>where the ApplyModifications method will contain your logic to define version changes (which will probably imply modifying the <strong>ModuleType </strong>and <strong>Ref </strong>properties of the affected <strong>ModuleInfo </strong>instances).</p>\r\n<p>Another alternative would be to directly generate the initial <strong>ModuleInfo</strong> list in a custom manner from within the <strong>CreateModuleCatalog</strong> method, instead of storing the information in a Xaml file.</p>\r\n<p>I hope you find this helpful.</p>\r\n<p>Guido Leandro Maliandi <br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-09-28T08:53:05.907-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "677759",
    "ThreadId": "273991",
    "Html": "<p>Thanks Guido,</p>\r\n<p>That makes sense and is extremely helpful, I really appreciate your detailed responses.</p>\r\n<p>Thanks again,</p>\r\n<p>Joe.</p>",
    "PostedDate": "2011-09-28T09:01:29.187-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]