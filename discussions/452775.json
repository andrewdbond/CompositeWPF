[
  {
    "Id": "1078101",
    "ThreadId": "452775",
    "Html": "I am creating a WPF application with PRISM, but this application is also using workflows.<br />\nThese workflows are long running workflows so they need to be persisted to the database. I am using the standard sql server mechanism to do that.<br />\nI am also using WorkflowApplication to create instances of the workflows and store the Guid in a database table of my own, so I can get to the flow at any state.<br />\nBecause of this I have to register the host application to the instance store, but also unrgister it.<br />\nI am doing the registration in the initialize of a dedicated IModule, I am also registering the InstanceStore to the container.<br />\nHow am I supposed to take care of the unregistering when the application dies ?<br />\nShould I implement IDisposable on the module and do the necessary steps to make sure the cleanup is called even though I am not explicitely calling dispose myself (as in <a href=\"http://stackoverflow.com/questions/538060/proper-use-of-the-idisposable-interface\" rel=\"nofollow\">http://stackoverflow.com/questions/538060/proper-use-of-the-idisposable-interface</a>) ?<br />\nOr is there a better way ?<br />\n<br />\nedit:<br />\nIModule is definitely not the proper place because it is already being garbage collected way before the end of the application. At least in my case it is.<br />\nSo my strategy now is to implement a manager that receives the store via dependency injection. In the constructor of the manager I am registering of the host and in dispose i am doing the deregistration of the host. I think I have to consider this unregistration as an unmanaged resource. otherwise it is not called.<br />\n",
    "PostedDate": "2013-08-08T00:54:50.74-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1078319",
    "ThreadId": "452775",
    "Html": "Hi, \r<br />\n<br />\nBased on the scenario you described us, implementing <strong>IDisposable</strong> on your manager could make the manager instance to be garbage collected if it is not being used and your application needs more resources. Therefore, a possible approach to solve your problem could be to define the manager as an <strong>IModule</strong> and register it in the container as a <strong>Singleton</strong>. By doing this, the manager instance won't be erased and you may work with the same manager through the entire application lifetime. Notice that if you are using <strong>Unity</strong>, you should register the module as follows, since <strong>Unity</strong> registers modules as <strong>not-Singleton</strong> by default:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">this</span>.container.RegisterType&lt;ManagerModule&gt;(<span style=\"color:Blue;\">new</span> ContainerControlledLifetimeManager());\n\r\n</pre></div>Registering the host inside the Initialize method of the managerÂ´s <strong>IModule</strong> class, will only execute it on the first resolve action, so you can be sure that the registration won't be done twice. \r<br />\n<br />\nRegarding the deregistration, you could make the manager subscribe to an event, raise that event through <strong>EventAggregator</strong> when you want to, and then deregister the host through the manager's module event handler.\r<br />\n<br />\nIf this doesn't help you, it would be useful if you can provide us with more detail of the design of your application or a sample so we can analyze in further detail your scenario.\r<br />\n<br />\nRegards,\r<br />\n<br />\nFederico Martinez \r<br />\n<a href=\"http://blogs.southworks.net/fmartinez\" rel=\"nofollow\">http://blogs.southworks.net/fmartinez</a> <br />\n",
    "PostedDate": "2013-08-08T09:47:57.253-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]