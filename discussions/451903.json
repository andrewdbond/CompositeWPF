[
  {
    "Id": "1074839",
    "ThreadId": "451903",
    "Html": "I have a case where I'm displaying modal windows.  These windows each have their own child container (unity <strong>CreateChildContainer()</strong>) and sub region manager (<strong>CreateRegionManager()</strong>).\r<br />\n<br />\nAs I understand it, when using scoped regions it is generally necessary to inject views into the appropriate regions.<br />\n\r<br />\nIt seems that PRISM is very close to being able to support discovery in this situation if only there were the concept of scoped <strong>RegionViewRegistry</strong>.  As it is, when a sub region manager is created, it's method <strong>RegisterViewWithRegion()</strong> still uses the main registry.\r<br />\n<br />\nI would like the ability to do something like the following each time a modal window is shown:<br />\n<pre><code>// Registry dependencies that ViewType may have\nchildContainer.RegisterType&lt;IA,A&gt;(new ContainerControlledLifetimeManager());\nchildContainer.RegisterType&lt;IB,B&gt;(new ContainerControlledLifetimeManager());\n\n// Register view with region using delegate that builds view on the child container\nsubRegionManager.RegisterViewWithRegion(&quot;RegionName&quot;, \n    () =&gt; childContainer.Resolve(ViewType));</code></pre>\n\nAs it is, <strong>RegisterViewWithRegion</strong> seems to persist the delegate that was registered causing havoc the second time a modal window is shown and this code is repeated.\r<br />\n<br />\nAre there any patterns for getting around this problem aside from directly injecting the view into the region?\r<br />\n<br />\nThanks.<br />\n",
    "PostedDate": "2013-07-30T13:23:48.31-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1075277",
    "ThreadId": "451903",
    "Html": "Hi,\r<br />\n<br />\nAs out of the box the <strong>RegionViewRegistry</strong> provided by <strong>Prism</strong> is used for the entire application and it does not allow to remove a previous registration. Hence in order to acquire the functionality you are describing you will need to take advantage of the extension points provided by <strong>Prism</strong> to implement you own custom logic.\r<br />\n<br />\nA possible approach for example could be to use the implementation provided in the following blog post:<br />\n<ul>\n<li>\n<a href=\"http://blogs.southworks.net/dcherubini/2011/10/06/registering-a-view-in-a-specific-region-manager/\" rel=\"nofollow\">Registering a view in a specific region manager</a><br />\n</li>\n</ul>\nThis approach basically allows to define a view registration only for an specific <strong>RegionManager</strong>. If you are using a scoped <strong>RegionManager</strong> for each window then you could register the view with said region manager each time a window is shown. As each window will have its own <strong>RegionManager</strong>, you should not experience issues with the previous registrations.\r<br />\nHowever, this approach also creates other problems. First, the previous delegates will be still stored in the <strong>RegionViewRegistry</strong>, which could cause memory leaks. Second, if the <strong>RegionManagers</strong> of two windows are identical, they might return the same hash code, making this approach pointless for this scenario.\r<br />\n<br />\nAnother approach could be to use to create a scoped <strong>RegionViewRegistry</strong> for each window. Basically what defines the &quot;scope&quot; where the registration of the views will have effect are the <strong>AutoPopulateRegionBehaviors</strong> that are subscribed to the <strong>RegionViewRegistry</strong>. By default, those behaviors subscribe to the global <strong>RegionViewRegistry</strong>, but I believe they could be created manually passing them the scoped <strong>RegionViewRegistry</strong> they should subscribe to in its constructor. Then you just need to replace the behavior in the region using the same behavior key. The problem with this approach is that you will need to access the <strong>Region</strong> itself to change the <strong>AutoPopulateRegionBehavior</strong> and if you have access to the region it would be easier to simply inject the view in it manually.\r<br />\n<br />\nAs it can be seen, trying to implement this functionality using the <strong>RegionViewRegistry</strong> is not a trivial task.\r<br />\n<br />\nIn my opinion, the easiest approach is to inject the view directly instead of using the <strong>RegionViewRegistry</strong>. The functionality that the registry provides can be simply obtained by first checking if a <strong>Region</strong> exist. If not, then you can subscribe to the <strong>CollectionsChanged</strong> event of the <strong>Regions</strong> collection in the scoped <strong>RegionManager</strong>. When a <strong>Region</strong> is added to the <strong>RegionManager</strong>, the event will be fired allowing you to add the corresponding views to the <strong>Region</strong>.\r<br />\n<br />\nI hope this helps,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-07-31T13:25:48.51-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1080298",
    "ThreadId": "451903",
    "Html": "Thanks as always Damian...\r<br />\n<br />\nI will take the injection route in the short term but hope to look into a scoped <strong>RegionManager</strong> solution when time allows.\r<br />\n<br />\n-- Terrence<br />\n",
    "PostedDate": "2013-08-13T18:07:03.113-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]