[
  {
    "Id": "1034664",
    "ThreadId": "441314",
    "Html": "Hi,\r<br />\n<br />\nNeed help as to why my event is firing twice.  I publish the event only in two places and it only gets fired once after the main Window is loaded and the other is after I loaded a new file using the OpenDialog Dialog.  Both are in my ShellViewModel.\r<br />\n<br />\n<strong>ShellViewModel.cs:</strong><br />\n<pre><code>        private void ShowOpenFileDialog(object arg)\n        {\n            string getFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\n\n            if (!string.IsNullOrWhiteSpace(this.DirectoryPath))\n                getFolderPath = this.DirectoryPath;\n\n            var openFileDialog = new OpenFileDialog()\n            {\n                InitialDirectory = getFolderPath,\n                FileName = this.DocumentFileName,\n                DefaultExt = &quot;*.ods&quot;,\n                Filter = &quot;Open Document Spreadsheet (.ods)|*.ods&quot;\n            };\n\n            if (openFileDialog.ShowDialog() == true)\n            {\n                DirectoryInfo di = new DirectoryInfo(openFileDialog.FileName);\n                DocumentFileInfo dfInfo = new DocumentFileInfo();\n\n                this.InputPath = openFileDialog.FileName;\n                this.DirectoryPath = di.Parent.FullName;\n                this.DocumentFileName = di.Name;\n                this.IsSpreadsheetML = true;\n\n                eventAggregator.GetEvent&lt;DocumentFileEvent&gt;().Publish(new DocumentFileInfo\n                {\n                    InputPath = this.InputPath,\n                    DirectoryPath = this.DirectoryPath,\n                    DocumentFileName = this.DocumentFileName\n                });\n            }\n        }\n\n        public void OnNatsarLoaded()\n        {\n            //MessageBox.Show(&quot;OnNatsarLoaded called&quot;);\n            if (!string.IsNullOrWhiteSpace(Settings.Default.InputPath))\n            {\n                this.InputPath = Settings.Default.InputPath;\n\n                if (!File.Exists(this.InputPath))\n                    return;\n\n                if (string.IsNullOrWhiteSpace(this.directoryPath))\n                    return;\n\n                this.DirectoryPath = Settings.Default.DirectoryPath;\n\n                if (string.IsNullOrWhiteSpace(this.documentFileName))\n                    return;\n\n                this.DocumentFileName = Settings.Default.DocumentFileName;\n\n                DocumentFileInfo dfInfo = new DocumentFileInfo();\n                this.IsSpreadsheetML = true;\n\n __               eventAggregator.GetEvent&lt;DocumentFileEvent&gt;().Publish(new DocumentFileInfo\n                {\n                    InputPath = this.InputPath,\n                    DirectoryPath = this.DirectoryPath,\n                    DocumentFileName = this.DocumentFileName\n                });\n__            }\n        }\n</code></pre>\n\n...the event is subscribed in two places, 1) where is processes the file information.\r<br />\n<br />\n<strong>ObservablePosition.cs</strong><br />\n<pre><code>          eventAggregator.GetEvent&lt;DocumentFileEvent&gt;().Subscribe(OnDocumentFileEvent, ThreadOption.UIThread);\n\n        private void OnDocumentFileEvent(DocumentFileInfo dfInfo)\n        {\n            this.HeaderInfo = dfInfo.DocumentFileName.ToUpper();\n            //MessageBox.Show(&quot;OnDocumentFileEvent : &quot; + dfInfo.DocumentFileName);\n            try\n            {\n                using (ZipFile zipFile = ZipFile.Read(dfInfo.InputPath))\n                {\n                    zipFile.ExtractProgress += this.odsProgressHandler.ExtractProgressHandler;\n\n                    OdsZipFileUpdated(new OdsNewDocumentInfo\n                    {\n                        AddDirectoryWillTraverseReparsePoints = zipFile.AddDirectoryWillTraverseReparsePoints,\n                        AlternateEncoding = zipFile.AlternateEncoding,\n                        AlternateEncodingUsage = zipFile.AlternateEncodingUsage,\n                        BufferSize = zipFile.BufferSize,\n                        CaseSensitiveRetrieval = zipFile.CaseSensitiveRetrieval,\n                        CodecBufferSize = zipFile.CodecBufferSize,\n                        Comment = zipFile.Comment,\n                        CompressionLevel = zipFile.CompressionLevel,\n                        CompressionMethod = zipFile.CompressionMethod,\n                        Count = zipFile.Count,\n                        EmitTimesInUnixFormatWhenSaving = zipFile.EmitTimesInUnixFormatWhenSaving,\n                        EmitTimesInWindowsFormatWhenSaving = zipFile.EmitTimesInWindowsFormatWhenSaving,\n                        Encryption = zipFile.Encryption,\n                        Entries = zipFile.Entries,\n                        EntriesSorted = zipFile.EntriesSorted,\n                        EntryFileNames = zipFile.EntryFileNames,\n                        ExtractExistingFile = zipFile.ExtractExistingFile,\n                        FlattenFoldersOnExtract = zipFile.FlattenFoldersOnExtract,\n                        FullScan = zipFile.FullScan,\n                        Info = zipFile.Info,\n                        InputUsesZip64 = zipFile.InputUsesZip64,\n                        //LibraryVersion = assemName.Version,\n                        MaxOutputSegmentSize = zipFile.MaxOutputSegmentSize,\n                        Name = zipFile.Name,\n                        NumberOfSegmentsForMostRecentSave = zipFile.NumberOfSegmentsForMostRecentSave,\n                        OutputUsedZip64 = zipFile.OutputUsedZip64,\n                        ParallelDeflateMaxBufferPairs = zipFile.ParallelDeflateMaxBufferPairs,\n                        ParallelDeflateThreshold = zipFile.ParallelDeflateThreshold,\n                        //Password = zipFile.Password,\n                        RequiresZip64 = zipFile.RequiresZip64,\n                        SetCompression = zipFile.SetCompression,\n                        SortEntriesBeforeSaving = zipFile.SortEntriesBeforeSaving,\n                        StatusMessageTextWriter = zipFile.StatusMessageTextWriter,\n                        Strategy = zipFile.Strategy,\n                        TempFileFolder = zipFile.TempFileFolder,\n                        UseZip64WhenSaving = zipFile.UseZip64WhenSaving,\n                        ZipErrorAction = zipFile.ZipErrorAction,\n                        ZipFile = zipFile\n                    });\n                }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(&quot;Error reading file {0}&quot;, e.Message);\n                MessageBox.Show(e.Message, &quot;Error reading file&quot;);\n            }\n        }\n\n        private void OdsZipFileUpdated(OdsNewDocumentInfo zfInfo)\n        {\n            this.OdsItems.Clear();\n\n            foreach (ZipEntry z in zfInfo.Entries)\n            {\n                if (z.CompressedSize != 0)\n                {\n                    this.OdsItems.Add(new OdsEntrySummaryItem(z)\n                    {\n                        FileName = z.FileName,\n                        CompressedSize = z.CompressedSize,\n                        CompressionRatio = z.CompressionRatio,\n                        Crc = z.Crc,\n                        UncompressedSize = z.UncompressedSize,\n                        CreationTime = z.CreationTime,\n                        ZipFile = zfInfo.ZipFile\n                    });\n                }\n            }\n        }</code></pre>\n\n..., 2) is where I get the file name for the header tab\r<br />\n<strong>PositionSummaryViewModel.cs:</strong><br />\n<pre><code>            eventAggregator.GetEvent&lt;DocumentFileEvent&gt;().Subscribe(OnHeaderInfoEvent, ThreadOption.UIThread);\n\n        public string HeaderInfo\n        {\n            get { return this.headerInfo; }\n            set { this.headerInfo = value; this.RaisePropertyChanged(() =&gt; HeaderInfo); }\n        }\n\n        private void OnHeaderInfoEvent(DocumentFileInfo dfInfo)\n        {\n            this.HeaderInfo = dfInfo.DocumentFileName.ToUpper();\n        }\n</code></pre>\n\nSo us this something in <strong>Prism</strong> or me?<br />\n",
    "PostedDate": "2013-04-23T09:27:02.683-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1034779",
    "ThreadId": "441314",
    "Html": "Hi,\r<br />\n<br />\nAfter checking the code snippets you posted I couldn't find anything that would cause the event to be raised twice, so the problem might not be in these parts of the code.\r<br />\n<br />\nAs a starting point to find the cause behind this, please check in your application that:<br />\n<ul>\n<li>The methods where the event is published are not being executed twice.</li>\n<li>The subscribers were not subscribed to the event twice.</li>\n<li>\nThere are no duplicates of the subscribed objects either alive or waiting to be destroyed.<br />\n</li>\n</ul>\nRegards,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-04-23T13:17:27.693-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1035207",
    "ThreadId": "441314",
    "Html": "Thanks for the reply! :)\r<br />\n<br />\nWell I did find of that IObservablePosition is being initialize twice, so I have to find out how and where its being done.\r<br />\n<br />\n<strong>PositionSummaryViewModel.cs:</strong><br />\n<pre><code>        public PositionSummaryViewModel(IOrdersController ordersController, IEventAggregator eventAggregator, IObservablePosition observablePosition)\n        {\n            if (ordersController == null)\n            {\n                throw new ArgumentNullException(&quot;ordersController&quot;);\n            }\n\n            this.eventAggregator = eventAggregator;\n            this.Position = observablePosition;\n\n            BuyCommand = ordersController.EntryCommand;\n            SellCommand = ordersController.RemoveEntryCommand;\n\n            this.CurrentPositionSummaryItem = new PositionSummaryItem(&quot;FAKEINDEX&quot;, 0, 0, 0);\n\n            eventAggregator.GetEvent&lt;DocumentFileEvent&gt;().Subscribe(OnHeaderInfoEvent, ThreadOption.UIThread);\n        }</code></pre>\n\n<strong>PositionPieChartViewModel.cs:</strong><br />\n<pre><code>        public PositionPieChartViewModel(IObservablePosition observablePosition)\n        {\n            this.Position = observablePosition;\n        }</code></pre>\n\nis it because of the <strong>Attributes</strong> of:<br />\n<pre><code>    [Export(typeof(IObservablePosition))]\n    [PartCreationPolicy(CreationPolicy.NonShared)]\n    public class ObservablePosition : NotificationObject, IObservablePosition</code></pre>\n\n... that cause the class to be initialize by the calling class and do I need to change this to <strong>Shared</strong>?  Because I only want one instance of this class.<br />\n",
    "PostedDate": "2013-04-24T09:44:16.067-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1035236",
    "ThreadId": "441314",
    "Html": "Yes, that was it, it working fine now.  The way my structure is, is that I need that object to be initialized once.<br />\n",
    "PostedDate": "2013-04-24T10:44:53.973-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1035294",
    "ThreadId": "441314",
    "Html": "Hi,\r<br />\n<br />\nI'm glad to hear that you could find the cause behind this behavior. Indeed, when you want to have only one instance of an exported type in the application (e.g. a singleton,) you will need to define the <strong>CreationPolicy</strong> as <strong>Shared</strong>. When the type is exported as <strong>NonShared</strong>, a new instance will be created each time it's injected as a dependency by the container.\r<br />\n<br />\nRegards,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-04-24T13:17:00.423-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]