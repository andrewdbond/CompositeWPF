[
  {
    "Id": "465609",
    "ThreadId": "218965",
    "Html": "<p>Hello,</p>\r\n<p>I am using Prism to load modules via a ModuleCatalog in a xaml file. I have 2 modules, ModuleA and ModuleB. Right now both are set to InitializationMode=&quot;WhenAvailable&quot;. In ModuleA's ViewModel I can fire an event like this:\r\n<div style=\"color:black;background-color:white\">\r\n<pre>EventAggregator.GetEvent&lt;ShowModuleBEvent&gt;().Publish(EventArgs.Empty); \r\n</pre>\r\n</div>\r\nThis fires the event and ModuleB's IModule class contains :\r\n<div style=\"color:black;background-color:white\">\r\n<pre>_eventAggregator.GetEvent&lt;ShowModuleBEvent&gt;().Subscribe(HandleShowModuleB, ThreadOption.UIThread, <span style=\"color:blue\">true</span>);\r\n</pre>\r\n</div>\r\n</p>\r\n<p>All this works just great. The problem which I am sure you can see is that if I make ModuleB load dynamically, then the IModule in ModuleB will not be loaded at start-up and so the event subscription of course wont catch the event to load ModuleB's view. My question is (finally), where should I be placing event subscriptions to load dynamic modules? What class (or project) is the recommended&nbsp; place to handle the loading and unloading of modules when they are dynamically loaded?</p>\r\n<p>Thanks!!</p>\r\n<p>-Jeff</p>",
    "PostedDate": "2010-07-09T13:27:24.59-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "466110",
    "ThreadId": "218965",
    "Html": "<p>In the case of my <a href=\"http://EHR.CodePlex.com\">http://EHR.CodePlex.com</a> (ModularityWithMef.Desktop folder) using Prism V4 Drop 3 w/MEF container - I subscribe to the ModuleEvent in my <strong>MainWindowPresenter</strong> (the PresenterBase imports the Shell, EventAggregator, ModuleManager, etc).</p>\r\n<p><em><span style=\"color:blue\">using</span> System.ComponentModel.Composition;<br><span style=\"color:blue\">using</span> System.Globalization;<br><span style=\"color:blue\">using</span> GWN.Library.WPF.Base;<br><span style=\"color:blue\">using</span> GWN.Library.WPF.Events;<br><span style=\"color:blue\">using</span> Microsoft.Practices.Composite.Logging;<br><span style=\"color:blue\">using</span> Microsoft.Practices.Composite.Modularity;<br><br><span style=\"color:blue\">namespace</span> ModularityWithMef.Desktop.Presenters<br>{<br>&nbsp;&nbsp;&nbsp; [Export]<br>&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> MainWindowPresenter : PresenterBase, IPartImportsSatisfiedNotification<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Import]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">public</span> CallbackLogger Logger { <span style=\"color:blue\">get</span>; <span style=\"color:blue\">set</span>; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> OnEventAggregatorSet()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventAggregator.GetEvent&lt;ModuleEvent&gt;().Subscribe(e =&gt; ProcessModuleLoad(e));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> ProcessModuleLoad(ModuleEventArgs e)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:green\">// Remove spaces and load the module</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><strong>ModuleManager.LoadModule(e.ModuleControl.ModuleName.Replace(<span style=\"color:#a31515\">&quot; &quot;</span>, <span style=\"color:#a31515\">&quot;&quot;</span>));</strong><br><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> Log(<span style=\"color:blue\">string</span> message, Category category, Priority priority)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">var</span> mainWindow = Shell <span style=\"color:blue\">as</span> MainWindow;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mainWindow.TraceTextBox.Text = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">string</span>.Format(CultureInfo.CurrentUICulture, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:#a31515\">&quot;[{0}][{1}] {2}\\r\\n{3}&quot;</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; category, priority, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message, mainWindow.TraceTextBox.Text);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> OnImportsSatisfied()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shell.DataContext = ModuleTracker;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">this</span>.Logger.Callback = Log;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">this</span>.Logger.CallbackSavedLogs();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</em></p>\r\n<div style=\"color:black;background-color:white\">In my case I'm using MVPVM however if you are using MVVM I would probably import the EventAggregator/ModuleManager into the Bootstrapper (similiar to how I import the MainWindowPresenter below) and subscribe to it there.</div>\r\n<div style=\"color:black;background-color:white\">&nbsp;\r\n<pre><div style=\"color:black;background-color:white\"><pre><em><span style=\"color:blue\">using</span> System.ComponentModel.Composition;\r\n<span style=\"color:blue\">using</span> System.ComponentModel.Composition.Hosting;\r\n<span style=\"color:blue\">using</span> System.Windows;\r\n<span style=\"color:blue\">using</span> Microsoft.Practices.Composite.Logging;\r\n<span style=\"color:blue\">using</span> Microsoft.Practices.Composite.MefExtensions;\r\n<span style=\"color:blue\">using</span> Microsoft.Practices.Composite.Modularity;\r\n<span style=\"color:blue\">using</span> ModularityWithMef.Desktop.Presenters;\r\n<span style=\"color:blue\">using</span> ModularityWithMef.Infrastructure;\r\n\r\n\r\n<span style=\"color:blue\">namespace</span> ModularityWithMef.Desktop\r\n{\r\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> Bootstrapper : MefBootstrapper\r\n    {\r\n        <span style=\"color:blue\">private</span> CallbackLogger callbackLogger = <span style=\"color:blue\">new</span> CallbackLogger();\r\n\r\n       </em><strong> [Import]\r\n        MainWindowPresenter </strong>mainWindowPresenter { <span style=\"color:blue\">get</span>; <span style=\"color:blue\">set</span>; }\r\n<em>\r\n        <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> System.Windows.DependencyObject CreateShell()\r\n        {\r\n            Container.ComposeParts(<span style=\"color:blue\">this</span>);\r\n            <span style=\"color:blue\">return</span> (DependencyObject) mainWindowPresenter.Shell;\r\n        }\r\n\r\n        <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> InitializeShell()\r\n        {\r\n            Application.Current.MainWindow = (MainWindow)<span style=\"color:blue\">this</span>.Shell;\r\n            Application.Current.MainWindow.Show();\r\n        }\r\n\r\n        <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> ConfigureAggregateCatalog()\r\n        {\r\n            <span style=\"color:blue\">base</span>.ConfigureAggregateCatalog();\r\n            \r\n            <span style=\"color:blue\">this</span>.AggregateCatalog.Catalogs.Add(<span style=\"color:blue\">new</span> AssemblyCatalog(<span style=\"color:blue\">typeof</span>(Bootstrapper).Assembly));\r\n            <span style=\"color:blue\">this</span>.AggregateCatalog.Catalogs.Add(<span style=\"color:blue\">new</span> AssemblyCatalog(<span style=\"color:blue\">typeof</span>(ModuleA).Assembly));\r\n            <span style=\"color:blue\">this</span>.AggregateCatalog.Catalogs.Add(<span style=\"color:blue\">new</span> AssemblyCatalog(<span style=\"color:blue\">typeof</span>(ModuleC).Assembly));\r\n            <span style=\"color:blue\">this</span>.AggregateCatalog.Catalogs.Add(<span style=\"color:blue\">new</span> AssemblyCatalog(<span style=\"color:blue\">typeof</span>(LoaderClass).Assembly));\r\n\r\n            DirectoryCatalog catalog = <span style=\"color:blue\">new</span> DirectoryCatalog(<span style=\"color:#a31515\">&quot;DirectoryModules&quot;</span>);            \r\n            <span style=\"color:blue\">this</span>.AggregateCatalog.Catalogs.Add(catalog);            \r\n        }\r\n\r\n        <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> ConfigureContainer()\r\n        {\r\n            <span style=\"color:blue\">base</span>.ConfigureContainer();\r\n            <span style=\"color:blue\">this</span>.Container.ComposeExportedValue&lt;CallbackLogger&gt;(<span style=\"color:blue\">this</span>.callbackLogger);\r\n        }\r\n\r\n        <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> IModuleCatalog CreateModuleCatalog()\r\n        {\r\n            <span style=\"color:green\">// Module C is referenced by this project and in the configuration</span>\r\n            <span style=\"color:green\">// Module E only referenced in the configuration</span>\r\n            <span style=\"color:blue\">this</span>.ModuleCatalog = <span style=\"color:blue\">new</span> ConfigurationModuleCatalog();\r\n            <span style=\"color:blue\">return</span> ModuleCatalog;\r\n        }\r\n\r\n        <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> ILoggerFacade CreateLogger()\r\n        {\r\n            <span style=\"color:blue\">this</span>.Logger = <span style=\"color:blue\">this</span>.callbackLogger;\r\n            <span style=\"color:blue\">return</span> callbackLogger;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n</em></pre>\r\n</div>\r\n</pre>\r\n</div>",
    "PostedDate": "2010-07-11T21:08:19.283-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "466332",
    "ThreadId": "218965",
    "Html": "<p>I am not familiar with the [Import] attribute. I am new to Prism like I said. So, if I create a property for the event aggregator as you did with your MainWindowPresenter, what actually calls that property to pass in the eventAggregator object?</p>\r\n<p>Also, it seems to me at first glance that the responsibility of the boot strapper class is to kick off the application. After all, it basically replaces the a call to a main form to run. Is it really the correct place to handle loading and unloading of views. After the application &quot;boots&quot; I would think that class's responsibility is finished. I was thinking that I should create a module that held a controller class and it could be the &quot;manager&quot; of views. What do you think of that? I just don't want to re-invent the wheel, and I want my code to be easy to follow for others using Prism should anyone else have to maintain my code.</p>\r\n<p>thoughts?</p>\r\n<p>-J</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-07-12T07:11:39.667-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "466351",
    "ThreadId": "218965",
    "Html": "<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>Savij wrote:</strong><br>\r\n<p>I am not familiar with the [Import] attribute. I am new to Prism like I said. So, if I create a property for the event aggregator as you did with your MainWindowPresenter, <strong>what actually calls that property to pass in the eventAggregator object?</strong></p>\r\n</blockquote>\r\n<p><strong>Dependency Injection</strong> (DI) - currently Prism uses a <strong>Unity</strong> Container.&nbsp; At a very high level you can look at&nbsp;a DI container&nbsp;as a lookup dictionary that contains interfaces and the implementation that was registered for it.&nbsp; For example in the Bootstrapper base class you'll find that IEventAggregator was registered to use the EventAggregator class so when you do the following:</p>\r\n<p><strong>[Dependency]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong> &lt;=== Unity<br>public IEventAggregator EventAggregator {get;set;}</p>\r\n<p>Dependency Injection&nbsp;will automagically populate the property with an instance of EventAggregator for you.&nbsp;&nbsp;&nbsp;The above is referred to as &quot;Setter injection&quot;, there is also &quot;constructor injection&quot; which allows you to specify constructor parameters such as&nbsp;&nbsp; <strong>myclass(IEventAggregator eventAggregator)</strong> which will effectively provide you an instance of EventAggregator.&nbsp;&nbsp; <span style=\"text-decoration:underline\">As long as your class was instantiated using constructor or setting injection</span> those classes will be propagating the&nbsp;DI allowing them to also use setter or constructor injection.</p>\r\n<p>In the case of Prism Version 4 Drop 3 they provide both MEF and Unity.&nbsp;&nbsp; MEF does things differently than Unity.&nbsp;&nbsp; MEF allows you to do an [Import] and expects that somewhere else there is a matching [Export].&nbsp;&nbsp;&nbsp;In my case the baseclass for the bootstrapper exported the IEventAggregator so I can simply do the following:</p>\r\n<p><strong>[Import]</strong><br>protected&nbsp;IEventAggregator EventAggregator {get;set;} and it will automagically be populated.&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>Savij wrote:</strong><br>\r\n<p>Also, it seems to me at first glance that the responsibility of the boot strapper class is to kick off the application. After all, it basically replaces the a call to a main form to run. Is it really the correct place to handle loading and unloading of views. After the application &quot;boots&quot; I would think that class's responsibility is finished. <strong>I was thinking that I should create a module that held a controller class and it could be the &quot;manager&quot; of views</strong>. What do you think of that? I just don't want to re-invent the wheel, and I want my code to be easy to follow for others using Prism should anyone else have to maintain my code.</p>\r\n</blockquote>\r\n<p>I agree with you whole-heartedly; that would be a far better solution than placing it in the bootstrapper which is, as you said, only responsible for booting up the application - your way provides a clear separation of&nbsp; concerns.</p>\r\n<p>Your module will be resolved by the Unity Container (under the hood) so it will provide you the ability to specify the following:</p>\r\n<p><br>** MODULE **<br><br><strong>[Dependency]<br></strong>public IModuleManager ModuleManager {get;set;}<br><br>private IEventAggregator eventAggregator;<br><strong>[Dependency]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong><br>public IEventAggregator EventAggregator <br>{<br>&nbsp;&nbsp;&nbsp;&nbsp; get { return eventAggregator; }<br>&nbsp;&nbsp;&nbsp;&nbsp; set {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eventAggregator = value; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnEventAggregatorSet();<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>}</p>\r\n<p>private void OnEventAggregatorSet()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventAggregator.GetEvent&lt;myEvent&gt;().Subscribe(MyEventHandler);<br>}</p>\r\n<p><strong>public</strong> void MyEventHandler(MyEventHandlerEventArgs e)&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&lt;== Must be public for Unity Subscriptions!<br>{<br><strong>&nbsp;&nbsp;&nbsp;&nbsp; </strong>ModuleManager.LoadModule(e.ModuleName);&nbsp;&nbsp;&nbsp;&nbsp; <br>}</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-07-12T07:48:32.123-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "466553",
    "ThreadId": "218965",
    "Html": "<p>Bill,</p>\r\n<p>That is pretty awsome stuff. I can't wait to play a little and implement those changes!! Thanks so much for the insight!</p>\r\n<p>-Jeff</p>",
    "PostedDate": "2010-07-12T16:09:46.89-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]