[
  {
    "Id": "542061",
    "ThreadId": "239979",
    "Html": "\r\n<p>I&acute;ve noticed that IsActive is set on IActiveAware interface before a view is loaded and added to the object tree. Is this behavior by design?</p>\r\n<p>Wouldn&acute;t it be better to set IsActive after a view (userControl) is loaded?</p>\r\n<p>&nbsp;</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">partial</span> <span style=\"color:blue\">class</span> ActiveAwareView : UserControl, IActiveAware {\r\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">bool</span> _isActive;\r\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">event</span> EventHandler IsActiveChanged;\r\n\r\n        <span style=\"color:blue\">public</span> ActiveAwareView () {\r\n          InitializeComponent();\r\n          <span style=\"color:blue\">this</span>.Loaded &#43;= <span style=\"color:blue\">new</span> RoutedEventHandler(View_Loaded);\r\n        }\r\n\r\n        <span style=\"color:blue\">void</span> View_Loaded(<span style=\"color:blue\">object</span> sender, RoutedEventArgs e) {\r\n            System.Diagnostics.Debug.WriteLine(<span style=\"color:#a31515\">&quot;Loaded&quot;</span>);\r\n        }\r\n\r\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">bool</span> IsActive {\r\n            <span style=\"color:blue\">get</span> {\r\n                <span style=\"color:blue\">return</span> _isActive;\r\n            }\r\n            <span style=\"color:blue\">set</span> {\r\n                <span style=\"color:blue\">if</span> (value == _isActive) {\r\n                    <span style=\"color:blue\">return</span>;\r\n                }\r\n\r\n                _isActive = value;\r\n                OnActiveChanged(EventArgs.Empty);               \r\n\r\n                System.Diagnostics.Debug.WriteLine(<span style=\"color:#a31515\">&quot;IsActive changed&quot;</span>);\r\n            }\r\n        }\r\n\r\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">void</span> OnActiveChanged(EventArgs e) {\r\n            <span style=\"color:blue\">var</span> handler = IsActiveChanged;\r\n\r\n            <span style=\"color:blue\">if</span> (handler != <span style=\"color:blue\">null</span>) {\r\n                handler(<span style=\"color:blue\">this</span>, e);\r\n            }\r\n        }\r\n}\r\n</pre>\r\n</div>\r\n<p></p>\r\n",
    "PostedDate": "2010-12-30T01:18:40.483-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "542253",
    "ThreadId": "239979",
    "Html": "\r\n<p>Hi,</p>\r\n<p>The behavior you're mentioning is by design. There is a Region Behavior responsible for setting the\r\n<strong>IsActive </strong>property of a view to true when adding it to a region (the\r\n<strong>RegionActiveAwareBehavior</strong> behavior, which can be found in the <strong>\r\nRegions/Behaviors</strong> folder in the <strong>Prism.Silverlight</strong> project). The aforementioned behavior monitors the region's\r\n<strong>ActiveViews </strong>collection to see if a view is added or removed (by subscribing to its\r\n<strong>CollectionChanged </strong>event). The <strong>ActiveViews </strong>collection (which is an instance of the\r\n<strong>ViewsCollection </strong>class) is a collection of <strong>ItemMetadata</strong>, which are wrappers that contain a view (of object type) and metadata for it, such as a Name and a property indicating whether it is active. So the\r\n<strong>ActiveViews </strong>collection of a region contains all the views that should be considered active for that region. When a view that implements\r\n<strong>IActiveAware</strong> is added to that <strong>ActiveViews </strong>collection, the\r\n<strong>RegionActiveAwareBehavior</strong> sets the <strong>IsActive</strong> property of the View and its DataContext (if any) to true, and to false in case it is removed from that collection. Since the views that can be added to regions aren't constrained\r\n to <strong>FrameworkElements</strong>, you could add any kind of object to a region, which does not necessarily implement the\r\n<strong>FrameworkElement.Loaded</strong> event.</p>\r\n<p>You could, however, consider extending Prism to implement a different <strong>\r\nRegionActiveAwareBehavior </strong>that sets the <strong>IsActive </strong>property of a view to true only when it is loaded. In that case, you should note that only views that inherit from\r\n<strong>FrameworkElement</strong> could be affected by that behavior. Another possibility would be to add a different implementation of the IActiveAware interface in your active aware view. For example, you could modify the getter of your IsActive property\r\n to return (_isActive &amp;&amp; this._contentLoaded) instead of just _isActive, so that your view is only considered active when it has already been loaded. An example to illustrate this could look like the following:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">partial</span> <span style=\"color:blue\">class</span> ActiveAwareView : UserControl, IActiveAware\r\n    {\r\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">bool</span> _isActive;\r\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">event</span> EventHandler IsActiveChanged;\r\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">bool</span> _alreadyLoaded;\r\n\r\n        <span style=\"color:blue\">public</span> ActiveAwareView()\r\n        {\r\n            InitializeComponent();\r\n            <span style=\"color:blue\">this</span>.Loaded &#43;= <span style=\"color:blue\">new</span> RoutedEventHandler(View_Loaded);\r\n        }\r\n\r\n        <span style=\"color:blue\">void</span> View_Loaded(<span style=\"color:blue\">object</span> sender, RoutedEventArgs e)\r\n        {\r\n            System.Diagnostics.Debug.WriteLine(<span style=\"color:#a31515\">&quot;Loaded (now the view is considered active)&quot;</span>);\r\n            <span style=\"color:blue\">this</span>._alreadyLoaded = <span style=\"color:blue\">true</span>;\r\n        }\r\n\r\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">bool</span> IsActive\r\n        {\r\n            <span style=\"color:blue\">get</span>\r\n            {\r\n                <span style=\"color:blue\">return</span> (_isActive &amp;&amp; <span style=\"color:blue\">this</span>._alreadyLoaded);\r\n            }\r\n            <span style=\"color:blue\">set</span>\r\n            {\r\n                <span style=\"color:blue\">if</span> (value == _isActive)\r\n                {\r\n                    <span style=\"color:blue\">return</span>;\r\n                }\r\n\r\n                _isActive = value;\r\n                OnActiveChanged(EventArgs.Empty);\r\n\r\n                System.Diagnostics.Debug.WriteLine(<span style=\"color:#a31515\">&quot;IsActive changed (but the view is still considered not active&quot;</span>);\r\n            }\r\n        }\r\n\r\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">void</span> OnActiveChanged(EventArgs e)\r\n        {\r\n            <span style=\"color:blue\">var</span> handler = IsActiveChanged;\r\n\r\n            <span style=\"color:blue\">if</span> (handler != <span style=\"color:blue\">null</span>)\r\n            {\r\n                handler(<span style=\"color:blue\">this</span>, e);\r\n            }\r\n        }\r\n    }\r\n</pre>\r\n</div>\r\n<p>If you consider this to be an undesired behavior for Prism, you could create a work item in the\r\n<a href=\"http://compositewpf.codeplex.com/workitem/list/basic\">Issue Tracker</a> for this to be modified in future releases.</p>\r\n<p>I hope you find this helpful.</p>\r\n<p>Guido Leandro Maliandi<br>\r\n<a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>\r\n",
    "PostedDate": "2010-12-30T10:46:53.86-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]