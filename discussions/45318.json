[
  {
    "Id": "151107",
    "ThreadId": "45318",
    "Html": "I came across David Hill's blog post (<a href=\"http://blogs.msdn.com/dphill/archive/2008/12/05/ui-composition-patterns.aspx\">http://blogs.msdn.com/dphill/archive/2008/12/05/ui-composition-patterns.aspx</a>) about a view-centric way of instantiating components, and it looked like exactly what I want to do in my app.  I'd like to be able to instantiate views in XAML and declaratively list the dependencies (such as the ViewModel) to inject. <div><br></div><div>David's post had this example:</div><div><span style=\"font-family:consolas;font-size:11px;line-height:16px\"><pre style=\"padding-right:0px;padding-left:0px;font-size:8pt;padding-bottom:0px;margin-top:0em;margin-right:0em;margin-bottom:0em;margin-left:0em;overflow-x:visible;overflow-y:visible;width:100%;color:black;border-top-style:none;line-height:12pt;padding-top:0px;font-family:consolas, 'courier new', courier, monospace;border-right-style:none;border-left-style:none;background-color:white;border-bottom-style:none\"><span style=\"color:rgb(0, 0, 255)\">&lt;</span><span style=\"color:rgb(128, 0, 0)\">UserControl</span> <span style=\"color:rgb(255, 0, 0)\">x:Class</span><span style=\"color:rgb(0, 0, 255)\">=&quot;UIComposition.Modules.Project.ProjectsListView&quot;</span></pre><pre style=\"padding-right:0px;padding-left:0px;font-size:8pt;padding-bottom:0px;margin-top:0em;margin-right:0em;margin-bottom:0em;margin-left:0em;overflow-x:visible;overflow-y:visible;width:100%;color:black;border-top-style:none;line-height:12pt;padding-top:0px;font-family:consolas, 'courier new', courier, monospace;border-right-style:none;border-left-style:none;background-color:rgb(244, 244, 244);border-bottom-style:none\">    <span style=\"color:rgb(255, 0, 0)\">cal:Presenter</span>.<span style=\"color:rgb(255, 0, 0)\">Type</span><span style=\"color:rgb(0, 0, 255)\">=&quot;{x:Type UIComposition.Modules.Project.IProjectsListPresenter}&quot;</span> … <span style=\"color:rgb(0, 0, 255)\">&gt;</span></pre></span></div><div><br></div><div>Is this capability present in the current Prism drop?  If so, where can I find an example of it in the Quickstarts?</div>",
    "PostedDate": "2009-01-26T14:41:58.267-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "151618",
    "ThreadId": "45318",
    "Html": "Not within Prism 1.0. An alpha of prism 2.0 should contain this functionality if I'am right: <a href=\"../Release/ProjectReleases.aspx?ReleaseId=21912\" title=\"http://www.codeplex.com/CompositeWPF/Release/ProjectReleases.aspx?ReleaseId=21912\">http://www.codeplex.com/CompositeWPF/Release/ProjectReleases.aspx?ReleaseId=21912</a><br>\r\n<br>\r\nRegards<br>\r\n",
    "PostedDate": "2009-01-27T22:44:26.38-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "151637",
    "ThreadId": "45318",
    "Html": "Check out the quick starts in v2 drop 9:<br>\r\n- 'View-First' is named 'View Discovery Composition'<br>\r\n- 'Presenter-First' is named 'View Injection Composition'<br>\r\n<br>\r\nCheers,<br>\r\nJani<br>\r\n<br>\r\n",
    "PostedDate": "2009-01-28T00:02:50.163-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "151913",
    "ThreadId": "45318",
    "Html": "From what I can tell, both View Discovery Composition and View Injection Composition use Presenter-first composition.  The basic process is the same: <div><br></div><div>1) The Presenter class uses constructor injection to obtain an instance of its view</div><div>2) The module calls Resolve on the Presenter</div><div>3) The module register's the Presenter's View with the Region</div><div>4) In one way or another, the region displays the View</div><div><br></div><div>And of course, all this is done in code.  What I'm asking for is a way to include the child views in the XAML of the parent view.  This would mean that the View class would be the one with constructor injection, and it would obtain an instance of the Presenter class in its constructor.  I've come across two blog posts by the Patterns &amp; Practices team that talk about this (<span style=\"color:rgb(48, 51, 45);font-family:'segoe ui';font-size:13px\"><a href=\"http://blogs.msdn.com/dphill/archive/2008/12/05/ui-composition-patterns.aspx\" style=\"text-decoration:underline;color:rgb(206, 139, 16)\">http://blogs.msdn.com/dphill/archive/2008/12/05/ui-composition-patterns.aspx</a>, <span style=\"color:rgb(0, 0, 0);font-family:'times new roman';font-size:16px\"><a href=\"http://blogs.msdn.com/erwinvandervalk/archive/2008/10/24/prism-v2-drop-4.aspx\">http://blogs.msdn.com/erwinvandervalk/archive/2008/10/24/prism-v2-drop-4.aspx</a>), but they refer to Drop 7 and Drop 4 of Prism.  It seems that the team dropped support for this functionality in Drop 9.  Can anybody clear this up for me?  Thanks.</span></span></div>",
    "PostedDate": "2009-01-28T12:33:30.943-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "152284",
    "ThreadId": "45318",
    "Html": "<p>Hi guys,</p>\r\n<p>What david is describing in his blog post unfortunately is not possible with the upcoming release of Prism. </p>\r\n<p>We talked about this quite a lot - Internally and with our advirors - and decided not to implement something like this. </p>\r\n<p>Our initial idea was to be able to do something like this:<br>\r\n&lt;ContentControl RegionName=&quot;MyRegion&quot; ViewType=&quot;IMyView&quot;&gt;<br>\r\n&lt;/ContentControl&gt;</p>\r\n<p>And then also to be able to access interface parameters (like the presenter, or something else) on that interface on the view. However, our advisors were quite strongly opposed to that idea, because it breaks some of the modularity of the system. </p>\r\n<p>Also, specifying the type (or interface) of a view or presenter to load in your view is not easy in silverlight. You have to specify the fully qualified name in a string, because &lt;x:Type IMyViewType&gt; is not supported in Silverlight. </p>\r\n<p>Now, we are supporting ViewDiscovery by registering types against a region name. When a region with that name is displayed, the type of the registered view is created. </p>\r\n<p>What you are describing, createing a view that receives the presenter as a parameter in the constructor is still possible. However, since all the we converted quickstarts from Prism V1 were using the presenter first pattern, we are not demonstrating how to do what you are describing.</p>\r\n<p>So if you do:<br>\r\n RegionManager.RegisterTypeWithRegion(&quot;MyRegion&quot;, typeof(MyView));<br>\r\nThe view will be created with unity and all dependencies that the view has defined in the constructor will be injected. </p>\r\n<p>Now you also mentioned that you wanted to specify the dependencies in XAML. Please correct me if I'm wrong, but the only reason for that I could think of is if you want to display the same view twice, but with a different TYPE of presenter. Usually, I see it the other way around. Different views using the same presenter to get different representations of the same data &amp; logic. </p>\r\n<p>Now if you really want to specify your dependencies in XAML, it's not impossible, but it requires some serious customization.<br>\r\n1. Create a dependency property for the Region that will host your dependency (for example, a string that will contain the type of the presenter you wish to add)<br>\r\n2. Create a custom regionbehavior that implements IHostAwareRegionBehavior<br>\r\n 2.1 This behavior will monitor the Views collection to see if views are added and removed<br>\r\n 2.2 Retrieve the dependency property value with the presenter type name from the hostcontrol <br>\r\n 2.3 When a view is added, it will create use the presenter typename to create an instance of the presenter and add it to the view. YOu might have to create a common 'IPresenterAware' behavior to allow you to set the presenter on the view. </p>\r\n<p>Hope this helps.</p>\r\n<p>_Erwin  </p>\r\n",
    "PostedDate": "2009-01-29T12:03:35.48-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "152302",
    "ThreadId": "45318",
    "Html": "Thanks for your thorough reply Erwin.  My reason for wanting to instantiate Views in the XAML was to allow for better designer-developer workflow, one that would involve a minimum of rewriting as code is passed from designer to developer.  This was one of the selling points of WPF: the designer can create all the controls and layout in XAML, and not have to worry about code.  The developer then basically wires up the controls to data and business logic.  What the current CAL patterns force us to do, however, completely demolishes that, and leaves teams with two choices:<div><br></div><div>1) <span style=\"white-space:pre\">\t</span>Designers continue to create the interfaces in Blend/XAML.  When they hand off to the developers, the developers have to do a considerable amount of rewriting of the XAML: they must create Regions wherever a UserControl was called for, and in the Presenter code they must resolve the child control's Presenter and inject the views.  </div><div><span style=\"white-space:pre\">\t</span>This path allows designers to work in a way that's easy for them.  They can use an actual <span style=\"font-style:italic\">design </span>tool (Blend), that allows them to see layout without running the project.  But this leaves the team with two entirely different sets of code.  One that's entirely XAML-based for designers, and one that's largely code-based for developers.  It becomes hard to reconcile changes as the project progresses.</div><div><br></div><div>2)<span style=\"white-space:pre\">\t</span>The developers work with the designers as they're creating the interface.  We make the project CAL-based from the very beginning.  Developers help the designer create Regions wherever they were going to put a UserControl, and we do all the necessary coding for resolving presenters and injecting views and whatnot.  </div><div><span style=\"white-space:pre\">\t</span>The disadvantage here is that designers don't get the advantage of using a design tool, since they must always run the project to see all the pieces come together.  Also, they can't create and include any additional child controls without either having to know how to write the code to write everything up, or they must involve a developer.</div><div><br></div><div>I'm probably missing something here, because things can't really be this difficult.  Can you explain how designers and developers work together on your team?</div><div><br></div><div>-Amit</div>",
    "PostedDate": "2009-01-29T13:19:10.22-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "152720",
    "ThreadId": "45318",
    "Html": "Hi Amit,<br>\r\n<br>\r\nWell, the problem again has to do with modularity. The designer of the shell shouldn't make assumptions about the views that are loaded into the regions and the designers of the individual views shouldn't make assumptions about what type of region (or where) it's beying displayed. Because you should be able to recompose your app in a different way.<br>\r\n<br>\r\nWe have put together some docs on considerations for developers and considerations for designer with regards to modular design. That might help you a bit. For the redesign of the Prism RI, we hired some graphical designers (who were actually more developers with extensive knowlegde of xaml) to work with our developers to update the UI. <br>\r\n<br>\r\nI would argue that having both your developers and designers working together would be the ideal approach. As a developer, you can create empty viewmodels that can be used by the designers in Blend to fill the UI with dummy data and allows the designers to test their databinding. While the UI is beying designed, the developers can add the code behind it.  <br>\r\n<br>\r\nHOpe that helps<br>\r\n_Erwin<br>\r\n<br>\r\n<br>\r\n",
    "PostedDate": "2009-01-30T15:23:59.647-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]