[
  {
    "Id": "728479",
    "ThreadId": "286888",
    "Html": "<p>Hi experts,</p>\n<p>Suppose we have a list of different models who only share the same base type</p>\n<div style=\"background-color: white; color: black;\">\n<pre><span style=\"color: blue;\">class</span> Model1 : ModelBase {}\r\n<span style=\"color: blue;\">class</span> Model2 : ModelBase {}\r\n<span style=\"color: blue;\">class</span> Model3 : ModelBase {}\r\n\r\n<span style=\"color: blue;\">var</span> myList = <span style=\"color: blue;\">new</span> List&lt;ModelBase&gt; { <span style=\"color: blue;\">new</span> Model1(), <span style=\"color: blue;\">new</span> Model2(), <span style=\"color: blue;\">new</span> Model3()}\r\n</pre>\n</div>\n<p>How do I resolve/create a ViewModel for each of this Models based on it's type using PRISM/MEF? At first I was thinking about using something like this (pseudocode)</p>\n<div style=\"background-color: white; color: black;\">\n<pre><span style=\"color: blue;\">var</span> myVMList;\r\n\r\n<span style=\"color: blue;\">foreach</span> (model <span style=\"color: blue;\">in</span> myList)\r\n{\r\n   <span style=\"color: blue;\">switch</span>(model)\r\n       <span style=\"color: blue;\">case</span> Model1\r\n          myVMList.Add(<span style=\"color: blue;\">new</span> Model1ViewModel(model)\r\n\r\n       <span style=\"color: blue;\">case</span> Model2\r\n          myVMList.Add(<span style=\"color: blue;\">new</span> Model2ViewModel(model))\r\n}\r\n</pre>\n</div>\n<p>But this has the drawback that&nbsp;'switch-on-type' is not supported in C#. There are some implementations by others but mostly it's suggested to just go with polymofism (create virtual&nbsp;GetViewModel method in ModelBase and just override this in direved classes.) This is in my case not ideal because it couples my Model with the ViewModel which should never be the case.</p>\n<p>I also found some answers to 'switch-on-type' discussions who suggest using IoC for this (like MEF) but i can't figure out how to do this. There is no method to get a viewmodel based on the models name as far as i'm concerned in PRISM. The only posibility would be to use Import attribute, which is useless here or go with ServiceLocator.Current.GetInstance&lt;Type&gt;(); but that requires an actual type rather than a string.</p>\n<p>Hope you can help me with this!</p>\n<p>Many thanks!</p>",
    "PostedDate": "2012-01-20T14:18:12.34-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "729473",
    "ThreadId": "286888",
    "Html": "<p>Hi,</p>\r\n<p>Based on my understanding, the usual approach when using the MVVM pattern in Prism is to create the view, obtain the corresponding view model through dependency injection and then obtain the corresponding models in the view model also through dependency injection or through a shared service. This way, the model doesn't need to know the view model that is going to consume it.</p>\r\n<p>However, this depends mostly of your personal preferences and the requirements of your scenario.</p>\r\n<p>If you have an scenario where you need to instantiate your model first (for example, to perform some kind of initialization on it) and then create the view model that will consume it passing the aforementioned model in the constructor, you could use the approach you mentioned above. For example, I believe you could use the type's name in the switch statement:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">foreach</span> (ModelBase model <span style=\"color: blue;\">in</span> myList)\r\n{\r\n    String type=model.GetType().Name;    \r\n    <span style=\"color: blue;\">switch</span>(type)\r\n    {\r\n        <span style=\"color: blue;\">case</span> <span style=\"color: #a31515;\">\"Model1\"</span>:\r\n            myVMList.Add(<span style=\"color: blue;\">new</span> Model1ViewModel(model));\r\n            <span style=\"color: blue;\">break</span>;\r\n\r\n        <span style=\"color: blue;\">case</span> <span style=\"color: #a31515;\">\"Model2\"</span>:\r\n            myVMList.Add(<span style=\"color: blue;\">new</span> Model2ViewModel(model));\r\n            <span style=\"color: blue;\">break</span>;\r\n\r\n        ( ... )\r\n    }\r\n}\r\n</pre>\r\n</div>\r\n</p>\r\n<p>However, take into account that, based on my understanding, this might not be a recommended approach as it might be possible for a model to be consumed by more than one view model or to have a view model that consumes more than one model.</p>\r\n<p>Also, another possible approach could be to implement a kind of \"presenter\" for each view - view model - model triad that could build the aforementioned components and wire them up.</p>\r\n<p>I hope you find this useful,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-01-23T11:46:02.133-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "729541",
    "ThreadId": "286888",
    "Html": "<p>Thank you very much for your answer. Yeah I was in the understanding that it is recommended to create a View first, then let DI create a ViewModel. I saw that in multiple sources, but I am confused on how to handle this in situations where you already have a collection of (different types) of Models.</p>\n<p>For instance: Suppose you have a service which generates random Models, based on some&nbsp;algorithm. After a minute or so the service has created 100 Models, lets say 50 of type Square and 50 of type Circle (both Models share the same base class ModelBase). Suppose each Model has a Color property and a Location property (X,Y). Now I want to display these Models in a Canvas (not a problem), but I want it to be done the MVVM way.</p>\n<p>When I understand&nbsp;MVVM&nbsp;correctly I now need to create a View for each Model (in real world models are somewhat more complex than described here, so a View for each model is not overdesigned) and a ViewModel linking the View to the Model without them knowing of eachother. With PRISM I now should do als you told: Create a View first, which loads a ViewModel via DI; this is a problem because I need to create a Views&nbsp;and VMs that belong to the already existent Models, so the Circle models should get a Circle view and a CircleViewModel and the same holds for the Square Models.</p>\n<p>Of course I could create a method CreateVM() or even CreateView() in the Models but that would break with all rules of MVVM and composition. The service who creates these models should not know anything about the VMs and Views. I'm very curious as to what your idea around this kind of problem is.</p>\n<p>Thank you very much for your time.</p>",
    "PostedDate": "2012-01-23T13:35:27.02-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "729661",
    "ThreadId": "286888",
    "Html": "<p>Okay to make things more clear to you I have created some code, hope this will help you better&nbsp;understand my problem. Thanks again!</p>\n<div style=\"color: black; background-color: white;\">\n<pre>    <span style=\"color: green;\">/*\r\n     * Models (these are generated by a service, the service doesn't and should not now about views or view models)\r\n     * \r\n     * \r\n     */</span>\r\n\r\n    <span style=\"color: blue;\">abstract</span> <span style=\"color: blue;\">class</span> BaseModel { }\r\n\r\n    <span style=\"color: blue;\">class</span> SquareModel : BaseModel { }\r\n\r\n    <span style=\"color: blue;\">class</span> CircleModel : BaseModel { }\r\n\r\n\r\n    <span style=\"color: green;\">/*\r\n     *  View Models\r\n     * \r\n     * \r\n     */</span>\r\n\r\n    <span style=\"color: blue;\">abstract</span> <span style=\"color: blue;\">class</span> BaseViewModel&lt;TModel&gt; <span style=\"color: green;\">// : INOtificationPropertyChanged, etc</span>\r\n    {\r\n        <span style=\"color: blue;\">protected</span> TModel Model;\r\n\r\n        <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> SetModel(TModel model)\r\n        {\r\n            Model = model;\r\n            OnChangeModel();\r\n        }\r\n\r\n        <span style=\"color: blue;\">protected</span> <span style=\"color: blue;\">virtual</span> <span style=\"color: blue;\">void</span> OnChangeModel()\r\n        {\r\n            <span style=\"color: green;\">// Assignment of base properties here, based on Model</span>\r\n        }\r\n\r\n        <span style=\"color: green;\">// Declarate some base properties here</span>\r\n    }\r\n\r\n    [Export(<span style=\"color: blue;\">typeof</span>(BaseViewModel&lt;BaseModel&gt;))]\r\n    [TypeMetadata(Type = <span style=\"color: #a31515;\">\"CircleViewModel\"</span>)]\r\n    <span style=\"color: blue;\">class</span> CircleViewModel : BaseViewModel&lt;CircleModel&gt;\r\n    {\r\n        <span style=\"color: blue;\">protected</span> <span style=\"color: blue;\">override</span> <span style=\"color: blue;\">void</span> OnChangeModel()\r\n        {\r\n            <span style=\"color: green;\">// Assignment of circle specific properties here, based on Model</span>\r\n        }\r\n\r\n        <span style=\"color: green;\">// Declarate some circle specific properties here</span>\r\n    }\r\n\r\n    [Export(<span style=\"color: blue;\">typeof</span>(BaseViewModel&lt;BaseModel&gt;))]\r\n    [TypeMetadata(Type = <span style=\"color: #a31515;\">\"SquareViewModel\"</span>)]\r\n    <span style=\"color: blue;\">class</span> SquareViewModel : BaseViewModel&lt;SquareModel&gt;\r\n    {\r\n        <span style=\"color: blue;\">protected</span> <span style=\"color: blue;\">override</span> <span style=\"color: blue;\">void</span> OnChangeModel()\r\n        {\r\n            <span style=\"color: green;\">// Assignment of square specific properties here, based on Model</span>\r\n        }\r\n\r\n        <span style=\"color: green;\">// Declarate some square specific properties here</span>\r\n    }\r\n\r\n    <span style=\"color: blue;\">class</span> Program\r\n    {\r\n        [ImportMany]\r\n        <span style=\"color: blue;\">protected</span> IEnumerable&lt;ExportFactory&lt;BaseViewModel&lt;BaseModel&gt;, ITypeMetadata&gt;&gt; Factories { <span style=\"color: blue;\">get</span>; <span style=\"color: blue;\">set</span>; }\r\n\r\n        <span style=\"color: blue;\">public</span> BaseViewModel&lt;BaseModel&gt; Create(<span style=\"color: blue;\">string</span> viewModelType)\r\n        {\r\n            <span style=\"color: blue;\">var</span> factory = (<span style=\"color: blue;\">from</span> f <span style=\"color: blue;\">in</span> Factories <span style=\"color: blue;\">where</span> f.Metadata.Type.Equals(viewModelType) <span style=\"color: blue;\">select</span> f).First();\r\n\r\n            <span style=\"color: green;\">// Factory is able to create View Models of type viewModelType using CreateExport() function</span>\r\n            <span style=\"color: blue;\">var</span> vm = factory.CreateExport().Value;\r\n\r\n            <span style=\"color: blue;\">return</span> vm;\r\n            <span style=\"color: green;\">// Same error as with solution A</span>\r\n            <span style=\"color: green;\">// cannot convert from 'ConsoleApplication1.SquareViewModel' to 'ConsoleApplication1.BaseViewModel&lt;ConsoleApplication1.BaseModel&gt;'</span>\r\n            <span style=\"color: green;\">// This error is actually displayed in ExportFactory context, but it means the same</span>\r\n        }\r\n\r\n        <span style=\"color: blue;\">public</span> BaseViewModel&lt;BaseModel&gt; CreateFrom(Type type)\r\n        {\r\n            <span style=\"color: blue;\">var</span> vmTypeName = type.Name + <span style=\"color: #a31515;\">\"ViewModel\"</span>;\r\n            <span style=\"color: blue;\">return</span> Create(vmTypeName);\r\n        }\r\n\r\n        <span style=\"color: blue;\">public</span> BaseViewModel&lt;BaseModel&gt; CreateVMUsingExportFactory(BaseModel model)\r\n        {\r\n            <span style=\"color: blue;\">var</span> vm = CreateFrom(model.GetType());\r\n            vm.SetModel(model);\r\n            <span style=\"color: blue;\">return</span> vm;\r\n        }\r\n\r\n        <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> DoStuff()\r\n        {\r\n            <span style=\"color: green;\">// Suppose service gives me this</span>\r\n            <span style=\"color: blue;\">var</span> serviceOutput = <span style=\"color: blue;\">new</span> List&lt;BaseModel&gt;\r\n                                    {\r\n                                        <span style=\"color: blue;\">new</span> SquareModel(),\r\n                                        <span style=\"color: blue;\">new</span> CircleModel(),\r\n                                        <span style=\"color: blue;\">new</span> CircleModel(),\r\n                                        <span style=\"color: blue;\">new</span> SquareModel(),\r\n                                        <span style=\"color: blue;\">new</span> CircleModel(),\r\n                                        <span style=\"color: blue;\">new</span> SquareModel(),\r\n                                        <span style=\"color: blue;\">new</span> SquareModel()\r\n                                        <span style=\"color: green;\">// may be longer but not the point</span>\r\n                                    };\r\n\r\n            <span style=\"color: green;\">// viewModelCollection is bound to a listbox, by using datatemplates everthing is nicely placed on the canvas; no problem there</span>\r\n            <span style=\"color: green;\">// Actually this is a ObserveableCollection</span>\r\n            List&lt;BaseViewModel&lt;BaseModel&gt;&gt; viewModelCollection = <span style=\"color: blue;\">new</span> List&lt;BaseViewModel&lt;BaseModel&gt;&gt;();\r\n\r\n\r\n            <span style=\"color: green;\">//</span>\r\n            <span style=\"color: green;\">// What to do here?</span>\r\n            <span style=\"color: green;\">//</span>\r\n\r\n            <span style=\"color: green;\">//</span>\r\n            <span style=\"color: green;\">// A. Switch-on-type</span>\r\n            <span style=\"color: blue;\">foreach</span> (<span style=\"color: blue;\">var</span> model <span style=\"color: blue;\">in</span> serviceOutput)\r\n            {\r\n                <span style=\"color: green;\">// Note there are beter implementations of this, using dicationaries and delegates, main goal of that is to not break when refactoring;</span>\r\n                <span style=\"color: blue;\">switch</span> (model.GetType().Name)\r\n                {\r\n                    <span style=\"color: blue;\">case</span> <span style=\"color: #a31515;\">\"SquareModel\"</span>:\r\n                        SquareViewModel vm = <span style=\"color: blue;\">new</span> SquareViewModel();\r\n                        vm.SetModel((SquareModel)model); <span style=\"color: green;\">// another cast..... :(</span>\r\n                        viewModelCollection.Add(vm);\r\n                        <span style=\"color: green;\">// Error: </span>\r\n                        <span style=\"color: green;\">// cannot convert from 'ConsoleApplication1.SquareViewModel' to 'ConsoleApplication1.BaseViewModel&lt;ConsoleApplication1.BaseModel&gt;'</span>\r\n\r\n                        <span style=\"color: blue;\">break</span>;\r\n\r\n                    <span style=\"color: blue;\">case</span> <span style=\"color: #a31515;\">\"CircleModel\"</span>:\r\n                        <span style=\"color: green;\">// same</span>\r\n                        <span style=\"color: blue;\">break</span>;\r\n                }\r\n            }\r\n\r\n            <span style=\"color: green;\">// B. MEF ExportFactory&lt;&gt;</span>\r\n            <span style=\"color: green;\">//</span>\r\n            <span style=\"color: blue;\">foreach</span> (<span style=\"color: blue;\">var</span> model <span style=\"color: blue;\">in</span> serviceOutput)\r\n            {\r\n                <span style=\"color: blue;\">var</span> vm = CreateVMUsingExportFactory(model);\r\n                viewModelCollection.Add(vm);\r\n            }\r\n\r\n            <span style=\"color: green;\">// C. Something else?!</span>\r\n            <span style=\"color: green;\">//</span>\r\n            <span style=\"color: green;\">// Please help ;-).</span>\r\n        }\r\n</pre>\n</div>\n<p>If anything is unclear please ask :)</p>",
    "PostedDate": "2012-01-23T17:25:07.303-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "730083",
    "ThreadId": "286888",
    "Html": "<p>Hi,</p>\r\n<p>If you need to create a view and view model and then obtain an already existing model for them, as a possible approach you could use dependency injection to create the view and view model and<strong> inject in the view model the service</strong> used to obtain the existing models.</p>\r\n<p>If instead, you need to create a view and/or view model for each existing model, I believe you could use a similar approach to the one you mentioned above: you could have a <strong>shared service</strong> (this would be a different service than the one used to obtain the models) that contains a dictionary of model types and delegates or \"presenters\" (for example, a method or object which knows how to create the view or view model for the specific model type and how to wire them together). When you need to create a view model for a specific model, you could pass this model to the service which could, for example, return the corresponding view model with the model inside it. The dictionary of the aforementioned service could be populated, for example, when a module is initialized: the module could register in the shared service the model types that are defined inside it, and the delegates or \"presenters\" used to create the corresponding view models.</p>\r\n<p>Also, as a possible approach to avoid the casting exceptions that you are mentioning, you could create an interface (for example, <strong>IBaseViewModel</strong>) that could be implemented by the <strong>BaseViewModel </strong>class. Then, the <strong>viewModelCollection </strong>(or any collection you want to use to save the view models) could be of type <strong>IBaseViewModel</strong> instead of type <strong>BaseViewModel</strong>. Based on my understanding, as the <strong>SquareViewModel </strong>and the <strong>CircleViewModel </strong>would also implement <strong>IBaseViewModel</strong> through inheritance, the exception might be avoided.</p>\r\n<p>I hope you find this useful,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-01-24T11:04:53.747-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "730162",
    "ThreadId": "286888",
    "Html": "<p>Hi ﻿DCherubini,</p>\r\n<p>Thanks again for your quick and helpful reply. Short before you replied I already found out about the use of an interface to be able to put everything together in a list. Seeying you come up with the exact same solution makes me confident i'm on the right path. With the introduction of the interface the ExportFactory&lt;&gt; also works like a charm. When I think of it, it does exactly as you described regarding the shared service!</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">interface</span> IViewModelBase\r\n    {\r\n        <span style=\"color: blue;\">void</span> SetModel(<span style=\"color: blue;\">object</span> model);\r\n        <span style=\"color: blue;\">bool</span> HasModel(<span style=\"color: blue;\">object</span> model);\r\n    }\r\n</pre>\r\n</div>\r\n<p>together with this base class:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">public</span> <span style=\"color: blue;\">abstract</span> <span style=\"color: blue;\">class</span> ViewModelBase\r\n        : ExtendedNotificationObject, IViewModelBase <span style=\"color: blue;\">where</span> TModel : <span style=\"color: blue;\">class</span>\r\n    {\r\n        <span style=\"color: blue;\">protected</span> TModel Model;\r\n\r\n        <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> SetModel(TModel model)\r\n        {\r\n            Model = model;\r\n            OnModelChanged();\r\n        }\r\n\r\n        <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> SetModel(<span style=\"color: blue;\">object</span> model)\r\n        {\r\n            <span style=\"color: blue;\">if</span> (model <span style=\"color: blue;\">is</span> TModel)\r\n            {\r\n                SetModel((TModel) model);\r\n            }\r\n        }\r\n\r\n        <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">bool</span> HasModel(TModel model)\r\n        {\r\n            <span style=\"color: blue;\">return</span> Model == model;\r\n        }\r\n\r\n        <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">bool</span> HasModel(<span style=\"color: blue;\">object</span> model)\r\n        {\r\n            <span style=\"color: blue;\">return</span> Model == model;\r\n        }\r\n\r\n        <span style=\"color: blue;\">protected</span> <span style=\"color: blue;\">virtual</span> <span style=\"color: blue;\">void</span> OnModelChanged()\r\n        {\r\n            <span style=\"color: green;\">// Set base properties here</span>\r\n        }\r\n\r\n        <span style=\"color: green;\">// Define base properties</span>\r\n}\r\n</pre>\r\n</div>\r\n<p>Now makes it possible to create the CircleViewModel and SquareViewModels and put them in a single List&lt;IViewModelBase&gt;&nbsp;.</p>\r\n<p>The shared service you mentioned is also easy to realise once you have that interface and knowledge of ExportFactory&lt;&gt;:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>    [Export]\r\n    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">sealed</span> <span style=\"color: blue;\">class</span> ViewModelFactory&lt;TIViewModelBase&gt;\r\n        <span style=\"color: blue;\">where</span> TIViewModelBase : IViewModelBase\r\n    {\r\n        <span style=\"color: green;\">//http://mef.codeplex.com/wikipage?title=Exports%20and%20Metadata</span>\r\n        [ImportMany(AllowRecomposition = <span style=\"color: blue;\">true</span>)]\r\n        <span style=\"color: blue;\">private</span> IEnumerable&lt;ExportFactory&lt;TIViewModelBase, ITypeMetadata&gt;&gt; Factories { <span style=\"color: blue;\">get</span>; <span style=\"color: blue;\">set</span>; }\r\n\r\n        <span style=\"color: blue;\">public</span> TIViewModelBase Create(<span style=\"color: blue;\">string</span> viewModelType)\r\n        {\r\n            <span style=\"color: green;\">// Factory creates view models of type viewModelType</span>\r\n            <span style=\"color: blue;\">var</span> factory = (<span style=\"color: blue;\">from</span> f <span style=\"color: blue;\">in</span> Factories\r\n                           <span style=\"color: blue;\">where</span> f.Metadata.Type.Equals(viewModelType)\r\n                           <span style=\"color: blue;\">select</span> f).First();\r\n\r\n            <span style=\"color: blue;\">return</span> factory.CreateExport().Value;\r\n        }\r\n\r\n        <span style=\"color: blue;\">public</span> TIViewModelBase CreateFrom(Type type)\r\n        {\r\n            <span style=\"color: blue;\">var</span> vmTypeName = type.Name + <span style=\"color: #a31515;\">\"ViewModel\"</span>;\r\n            <span style=\"color: blue;\">return</span> Create(vmTypeName);\r\n        }\r\n\r\n        <span style=\"color: blue;\">public</span> TIViewModelBase CreateFrom(<span style=\"color: blue;\">object</span> model)\r\n        {\r\n            <span style=\"color: blue;\">var</span> vm = CreateFrom(model.GetType());\r\n            vm.SetModel(model);\r\n            <span style=\"color: blue;\">return</span> vm;\r\n        }\r\n    }\r\n</pre>\r\n</div>\r\n<p>&nbsp;Using it now only requires importing the factory above and calling CreateFrom(&lt;My Model&gt;) to receive a correctly instantiated view model based on the supplied model! The default CreationPolicy for the factory above is NonShared, does this mean that it returns the same instance for</p>\r\n<p>[import]<br />ViewModelFactory&lt;IBaseViewModel&gt;Factories1<br /><br />[import]<br />ViewModelFactory&lt;IAnotherSetOfViewModelsThatHaveThisType&gt; Factories2</p>\r\n<p>I expect it not too (as TIViewModel differs).</p>\r\n<p>Do you think this is the right approach? To me it feels a lot better than what I had before, but you are the expert ;-). Thanks again for your help :)</p>",
    "PostedDate": "2012-01-24T13:16:16.4-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "731318",
    "ThreadId": "286888",
    "Html": "<p>Hi,</p>\r\n<p>Based on my understanding, I believe that the approach you mentioned above could be valid to fulfill this scenario. Thanks for sharing it with the rest of the community as it might be useful for other users with similar concerns.</p>\r\n<p>Thanks,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-01-26T13:09:30.38-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]