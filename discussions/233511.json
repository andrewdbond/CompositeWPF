[
  {
    "Id": "517176",
    "ThreadId": "233511",
    "Html": "\r\n<p>Is there a way to sort the views that get added to a ItemsControl region? The views being added are registered with the container and added to the region in each unique module.</p>\r\n<p>Some pseudo code...</p>\r\n<p>Shell:</p>\r\n<p><code>&lt;Window&gt;</code><br>\r\n<code>&lt;ItemsControl Prism:RegionManager.Region=&quot;ItemsRegion&quot;/&gt;</code><br>\r\n<code>&lt;/Window&gt;</code></p>\r\n<p>Modules: This is the initialization code in the modules.</p>\r\n<pre><code><span>&nbsp; &nbsp; </span><span>protected</span><span> </span><span>override</span><span> </span><span>void</span><span> </span><span>RegisterViewsAndServices</span><span>()</span><span><br>&nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>CommonContainerLifetimeManager</span><span>.</span><span>Register</span><span>&lt;</span><span>IView</span><span>,</span><span> </span><span>ItemView1</span><span>&gt;();</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>Container</span><span>.</span><span>RegisterType</span><span>&lt;</span><span>IViewModel</span><span>,</span><span> </span><span>ItemViewModel1</span><span>&gt;(</span><span class=\"str\">&quot;ItemViewModel1&quot;</span><span>);</span><span><br>&nbsp; &nbsp; </span><span>}</span><span><br><br>&nbsp; &nbsp; </span><span>public</span><span> </span><span>override</span><span> </span><span>void</span><span> </span><span>AdditionalInitialization</span><span>()</span><span><br>&nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>var</span><span> itemView1 </span><span>=</span><span> </span><span>Container</span><span>.</span><span>Resolve</span><span>&lt;</span><span>ItemView1</span><span>&gt;();</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>RegionManager</span><span>.</span><span>Regions</span><span>[</span><span class=\"str\">&quot;ItemsRegion&quot;</span><span>].</span><span>Add</span><span>(</span><span>itemView1</span><span>);</span><span><br>&nbsp; &nbsp; </span><span>}</span><span><br></span></code></pre>\r\n<p>With this approach it is showing the added views in the shell's itemscontrol in the order the modules are loaded. Based on the role of the logged on user different modules are loaded. Is there a way, without having to add a collection inbetween, to sort\r\n the itemscontrol.items on a property of the view's viewmodel for example? Is there a way to force the modules to be loaded in a certain order? I am currently using a module catalog.</p>\r\n<p>Thanks</p>\r\n<p>Andy</p>\r\n",
    "PostedDate": "2010-11-04T10:02:55.553-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "517313",
    "ThreadId": "233511",
    "Html": "\r\n<p>Hi Andy,</p>\r\n<p>If you need to load the ModuleA before others, you could indicate in your other Modules that they depends on ModuleA. For more information on this topic, you could take a look at the following documentation section:</p>\r\n<ul>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/ff921124%28PandP.20%29.aspx\">How to: Define Dependencies Between Modules</a>\r\n</li></ul>\r\n<p>If you are using a ModuleCatalog, it might look like the following:</p>\r\n<pre><span style=\"color:blue\">&lt;</span><span style=\"color:#a31515\">Modularity:ModuleInfo </span><span style=\"color:red\">ModuleName</span><span style=\"color:blue\">=</span>&quot;<span style=\"color:blue\">ModuleB</span>&quot; <span style=\"color:red\">ModuleType</span><span style=\"color:blue\">=</span>&quot;<span style=\"color:blue\">ModuleB.ModuleB, ModulesB, Version=1.0.0.0</span>&quot;<span style=\"color:blue\">&gt;<br>  &lt;</span><span style=\"color:#a31515\">Modularity:ModuleInfo.DependsOn</span><span style=\"color:blue\">&gt;<br>    &lt;</span><span style=\"color:#a31515\">sys:String</span><span style=\"color:blue\">&gt;</span>ModuleA<span style=\"color:blue\">&lt;/</span><span style=\"color:#a31515\">sys:String</span><span style=\"color:blue\">&gt;<br>  &lt;/</span><span style=\"color:#a31515\">Modularity:ModuleInfo.DependsOn</span><span style=\"color:blue\">&gt;<br>&lt;/</span><span style=\"color:#a31515\">Modularity:ModuleInfo</span><span style=\"color:blue\">&gt;<br>&lt;</span><span style=\"color:#a31515\">Modularity:ModuleInfo </span><span style=\"color:red\">ModuleName</span><span style=\"color:blue\">=</span>&quot;<span style=\"color:blue\">ModuleC</span>&quot; <span style=\"color:red\">ModuleType</span><span style=\"color:blue\">=</span>&quot;<span style=\"color:blue\">ModuleC.ModuleC, ModulesC, Version=1.0.0.0</span>&quot;<span style=\"color:blue\">&gt;<br>  &lt;</span><span style=\"color:#a31515\">Modularity:ModuleInfo.DependsOn</span><span style=\"color:blue\">&gt;<br>    &lt;</span><span style=\"color:#a31515\">sys:String</span><span style=\"color:blue\">&gt;</span>ModuleB<span style=\"color:blue\">&lt;/</span><span style=\"color:#a31515\">sys:String</span><span style=\"color:blue\">&gt;<br>  &lt;/</span><span style=\"color:#a31515\">Modularity:ModuleInfo.DependsOn</span><span style=\"color:blue\">&gt;<br>&lt;/</span><span style=\"color:#a31515\">Modularity:ModuleInfo</span><span style=\"color:blue\">&gt;<br></span></pre>\r\n<p>Hope this helps.</p>\r\n<p>Fernando Antivero <br>\r\n<a href=\"http://blogs.southworks.net/fantivero\">http://blogs.southworks.net/fantivero</a></p>\r\n",
    "PostedDate": "2010-11-04T13:28:07.907-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "518545",
    "ThreadId": "233511",
    "Html": "\r\n<p>I have just been battling with the same issue myself in that I was trying to define an order to modules that were loaded into a WPF TabControl, however I am using a DirectoryModuleCatalog whereby all modules are simply loaded at startup from a directory\r\n without any explicit configuration.</p>\r\n<p>The solution proposed whereby you define dependencies between modules seems to be hijacking the dependency feature for a completely different purpose. i.e. Module B may indeed be dependent on Module A to be 'loaded' first, but that doesn't necessarily mean\r\n it should be displayed in that order.</p>\r\n<p>The solution I have just come up with was to add a new RegionAdapter and Host Aware Region Behavior to wire up my own binding to a CollectionViewSource that is in turn bound to the Regions.Views collection.</p>\r\n<p>In my bootstrapper, I've added the following method:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>\r\n<span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> RegionAdapterMappings ConfigureRegionAdapterMappings()\r\n{\r\n\tRegionAdapterMappings mappings = <span style=\"color:blue\">base</span>.ConfigureRegionAdapterMappings();\r\n\tmappings.RegisterMapping(<span style=\"color:blue\">typeof</span>(TabControl), <span style=\"color:blue\">this</span>.Container.Resolve&lt;TabControlRegionAdapter&gt;());\r\n\t<span style=\"color:blue\">return</span> mappings;\r\n}\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>The TabControlRegionAdapter then looks like this:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> TabControlRegionAdapter : RegionAdapterBase&lt;TabControl&gt;\r\n{\r\n\t<span style=\"color:blue\">public</span> TabControlRegionAdapter(IRegionBehaviorFactory regionBehaviorFactory) : <span style=\"color:blue\">base</span>(regionBehaviorFactory) {}\r\n\t\r\n\t<span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> Adapt(IRegion region, TabControl regionTarget) {}\r\n\t\r\n\t<span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> AttachBehaviors(IRegion region, TabControl regionTarget)\r\n\t{\r\n\t\tregion.Behaviors.Add(\r\n\t\t\tTabControlSortedItemsBehavior.BehaviorKey, \r\n\t\t\t<span style=\"color:blue\">new</span> TabControlSortedItemsBehavior() { HostControl = regionTarget });\r\n\t\t<span style=\"color:blue\">base</span>.AttachBehaviors(region, regionTarget);\r\n\t}\r\n\r\n\t<span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> IRegion CreateRegion()\r\n\t{\r\n\t\t<span style=\"color:blue\">return</span> <span style=\"color:blue\">new</span> Region();\r\n\t}\r\n}\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>And the TabControlSortedItemsBehavior looks like this:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> TabControlSortedItemsBehavior : RegionBehavior, IHostAwareRegionBehavior\r\n{\r\n\t<span style=\"color:blue\">public</span> <span style=\"color:blue\">static</span> <span style=\"color:blue\">readonly</span> <span style=\"color:blue\">string</span> BehaviorKey = <span style=\"color:#a31515\">&quot;TabControlSortedItemsBehavior&quot;</span>;\r\n\t<span style=\"color:blue\">private</span> TabControl hostControl;\r\n\r\n\t<span style=\"color:blue\">public</span> DependencyObject HostControl\r\n\t{\r\n\t\t<span style=\"color:blue\">get</span>\r\n\t\t{\r\n\t\t\t<span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>.hostControl;\r\n\t\t}\r\n\r\n\t\t<span style=\"color:blue\">set</span>\r\n\t\t{\r\n\t\t\t<span style=\"color:blue\">this</span>.hostControl = value <span style=\"color:blue\">as</span> TabControl;\r\n\t\t}\r\n\t}\r\n\r\n\t<span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> OnAttach()\r\n\t{\r\n\t\t<span style=\"color:blue\">bool</span> itemsSourceIsSet = <span style=\"color:blue\">this</span>.hostControl.ItemsSource != <span style=\"color:blue\">null</span>;\r\n<span style=\"color:blue\">#if</span> !SILVERLIGHT\r\n\t\titemsSourceIsSet = itemsSourceIsSet || (BindingOperations.GetBinding(<span style=\"color:blue\">this</span>.HostControl, ItemsControl.ItemsSourceProperty) != <span style=\"color:blue\">null</span>);\r\n<span style=\"color:blue\">#endif</span>\r\n\t\t<span style=\"color:blue\">if</span> (!itemsSourceIsSet)\r\n\t\t{\r\n\t\t\tCollectionViewSource cvs = <span style=\"color:blue\">new</span> CollectionViewSource();\r\n\t\t\tcvs.Source = <span style=\"color:blue\">this</span>.Region.Views;\r\n\t\t\tcvs.SortDescriptions.Add(<span style=\"color:blue\">new</span> SortDescription(<span style=\"color:#a31515\">&quot;Order&quot;</span>, ListSortDirection.Ascending));\r\n\t\t\t<span style=\"color:blue\">this</span>.hostControl.ItemsSource = cvs.View;\r\n\t\t}\r\n\t}\r\n}\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>I then have my views implement an IOrderableView interface that contains a single int property called Order that defines an arbitrary integer value that I can set to define the order I want my view to appear in. This is a very simplistic implementation that\r\n doesn't handle re-sorting or anything, but its a starting point that could easily be built upon to expose the CollectionViewSource and provide those features.&nbsp;</p>\r\n",
    "PostedDate": "2010-11-07T21:55:57.64-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]