[
  {
    "Id": "778859",
    "ThreadId": "326352",
    "Html": "\r\n<p>What about the Prism EventAggregator?<br>\r\n<br>\r\nMany people first come into contact with the Event Aggregator pattern through the implementation in Prism.&nbsp; For my regular readers you may be shocked (shocked I say!) to know that I don&rsquo;t particularly care for the way they implemented the pattern\r\n in Prism.&nbsp; I think the Prism implementation is clumsy and awkward to use.&nbsp; I despise that idiom of first getting the event aggregator, then retrieving an &ldquo;Event&rdquo; object that I&rsquo;ll then listen to.&nbsp; Same thing with publishing.&nbsp;\r\n I think it&rsquo;s awkward that I have two steps (get event, then publish) instead of just saying &ldquo;IEventAggregator.Send().&rdquo;&nbsp; All of that is unnecessary noise code, and the &ldquo;get event, then listen/publish&rdquo; adds a little bit of\r\n overhead to every single unit test that I write that involves either listening to or sending events (more mock object setup, and that would add up more than the extra production code).&nbsp; No, that&rsquo;s not a huge deal, but noise code adds up, and every\r\n bit of ceremony/noise code I can remove due to infrastructure will make me more productive and the code easier to deal with by making it easier to read.<br>\r\n<br>\r\nAll I want is to go:<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp; IEventAggregator.Send( the message ).&nbsp; Nothing else.<br>\r\n&nbsp;&nbsp;&nbsp; The listeners should have little or preferably NO/ZILCH/NADA coupling to the event aggregator.<br>\r\n<br>\r\nI think Prism is far better than CAB, but it&rsquo;s still headed for some of the same problems that CAB had.&nbsp; The complexity and awkwardness of the EventAggregator in Prism is directly caused by trying to make the EventAggregator generalized to every\r\n possible scenario that you can think of.&nbsp; You will be able to create a better implementation of EventAggregator for your application by tailoring something simpler for only the things you need.&nbsp; At a minimum, you could at least put an application\r\n specific wrapper around Prism&rsquo;s generalized API&rsquo;s to make them easier to consume.&nbsp; I think you could stand to sacrifice some of the flexibility of the Prism EventAggregator and end up with a simpler to consume alternative.<br>\r\n<br>\r\nDon&rsquo;t take this as a specific criticism of Prism itself, because the real issue is that generalized application frameworks are an automatic compromise.&nbsp; The single most important reason that Prism is better than CAB is that you could easily, and\r\n I do mean easily, roll your own Event Aggregator and replace the one in Prism while still using the rest of Prism.&nbsp; Hooray for &ldquo;Composition over Inheritance.&rdquo;&nbsp; You couldn&rsquo;t do that with CAB.</p>\r\n<p>&nbsp;</p>\r\n<p><span id=\"result_box\" lang=\"en\"><span>Come from</span></span></p>\r\n<p><span id=\"result_box\" lang=\"en\"><span>&nbsp;</span></span>http://codebetter.com/jeremymiller/2009/07/22/braindump-on-the-event-aggregator-pattern/</p>\r\n<p><span id=\"result_box\" lang=\"en\"><span>Seek to help</span></span></p>\r\n",
    "PostedDate": "2012-02-19T02:02:23.087-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "797971",
    "ThreadId": "326352",
    "Html": "<p>Hi,</p>\r\n<p>Thanks for your providing us with you feedback.</p>\r\n<p>Based on my understanding, the <strong>EventAggregator </strong>class is basically a collection of events. The <strong>Subscribe </strong>/ <strong>Publish</strong> functionalities for each event are not implemented in the <strong>EventAggregator </strong>class but in \"event class\" itself (that is, the type of the event's payload which should inherit from <strong>EventBase</strong>). If you do not wish to retrieve the event from the <strong>EventAggregator </strong>each time a <strong>Subscribe </strong>/ <strong>Publish </strong>operation needs to be performed, you could instead retrieve the event only once (through the <strong>GetEvent </strong>method of the <strong>EventAggregator </strong>class), and store the event instead of the <strong>EventAggregator</strong>. Like this you should be able to perform <strong>Subscribe </strong>/ <strong>Publish </strong>operations without requiring to perform the \"get-the-event step.\"</p>\r\n<p>Another possible approach could be to implement an extension method for the <strong>IEventAggregator </strong>interface, which could be in charge of receiving the message to be published as a parameter and internally getting the event and publishing it. However, which approach would be more useful for you will depend mostly of your personal preferences and the requirements of your scenario.</p>\r\n<p>If you believe that the implementation of the event aggregation pattern in Prism should be changed, you can create a work item in the <a href=\"http://compositewpf.codeplex.com/workitem/list/advanced\">Issue Tracker</a> as a suggestion, so that the p&amp;p team can consider it for future releases.</p>\r\n<p>Regards,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-02-23T10:23:58.16-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]