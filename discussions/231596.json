[
  {
    "Id": "509785",
    "ThreadId": "231596",
    "Html": "<p>Hi to all,</p>\r\n<p>I've been experimenting with Prism 2.2 for SL4 according to this example by Jeremy Likness:</p>\r\n<p><a>http://www.wintellect.com/CS/blogs/jlikness/archive/2010/03/15/10320.aspx</a></p>\r\n<p>I noticed that in this example - and many others for that matter - that for each composite View there's an associated Module created as a separate class. Assuming we're implementing MVVM, that means each 'View' has the following files associated with it:</p>\r\n<ol>\r\n<li>the XAML (Orders.xaml)</li>\r\n<li>the XAML code-behind (Orders.xaml.cs)</li>\r\n<li>the ViewModel (OrdersViewModel.cs)</li>\r\n<li>the PRISM Module that implements IModule (OrdersModule.cs)</li>\r\n</ol>\r\n<p>I'm aware that the Module class doesn't have to be an actual file and be written / included somewhere else, but for complexity's sake and to adhere to what the various PRISM examples are showing, let's assume that the Module is in a separate file.</p>\r\n<ol> </ol>\r\n<p>I dunno, but that seems a lot of files for 1 View. Sure it's a small price to pay for the composition, decoupling and good segregation that PRISM and MVVM offer but here's where this thread's title comes into play: Why not let XAML code-behind implement IModule?</p>\r\n<p>Theoretically it's feasible - it's just an interface implementation - but it doesn't show anything. The modules load correctly, but nothing is rendered. Another downside is that the regionManager instance would get instantiated twice, but that's easily solvable:</p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> Orders(IRegionManager r)\r\n{\r\n       <span style=\"color:blue\">if</span> (_regionManager == <span style=\"color:blue\">null</span>)\r\n       {\r\n              _regionManager = r;\r\n       }            \r\n       InitializeComponent();\r\n}<br></pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>I know it's preferable to keep the view's code-behind as 'clean' as possible, but that can also be solved by making all views inherit a main app view where all this IModule management can reside, no? (Please correct me if I'm wrong)</p>\r\n<p>Also, IF it is feasible to have the XAML code-behind as the Module itself, what needs to be done in order for the module to render and actually show? Or perhaps it should and I'm doing something wrong...</p>\r\n<p>So if it's feasible, are there any 'bad practice' warnings anyone can shed some light on that I'm not aware of?</p>\r\n<p>Thanks in advance.</p>",
    "PostedDate": "2010-10-20T00:34:45.55-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "510005",
    "ThreadId": "231596",
    "Html": "<p>Hi,</p>\r\n<p>I am not aware how the Jeremy Likness' example works, but probably is not trying to demonstrate the Prism modularity concept in a complex scenario.</p>\r\n<p>In Prism modules are a set of related concerns. From the <a href=\"http://msdn.microsoft.com/en-us/library/ff921069(PandP.20).aspx\">documentation on MSDN</a>: <em>A module can include a collection of related components, such as features, views,  or business logic, and pieces of infrastructure, such as services for  logging or authenticating users</em>.</p>\r\n<p>It means that modules are not strictly associated to only one view, but also they contain more than one view, services and so on. For example, an scenario might require to create a module with no views, since it only provides services.</p>\r\n<p>Although in modules you will commonly find views, modularity is used for composing a complete logical unit in your application. For more information on this topic, you could take a look at the following documentation section on MSDN: <a href=\"http://msdn.microsoft.com/en-us/library/ff921069(PandP.20).aspx\">Modularity</a></p>\r\n<p>You could think the class that implements IModule as the initialization class of a module. In this class you will add/register views in a particular region, register your services in the container, etc.</p>\r\n<p>Additionally, a more complex scenario of the aforementioned concept is implemented in the <a href=\"http://msdn.microsoft.com/en-us/library/ff921074(PandP.20).aspx\">Stock Reference Implementation</a>, so you could check this application.</p>\r\n<p>Something that you can find interesting is that if you use MEF for modularity in <a href=\"http://compositewpf.codeplex.com/releases/view/53942\">Prism v4</a>, it is not strictly necessary to create a class which implements IModule. This is because views, services and other types are discovered through declarative attributes.&nbsp;</p>\r\n<p>Hope this helps.</p>\r\n<p>Fernando Antivero <br><a href=\"http://blogs.southworks.net/fantivero\">http://blogs.southworks.net/fantivero</a></p>",
    "PostedDate": "2010-10-20T08:52:21.55-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]