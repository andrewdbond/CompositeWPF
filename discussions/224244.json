[
  {
    "Id": "482729",
    "ThreadId": "224244",
    "Html": "<p>With all the work put into Prism, it is sometimes easy to get complacent with your code.&nbsp; While flying on &quot;auto pilot&quot; through a section of code I failed to think before I typed and the result in my application was far from what was expected.</p>\r\n<p>I had created a service module used by most of my other modules.&nbsp; Within that module I have a process that performs a set of tasks on parallel threads.&nbsp; Because the parallel threads all access a shared collection (read only) for parameters in thier tasks, I lock an object&nbsp;during their execution to ensure no other thread can update the collection until the parallel threads have completed their work.&nbsp; I do not release the lock until all the threads are complete.</p>\r\n<p>Each thread publishes an event that is consumed by the other modules in the app.&nbsp; Depending upon the state and the module, there is a call back to another method&nbsp;the same service that is running the parallel tasks.&nbsp; That other method must also lock the object before it can perform it's work.</p>\r\n<p>Well, I had subscribed to the event in the modules on the publishers thread using a strong reference.&nbsp; Without digging into the Event Aggregator's source code I am going to assume that the EventAggregator is not creating a new thread (as implied by the option).&nbsp; This means that my event handler method is called on the same thread as the the parallel task that published the event.&nbsp; As I am sure you probably guessed, I managed to create a deadlock because the call to the service method from the event handler goes into a wait state waiting for the lock to be released on the object and that lock is never released because the parallel task thread is still running waiting for the lock to release.&nbsp; Because that parallel task thread never finishes, the parent thread that created the parallel task threads and locked the object&nbsp;is waiting to join all the parallel threads before finishing and releasing the lock.</p>\r\n<p>So instead, I have subscribed to the event with the background thread option, and since I really did not need the strong reference, I am no longer using it.</p>\r\n<p>A few factors that helped create this deadlock were:</p>\r\n<ul>\r\n<li>The disconnect between the modules and the service made it easy to overlook the logic involved in the processes being performed</li>\r\n<li>Coding different parts at different times created tunnel vision on only the part being worked on instead of the entire flow of logic</li>\r\n<li>Failure to document the processes before coding so these situations are identified before they become a problem</li>\r\n</ul>\r\n<p>If this was highlighted in any Prism documentation, I have yet to find it.&nbsp; Hopefully this lesson helps others avoid some frustration not only in this eventaggregator scenario, but in multithreading in general.</p>\r\n<p>LD</p>",
    "PostedDate": "2010-08-20T05:24:24.007-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "482889",
    "ThreadId": "224244",
    "Html": "<p>Hi LD,</p>\r\n<p>Thanks for sharing with the community your feedback and findings on this topic, since it is really valuable/appreciated. As you mentioned using Event Aggregator you could receive the event in different threads. The following options are offered when subscribing:</p>\r\n<ol>\r\n<li><strong>PublisherThread</strong>. receive the event on the publishers' thread. This is the default setting. </li>\r\n<li><strong>UIThread</strong>. receive the event on the user interface thread. </li>\r\n<li><strong>BackgroundThread</strong>. receive the event asynchronously on a .NET Framework thread-pool thread. </li>\r\n</ol>\r\n<p>This is because a subscriber might need to update an element of its UI in WPF, and only a user interface (UI) thread can perform this action. As it mentioned above, by default the subscriber will&nbsp;receive the event on the publisher's thread.</p>\r\n<p>Additionally, I would like to share the following documentation section on MSDN, where it is mentioned:</p>\r\n<ul>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/ff921122(PandP.20).aspx\">Event Aggreator</a>, see the &ldquo;<em>Subscribing on the User Interface Thread</em>&rdquo; section. </li>\r\n</ul>\r\n<p>Fernando Antivero <br><a href=\"http://blogs.southworks.net/fantivero\">http://blogs.southworks.net/fantivero</a></p>",
    "PostedDate": "2010-08-20T10:37:58.003-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]