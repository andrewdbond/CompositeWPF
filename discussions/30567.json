[
  {
    "Id": "101759",
    "ThreadId": "30567",
    "Html": "Hi all,<br>\r\n<br>\r\nI'm currently getting up to speed with the Composite WPF project and looking to replace Unity with another DI framework (namely Ninject). Initially I had thought that it would just be a matter of duplicating some of the classes in the UnityExtensions project, ie the Bootstrapper and the ContainerAdapter. Indeed this works fine for an example as simple as HelloWorld and things are up and running in no time.<br>\r\n<br>\r\nHowever, when I try to modify StockTraderRI, I notice that the IUnityContainer is being passed around quite a bit - most modules require a reference to it and so do some controllers. For the cases where it's being used to resolve types in the controller and modules, it's acting more as a Service Locator and it feels to me that it would be cleaner to have these dependencies injected instead of explicitly requiring the DI container to resolve them (OrdersController for example). Now this is fairly easy to fix because the dependencies could just be directly injected in the constructor, or if they're not known at construction, then a specific factory could be injected instead of the DI container itself.<br>\r\n<br>\r\nThe more complicated cases arise in the module initialization where the module needs to register/bind some types in the DI container. I haven't thought too deeply on this and it would be good to get some feedback as to what a clean solution would be so that the DI container is not required to be passed in to each module directly.<br>\r\n<br>\r\nOne option would be to expand IContainerFacade a little to allow for the registration of types (with singleton options) - this would be quite easy and solves the vendor dependency, but it still smells a little because the entire container facade would still be being passed around to the modules.<br>\r\n<br>\r\nAnother option may be to create an IModuleInitializer or IModuleRegistrar interface that gets bound during the module registration in the bootstrapper and passed in to the module constructor for use during Initialize (so we'd have, for example, a UnityNewsModuleRegistrar, a WindsorNewsModuleRegistrar, a NinjectNewsModuleRegistrar, etc). As the bootstrapper is already DI container specific, it's less problematic to do any binding here or to have a specific IModuleRegistrar rely on the container. Then, if the module requires certain objects from the DI container after the registration, it could either call something like IModuleRegistrar.Prepare(this) to have properties injected, or possibly cleaner would be to have factories for the required types passed in to the module constructor, which would be in turn initialized by the IModuleRegistrar ready for creating objects when the module needs them.<br>\r\n<br>\r\nOne question that arises from this approach is, are we just replacing the module with the module registrar? If all the module is responsible for is type registration, then the answer is yes and it's kind of a moot solution - although I still feel the modules should then technically be called UnityNewsModule, UnityPositionModule, etc.<br>\r\n<br>\r\nI would argue though that module initialization is probably made up of a number of steps, of which the DI registration is only one - the rest is the logic around adding views to regions, running controllers, etc. If the DI registration step can be factored out into small, DI-specific registrars, then it makes it much easier to swap one DI implementation for another.<br>\r\n<br>\r\nSo what do you guys think?<br>\r\n<br>\r\nCheers,<br>\r\n<br>\r\nMichael<br>\r\n",
    "PostedDate": "2008-06-30T17:39:09.83-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "101821",
    "ThreadId": "30567",
    "Html": "At the risk of breaking the space-time continuum, or at the very least occupying compulsive link-followers for a few hours, the NinjectExtensions doodling can be found <span><a href=\"http://groups.google.com/group/ninject/browse_thread/thread/cb6b5ad652714b9b\">here</a>. This works for the HelloWorld example and should work for any projects you create from scratch.</span>",
    "PostedDate": "2008-07-01T02:24:02.313-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "101941",
    "ThreadId": "30567",
    "Html": "<p>Hi Michael</p>\r\n<p>Your observations are good ones. Supporting multiple IOC containers was an explict goal from the get-go in Prism. However early on we made a decision that doing so doesn't necessarily equate to the &quot;one container to rule them all.&quot; We made the decision that &quot;support&quot; means that at the low-level (our 'framework) none of our apis explicitly depend on one container or another. On the other hand, at the high-level within the application we decided we should not have such an abstraction. The reasoning is very simple. Containers have different semantics and syntaxes. <br>\r\n<br>\r\nPart of the reason I choose to use Castle Windsor over Structure Map, NInject, etc is because I like the particular attributes of that container. If I like Structure Map's fluent interface then I want to use that, not some dumbed down abstraction. For this reason we very explicitly use IUnityContainer throughout the RI. We would equally expect if you used NInject then that is what you would use instead. Once I commit to a container, it's unlikely that I would want to change mid-way. However you want to make sure that whatever container you make the decision to use does not block your usage of the patterns and libraries. Now at the core levels, you would need an implementation of IContainerFacade for NInject, and possibly a Bootstrapper if you like the Bootstrapper pattern. <br>\r\n<br>\r\nIn this way you can use Prism with any container, while at the same time leverage all of the specific benefits each container provides.<br>\r\n<br>\r\nAs far as the module implementation itself, the reason we inject the container into the module is to allow registration of module-specific types AT load time. This way those types are only registered if the module is loaded. The module is not only used for registering but also instantiating views and controllers. We could have wrapped this with specific services like a ViewService and a ControllerService instead of using the container directly. However, we felt that had the same issues around losing container semantics and such. We could consider this for the future if this is what everyone wants though.<br>\r\n<br>\r\nLet us know if this rationale makes sense. Thanks for the feedback!</p>\r\n",
    "PostedDate": "2008-07-01T11:30:52.31-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "102025",
    "ThreadId": "30567",
    "Html": "Hi gblock,\r\n<div><br>\r\n</div>\r\n<div>The rationale of allowing the modules to register their types at load time makes complete sense - I apologise if my post doesn't make this clear. In fact, most of my post was dedicated to how to solve this particular problem while still allowing the container its semantics - this is actually what I was hoping to get some feedback on.<br>\r\n</div>\r\n<div><br>\r\n</div>\r\n<div>Based on past experience, many people will assume that the way they see things done in a reference implementation is the way they should be done - ie, that reference implementations represent best practice. For example, OrdersController.StartOrder&nbsp;depends on some presentation models - I don't think I'd be alone in saying it's better practice from a DI perspective to inject these dependencies rather than have OrdersController depend on Unity and have a reference to the container. It may be my lack of knowledge of Unity, but I don't see any &quot;container semantics&quot; being used here, or indeed anywhere in StockTraderRI where types are resolved. In a sense it'd be killing two birds by refactoring this because the code would be clearer (you only see the dependencies you actually need) and it also makes the &quot;support&quot; of multiple DI containers ring a little truer. What better place to show this support than in the tutorials and reference implementation?</div>\r\n<div><br>\r\n</div>\r\n<div>Perhaps it's not a good comparison, but I think that ASP.NET MVC is a great example of a platform that provides an easy way to swap one DI container for another.</div>\r\n<div><br>\r\n</div>\r\n<div>Now, even if the &quot;container as a service locator&quot; patterns are refactored, there's still the issue of how best to let modules register their dependencies while still allowing each DI container to do it's thing, and it'd be great to hear some thoughts on the ideas that I proposed as I'm sure there's smarter ways to do it. Refactoring out the DI registration from the module initialization into container-specific registrars, while keeping the non-container-specific glue logic is just the first way that popped into my head - and it certainly still allows for whatever container semantics you want because each registrar will be container-specific (just as the bootstrapper is for example).</div>\r\n<div><br>\r\n</div>\r\n<div>I guess I just feel that this project is a great way to show best practice for modular WPF apps, or indeed desktop apps in general - and if just a few small changes were made to the module loading process, then DI-agnosticity (?) could be one of those best practices.</div>\r\n<div><br>\r\n</div>\r\n<div>I realise for large, complex projects that this may not be achievable - but for the apps included with the release, it's certainly possible (and I would almost say trivial)!</div>\r\n<div><br>\r\n</div>\r\n<div>Cheers,</div>\r\n<div><br>\r\n</div>\r\n<div>Michael<br>\r\n<br>\r\nEdit: Fixed weird font formatting<br>\r\n</div>\r\n",
    "PostedDate": "2008-07-01T18:13:07.833-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "102307",
    "ThreadId": "30567",
    "Html": "Hi Michael <br>\r\n<br>\r\nThanks for the feedback. In this case having the presentation model in the constructor wouldn't have helped us or we would have done it. OrdersController is a singleton, while the StartOrder method creates a new order screen for each order. As such it needs to resolve a new IOrderPresentationModel instance for each order.<br>\r\n<br>\r\nWe could have possibly created an OrderPresentationModelFactory which is injected, and then have StartOrder use it for creating the model. We would also need an OrderCompositePresentationModelFactory as well. Before long with this approach we are creating lots of factories unecessarily. I was was talking with Chris Tavares today about this and he had the idea of registering a generic Resolver&lt;T&gt; (he called it Factory) with the container. This would then get the container injected into itself on construction and use it to to resolve specific instances in a clean fashion without requring writing lots of factories by and, and also without requring explicit access to the container. I like the sound of this approach because this way I could inject a Resolver&lt;OrderCompositePresentationModel&gt; and a Resolver&lt;OrderPresentationModel&gt; in the constructor of the controller.<br>\r\n<br>\r\nThe other place where we use the container directly is at the module level in registering types. This actaully doesn't have to happen in code and can be in config.&nbsp;The downside of one configuration is that those types will all get&nbsp;registered whether the module&nbsp;loads or not...unless we can have&nbsp;the services in config AND have them only registered if the module loads. I've talked to Chris about&nbsp;how we can&nbsp;support this with&nbsp;Unity. You can&nbsp;have a global config file for the contianer, but have sub-configurations&nbsp;within it (1 per module). This would let you have your cake and eat it to on the registration part. This would complement well the Resolver method above that I just described.<br>\r\n<br>\r\nI&nbsp;may do a post on this (I say may&nbsp;instead of will since&nbsp;I find I only get a round to a fraction of the thigns i say I will do :) )&nbsp;\r\n",
    "PostedDate": "2008-07-02T21:01:51.873-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "102345",
    "ThreadId": "30567",
    "Html": "Great - that idea regarding the OrdersController is exactly the sort of thing I was hoping for!<div><br></div><div>In terms of type registration in the modules - I don't necessarily think it has to be in a &quot;config file&quot; as such (not all DI containers support config files), and I certainly wouldn't want it to happen until the module loads.</div><div><br></div><div>Unless you're talking about a generic config file that you could write a simple parser for for each DI container, which I guess wouldn't be so bad.</div><div><br></div><div>I still wonder though whether the concept of a module bootstrapper, or type register isn't the right way to go.</div><div><br></div><div>public interface IModuleBootstrapper</div><div>{</div><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">public IModule InitializeModule();<br></blockquote><div>}</div><div><br></div><div>public class UnityNewsBootstrapper : IModuleBootstrapper</div><div>{</div><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">protected readonly IUnityContainer container;<br></blockquote><div><br></div><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">public UnityNewsBootstrapper(IUnityContainer container)<br></blockquote><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">{<br></blockquote><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\"><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">this.container = container;<br></blockquote></blockquote><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\"><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">// register the types...</blockquote>}</blockquote><div><br></div><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">// This could actually be factored into a base UnityModuleBootstrapper class</blockquote><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">public IModule InitializeModule()<br></blockquote><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">{<br></blockquote><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\"><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">// Create and inject dependencies into the module<br></blockquote></blockquote><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\"><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">var newsModule = container.Resolve&lt;NewsModule&gt;();<br></blockquote></blockquote><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\"><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">newsModule.Initialize();<br></blockquote></blockquote><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\"><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">return newsModule;<br></blockquote></blockquote><blockquote style=\"margin:0 0 0 40px;border:none;padding:0px\">}<br></blockquote><div>}</div><div><br></div><div>It would be cleaner to utilise generics, but you get the idea.</div><div><br></div><div>Too much effort? Too messy?</div>",
    "PostedDate": "2008-07-03T00:40:42.85-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "211160",
    "ThreadId": "30567",
    "Html": "<p>Actually, it would be the best if IContainer or IEventaggr or DI attributes are located under Composite or Composite.Presentation assemblies. The developers who are working on the Module shouldn't use anything related to Unity-specific or UnityExtension specific in their modules. Then, it will be very easy for them to switch the IoC container that they like.&nbsp;</p>\r\n<p>I'm facing that problem. I'm award of that Prism allows us to switch Ioc containers but I failed to explore how to switch and started using IUnityContainer or a lot of things which are specifc to Unity. Now, I want to try to switch to another IoC container but I couldn't because there are too many dependencies of Unity in my modules. :(&nbsp;</p>",
    "PostedDate": "2009-07-11T23:32:54.927-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "211162",
    "ThreadId": "30567",
    "Html": "<p>Hi Michael</p>\r\n<p>We deliberately did not go to such a level of abstraction when we were desiging Prism. The reasoning was that it was an unnecessary complexity, and it prevents you from being able to take advantage of the full features of the container, as you end up in a least-common-denominator situation. We also believed that if one made the decision to develop an application using a specific container, it was unlikely they would decide to change mid-way.</p>\r\n<p>Glenn</p>",
    "PostedDate": "2009-07-11T23:55:29.913-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "211163",
    "ThreadId": "30567",
    "Html": "<p>@mhart what advantage do you think the module registrar woudl buy you?</p>",
    "PostedDate": "2009-07-11T23:57:55.083-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "240180",
    "ThreadId": "30567",
    "Html": "<p>This is an interesting discussion, I am currently working on using CAL with Windsor and I've noticed the same thing in the StockTrader app.&nbsp;</p>\r\n<p>Glenn, I see what you are saying about needing new instances and hence the reference to IUnityContainer.&nbsp; Still this dependency on the container sprinkled throughout the app feels a bit iffy to me, particularly since UnityContainer is a very different implementation from say WindsorContainer.&nbsp; I know for my app I will be avoiding having a dependency on IWindsorContainer except in the bootstrapper and IModule classes.</p>\r\n<p>A potential  solution that would make the StockTrader implementation more &quot;pluggable&quot; might be to try the following:</p>\r\n<p>1. Only register services in the bootstrapper, or IModule classes (which I believe is already true)</p>\r\n<p>2. Resolve services where necessary using the ServiceLocator or another static container class that provides a Resolve&lt;T&gt;();</p>\r\n<p>This way changing containers can be done simply via a ServiceLocatorAdapter and doesn't require modifying every class that depends on IUnityContainer to work with IWindsorContainer or otherwise.</p>\r\n<p>On a related note, while I can't speak for other IoCs I know that Windsor does not autoregister classes when you call Resolve&lt;Class&gt;() like unity does.&nbsp; Nor does it default to transient lifestyle behavior.&nbsp; In it's use of the ServiceLocator the CAL seems to assume this will happen when GetInstance() is called requiring the following adapter implementation:<br>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>    <span style=\"color:Blue\">protected</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">object</span> DoGetInstance(Type serviceType, <span style=\"color:Blue\">string</span> key){\r\n      <span style=\"color:Blue\">if</span> (serviceType.IsClass &amp;&amp; !_container.Kernel.HasComponent(serviceType))\r\n        _container.AddComponentLifeStyle(serviceType.FullName, serviceType, LifestyleType.Transient);\r\n      <span style=\"color:Blue\">if</span> (String.IsNullOrEmpty(key)) <span style=\"color:Blue\">return</span> _container.Resolve(serviceType);\r\n      <span style=\"color:Blue\">return</span> _container.Resolve(key, serviceType);\r\n    }\r\n</pre>\r\n</div>\r\n</p>\r\n<p>This isn't really a big deal, but it &quot;feels&quot; a bit like a Unity dependency in CAL to me.</p>",
    "PostedDate": "2009-09-29T15:21:34.927-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]