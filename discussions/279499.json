[
  {
    "Id": "698344",
    "ThreadId": "279499",
    "Html": "\r\n<p>Is it possible to load all the onDemand modules in a specific order ? Indeed, i've found this code but it works only for modules that are not loaded at runtime:&nbsp;<a href=\"http://stackoverflow.com/questions/1296642/how-to-control-the-order-of-module-initialization-in-prism\">http://stackoverflow.com/questions/1296642/how-to-control-the-order-of-module-initialization-in-prism</a></p>\r\n<p>&nbsp;</p>\r\n<p>Any ideas ?</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks !</p>\r\n",
    "PostedDate": "2011-11-15T04:23:07.047-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "698550",
    "ThreadId": "279499",
    "Html": "<p>Hi,</p>\r\n<p>Based on my understanding of your scenario, if you are loading <strong></strong>modules on Demand, then you will need to write the code in your application that requests the module to be loaded. Hence you could define your own logic to make this requests in the desired order. To make this request you can use the following method:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>moduleManager.LoadModule(<span style=\"color: #a31515;\">\"ModuleX\"</span>);\r\n</pre>\r\n</div>\r\n</p>\r\n<p>On the other hand if you want to ensure that a module is initialized before another one, you could try specifying module dependencies.</p>\r\n<p>You might find more information about this in <a href=\"http://msdn.microsoft.com/en-us/library/gg405479%28v=PandP.40%29.aspx\">Chapter 4: Modular Application Development</a> of the Prism documentation at MSDN:</p>\r\n<ul>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/gg405479(v=PandP.40).aspx#sec33\">Requesting On-Demand Loading of a Module</a></li>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/gg405479(v=PandP.40).aspx#sec25\">Specifying Module Dependencies</a></li>\r\n</ul>\r\n<p>Please let us know if we misunderstood your scenario.</p>\r\n<p>Thanks,</p>\r\n<p>Agustin Adami<a href=\"http://blogs.southworks.net/aadami\"><br /> http://blogs.southworks.net/aadami</a>﻿</p>",
    "PostedDate": "2011-11-15T10:32:25.38-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "698631",
    "ThreadId": "279499",
    "Html": "<p>Hi Agustin,</p>\r\n<p>Thanks for your answer ! In fact, I already know how to load a module using the moduleManager. Here is my exact scenario: I have a Shell window that is composed by a Ribbon control. Each module in the Modules folder will populate the Ribbon with custom tab. By default, the ModuleCatalog contains all the module sort by name. So if i have the modules Invoices and Orders and i load them on demand, they will be loaded in the same order:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\">// Load all the modules except the \"Login\" module (the only module with InitializationMode set to 'WhenAvailable').</span>\r\n<span style=\"color: blue;\">foreach</span> (<span style=\"color: blue;\">var</span> module <span style=\"color: blue;\">in</span> <span style=\"color: blue;\">this</span>.ModuleCatalog.Modules.Where(m =&gt; m.InitializationMode != InitializationMode.WhenAvailable))\r\n{\r\n    <span style=\"color: blue;\">this</span>.ModuleManager.LoadModule(module.ModuleName);\r\n}\r\n</pre>\r\n</div>\r\n</p>\r\n<p>But i would like to change that order and load Orders in first then Invoices. Of course, i could use the ModuleDependency attribute but i would like to avoid it because it must be used with the module name (and my developers are not sure to know the name of the others modules, developed by other developers).</p>\r\n<p>The solution i've found at Stackoverflow works fine but only for modules that are loaded when available, not on demand :(</p>\r\n<p>Is it more clear ?</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks !</p>",
    "PostedDate": "2011-11-15T13:10:43.143-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "698929",
    "ThreadId": "279499",
    "Html": "<p>For those who are interested, i've managed to create a custom DirectoryCatalog that load all the modules, in ModuleCatalog, in the specify order :)</p>\r\n<p>Here is the code:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">public</span> <span style=\"color: blue;\">class</span> PrioritizedDirectoryModuleCatalog : DirectoryModuleCatalog\r\n    {\r\n        <span style=\"color: blue;\">protected</span> <span style=\"color: blue;\">override</span> <span style=\"color: blue;\">void</span> InnerLoad()\r\n        {\r\n            <span style=\"color: blue;\">if</span> (<span style=\"color: blue;\">string</span>.IsNullOrEmpty(<span style=\"color: blue;\">this</span>.ModulePath))\r\n                <span style=\"color: blue;\">throw</span> <span style=\"color: blue;\">new</span> InvalidOperationException(<span style=\"color: #a31515;\">\"The ModulePath cannot contain a null value or be empty\"</span>);\r\n\r\n            <span style=\"color: blue;\">if</span> (!Directory.Exists(<span style=\"color: blue;\">this</span>.ModulePath))\r\n                <span style=\"color: blue;\">throw</span> <span style=\"color: blue;\">new</span> InvalidOperationException(\r\n                    <span style=\"color: blue;\">string</span>.Format(CultureInfo.CurrentCulture, <span style=\"color: #a31515;\">\"Directory {0} was not found.\"</span>, <span style=\"color: blue;\">this</span>.ModulePath));\r\n\r\n            AppDomain childDomain = <span style=\"color: blue;\">this</span>.BuildChildDomain(AppDomain.CurrentDomain);\r\n\r\n            <span style=\"color: blue;\">try</span>\r\n            {\r\n                List&lt;<span style=\"color: blue;\">string</span>&gt; loadedAssemblies = <span style=\"color: blue;\">new</span> List&lt;<span style=\"color: blue;\">string</span>&gt;();\r\n\r\n                <span style=\"color: blue;\">var</span> assemblies = (\r\n                                     <span style=\"color: blue;\">from</span> Assembly assembly <span style=\"color: blue;\">in</span> AppDomain.CurrentDomain.GetAssemblies()\r\n                                     <span style=\"color: blue;\">where</span> !(assembly <span style=\"color: blue;\">is</span> System.Reflection.Emit.AssemblyBuilder)\r\n                                        &amp;&amp; assembly.GetType().FullName != <span style=\"color: #a31515;\">\"System.Reflection.Emit.InternalAssemblyBuilder\"</span>\r\n                                        &amp;&amp; !String.IsNullOrEmpty(assembly.Location)\r\n                                     <span style=\"color: blue;\">select</span> assembly.Location\r\n                                 );\r\n\r\n                loadedAssemblies.AddRange(assemblies);\r\n\r\n                Type loaderType = <span style=\"color: blue;\">typeof</span>(ModulePriorityLoader);\r\n\r\n                <span style=\"color: blue;\">if</span> (loaderType.Assembly != <span style=\"color: blue;\">null</span>)\r\n                {\r\n                    <span style=\"color: blue;\">var</span> loader =\r\n                        (ModulePriorityLoader)\r\n                        childDomain.CreateInstanceFrom(loaderType.Assembly.Location, loaderType.FullName).Unwrap();\r\n                    loader.LoadAssemblies(loadedAssemblies);\r\n                    <span style=\"color: blue;\">this</span>.Items.AddRange(<span style=\"color: blue;\">this</span>.Sort(loader.GetModuleInfos(<span style=\"color: blue;\">this</span>.ModulePath)));\r\n                }\r\n            }\r\n            <span style=\"color: blue;\">finally</span>\r\n            {\r\n                AppDomain.Unload(childDomain);\r\n            }\r\n        }\r\n\r\n        <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;summary&gt;</span>\r\n        <span style=\"color: gray;\">///</span><span style=\"color: green;\"> Sort modules according to dependencies and Priority</span>\r\n        <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;/summary&gt;</span>\r\n        <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;param name=\"modules\"&gt;</span><span style=\"color: green;\">modules to sort&lt;/param&gt;</span>\r\n        <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;returns&gt;</span><span style=\"color: green;\">sorted modules&lt;/returns&gt;</span>\r\n        <span style=\"color: blue;\">protected</span> <span style=\"color: blue;\">override</span> IEnumerable&lt;ModuleInfo&gt; Sort(IEnumerable&lt;ModuleInfo&gt; modules)\r\n        {\r\n            Dictionary&lt;<span style=\"color: blue;\">string</span>, <span style=\"color: blue;\">int</span>&gt; priorities = GetPriorities(modules);\r\n            <span style=\"color: green;\">//call the base sort since it resolves dependencies, then re-sort </span>\r\n            <span style=\"color: blue;\">var</span> result = <span style=\"color: blue;\">new</span> List&lt;ModuleInfo&gt;(<span style=\"color: blue;\">base</span>.Sort(modules));\r\n            result.Sort((x, y) =&gt;\r\n            {\r\n                <span style=\"color: blue;\">string</span> xModuleName = x.ModuleName;\r\n                <span style=\"color: blue;\">string</span> yModuleName = y.ModuleName;\r\n                <span style=\"color: green;\">//if one depends on other then non-dependent must come first</span>\r\n                <span style=\"color: green;\">//otherwise base on priority</span>\r\n                <span style=\"color: blue;\">if</span> (x.DependsOn.Contains(yModuleName))\r\n                    <span style=\"color: blue;\">return</span> 1; <span style=\"color: green;\">//x after y</span>\r\n                <span style=\"color: blue;\">else</span> <span style=\"color: blue;\">if</span> (y.DependsOn.Contains(xModuleName))\r\n                    <span style=\"color: blue;\">return</span> -1; <span style=\"color: green;\">//y after x</span>\r\n                <span style=\"color: blue;\">else</span>\r\n                    <span style=\"color: blue;\">return</span> priorities[xModuleName].CompareTo(priorities[yModuleName]);\r\n            });\r\n\r\n            <span style=\"color: blue;\">return</span> result;\r\n        }\r\n\r\n        <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;summary&gt;</span>\r\n        <span style=\"color: gray;\">///</span><span style=\"color: green;\"> Get the priorities</span>\r\n        <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;/summary&gt;</span>\r\n        <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;param name=\"modules\"&gt;</span><span style=\"color: gray;\">&lt;/param&gt;</span>\r\n        <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;returns&gt;</span><span style=\"color: gray;\">&lt;/returns&gt;</span>\r\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(<span style=\"color: #a31515;\">\"Microsoft.Performance\"</span>, <span style=\"color: #a31515;\">\"CA1822:MarkMembersAsStatic\"</span>), System.Diagnostics.CodeAnalysis.SuppressMessage(<span style=\"color: #a31515;\">\"Microsoft.Reliability\"</span>, <span style=\"color: #a31515;\">\"CA2001:AvoidCallingProblematicMethods\"</span>, MessageId = <span style=\"color: #a31515;\">\"System.Reflection.Assembly.LoadFrom\"</span>)]\r\n        <span style=\"color: blue;\">public</span> Dictionary&lt;<span style=\"color: blue;\">string</span>, <span style=\"color: blue;\">int</span>&gt; GetPriorities(IEnumerable&lt;ModuleInfo&gt; modules)\r\n        {\r\n            <span style=\"color: green;\">//retrieve the priorities of each module, so that we can use them to override the </span>\r\n            <span style=\"color: green;\">//sorting - but only so far as we don't mess up the dependencies</span>\r\n            <span style=\"color: blue;\">var</span> priorities = <span style=\"color: blue;\">new</span> Dictionary&lt;<span style=\"color: blue;\">string</span>, <span style=\"color: blue;\">int</span>&gt;();\r\n            <span style=\"color: blue;\">var</span> assemblies = <span style=\"color: blue;\">new</span> Dictionary&lt;<span style=\"color: blue;\">string</span>, Assembly&gt;();\r\n\r\n            <span style=\"color: blue;\">foreach</span> (ModuleInfo module <span style=\"color: blue;\">in</span> modules)\r\n            {\r\n                <span style=\"color: blue;\">if</span> (!assemblies.ContainsKey(module.Ref))\r\n                {\r\n                    <span style=\"color: green;\">//LoadFrom should generally be avoided appently due to unexpected side effects,</span>\r\n                    <span style=\"color: green;\">//but since we are doing all this in a separate AppDomain which is discarded</span>\r\n                    <span style=\"color: green;\">//this needn't worry us</span>\r\n                    assemblies.Add(module.Ref, Assembly.LoadFrom(module.Ref));\r\n                }\r\n\r\n                Type type = assemblies[module.Ref].GetExportedTypes()\r\n                    .Where(t =&gt; t.AssemblyQualifiedName.Equals(module.ModuleType, StringComparison.Ordinal))\r\n                    .First();\r\n\r\n                <span style=\"color: blue;\">var</span> priorityAttribute =\r\n                    CustomAttributeData.GetCustomAttributes(type).FirstOrDefault(\r\n                        cad =&gt; cad.Constructor.DeclaringType.FullName == <span style=\"color: blue;\">typeof</span>(PriorityAttribute).FullName);\r\n\r\n                <span style=\"color: blue;\">int</span> priority;\r\n                <span style=\"color: blue;\">if</span> (priorityAttribute != <span style=\"color: blue;\">null</span>)\r\n                {\r\n                    priority = (<span style=\"color: blue;\">int</span>)priorityAttribute.ConstructorArguments[0].Value;\r\n                }\r\n                <span style=\"color: blue;\">else</span>\r\n                {\r\n                    priority = 0;\r\n                }\r\n\r\n                priorities.Add(module.ModuleName, priority);\r\n            }\r\n\r\n            <span style=\"color: blue;\">return</span> priorities;\r\n        }\r\n\r\n        <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;summary&gt;</span>\r\n        <span style=\"color: gray;\">///</span><span style=\"color: green;\"> Local class to load assemblies into different appdomain which is then discarded</span>\r\n        <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;/summary&gt;</span>\r\n        <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">class</span> ModulePriorityLoader : MarshalByRefObject\r\n        {\r\n            [System.Diagnostics.CodeAnalysis.SuppressMessage(<span style=\"color: #a31515;\">\"Microsoft.Performance\"</span>, <span style=\"color: #a31515;\">\"CA1822:MarkMembersAsStatic\"</span>)]\r\n            <span style=\"color: blue;\">internal</span> <span style=\"color: blue;\">void</span> LoadAssemblies(IEnumerable&lt;<span style=\"color: blue;\">string</span>&gt; assemblies)\r\n            {\r\n                <span style=\"color: blue;\">foreach</span> (<span style=\"color: blue;\">string</span> assemblyPath <span style=\"color: blue;\">in</span> assemblies)\r\n                {\r\n                    <span style=\"color: blue;\">try</span>\r\n                    {\r\n                        Assembly.ReflectionOnlyLoadFrom(assemblyPath);\r\n                    }\r\n                    <span style=\"color: blue;\">catch</span> (FileNotFoundException)\r\n                    {\r\n                        <span style=\"color: green;\">// Continue loading assemblies even if an assembly can not be loaded in the new AppDomain</span>\r\n                    }\r\n                }\r\n            }\r\n\r\n            [System.Diagnostics.CodeAnalysis.SuppressMessage(<span style=\"color: #a31515;\">\"Microsoft.Performance\"</span>, <span style=\"color: #a31515;\">\"CA1822:MarkMembersAsStatic\"</span>)]\r\n            <span style=\"color: blue;\">internal</span> ModuleInfo[] GetModuleInfos(<span style=\"color: blue;\">string</span> path)\r\n            {\r\n                DirectoryInfo directory = <span style=\"color: blue;\">new</span> DirectoryInfo(path);\r\n\r\n                ResolveEventHandler resolveEventHandler =\r\n                    <span style=\"color: blue;\">delegate</span>(<span style=\"color: blue;\">object</span> sender, ResolveEventArgs args) { <span style=\"color: blue;\">return</span> OnReflectionOnlyResolve(args, directory); };\r\n\r\n                AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve += resolveEventHandler;\r\n\r\n                Assembly moduleReflectionOnlyAssembly =\r\n                    AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies().First(\r\n                        asm =&gt; asm.FullName == <span style=\"color: blue;\">typeof</span>(IModule).Assembly.FullName);\r\n                Type IModuleType = moduleReflectionOnlyAssembly.GetType(<span style=\"color: blue;\">typeof</span>(IModule).FullName);\r\n\r\n                IEnumerable&lt;ModuleInfo&gt; modules = GetNotAllreadyLoadedModuleInfos(directory, IModuleType);\r\n\r\n                <span style=\"color: blue;\">var</span> array = modules.ToArray();\r\n                AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve -= resolveEventHandler;\r\n                <span style=\"color: blue;\">return</span> array;\r\n            }\r\n\r\n            <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">static</span> IEnumerable&lt;ModuleInfo&gt; GetNotAllreadyLoadedModuleInfos(DirectoryInfo directory, Type IModuleType)\r\n            {\r\n                List&lt;FileInfo&gt; validAssemblies = <span style=\"color: blue;\">new</span> List&lt;FileInfo&gt;();\r\n                Assembly[] alreadyLoadedAssemblies = AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies();\r\n\r\n                <span style=\"color: blue;\">var</span> fileInfos = directory.GetFiles(<span style=\"color: #a31515;\">\"*.dll\"</span>)\r\n                    .Where(file =&gt; alreadyLoadedAssemblies\r\n                                       .FirstOrDefault(\r\n                                       assembly =&gt;\r\n                                       String.Compare(Path.GetFileName(assembly.Location), file.Name,\r\n                                                      StringComparison.OrdinalIgnoreCase) == 0) == <span style=\"color: blue;\">null</span>);\r\n\r\n                <span style=\"color: blue;\">foreach</span> (FileInfo fileInfo <span style=\"color: blue;\">in</span> fileInfos)\r\n                {\r\n                    Assembly assembly = <span style=\"color: blue;\">null</span>;\r\n                    <span style=\"color: blue;\">try</span>\r\n                    {\r\n                        assembly = Assembly.ReflectionOnlyLoadFrom(fileInfo.FullName);\r\n                        validAssemblies.Add(fileInfo);\r\n                    }\r\n                    <span style=\"color: blue;\">catch</span> (BadImageFormatException)\r\n                    {\r\n                        <span style=\"color: green;\">// skip non-.NET Dlls</span>\r\n                    }\r\n                }\r\n\r\n                <span style=\"color: blue;\">return</span> validAssemblies.SelectMany(file =&gt; Assembly.ReflectionOnlyLoadFrom(file.FullName)\r\n                                            .GetExportedTypes()\r\n                                            .Where(IModuleType.IsAssignableFrom)\r\n                                            .Where(t =&gt; t != IModuleType)\r\n                                            .Where(t =&gt; !t.IsAbstract)\r\n                                            .Select(type =&gt; CreateModuleInfo(type)));\r\n            }\r\n\r\n            <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">static</span> Assembly OnReflectionOnlyResolve(ResolveEventArgs args, DirectoryInfo directory)\r\n            {\r\n                Assembly loadedAssembly = AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies().FirstOrDefault(\r\n                    asm =&gt; <span style=\"color: blue;\">string</span>.Equals(asm.FullName, args.Name, StringComparison.OrdinalIgnoreCase));\r\n                <span style=\"color: blue;\">if</span> (loadedAssembly != <span style=\"color: blue;\">null</span>)\r\n                {\r\n                    <span style=\"color: blue;\">return</span> loadedAssembly;\r\n                }\r\n                AssemblyName assemblyName = <span style=\"color: blue;\">new</span> AssemblyName(args.Name);\r\n                <span style=\"color: blue;\">string</span> dependentAssemblyFilename = Path.Combine(directory.FullName, assemblyName.Name + <span style=\"color: #a31515;\">\".dll\"</span>);\r\n                <span style=\"color: blue;\">if</span> (File.Exists(dependentAssemblyFilename))\r\n                {\r\n                    <span style=\"color: blue;\">return</span> Assembly.ReflectionOnlyLoadFrom(dependentAssemblyFilename);\r\n                }\r\n                <span style=\"color: blue;\">return</span> Assembly.ReflectionOnlyLoad(args.Name);\r\n            }\r\n\r\n            <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">static</span> ModuleInfo CreateModuleInfo(Type type)\r\n            {\r\n                <span style=\"color: blue;\">string</span> moduleName = type.Name;\r\n                List&lt;<span style=\"color: blue;\">string</span>&gt; dependsOn = <span style=\"color: blue;\">new</span> List&lt;<span style=\"color: blue;\">string</span>&gt;();\r\n                <span style=\"color: blue;\">bool</span> onDemand = <span style=\"color: blue;\">false</span>;\r\n                <span style=\"color: blue;\">var</span> moduleAttribute =\r\n                    CustomAttributeData.GetCustomAttributes(type).FirstOrDefault(\r\n                        cad =&gt; cad.Constructor.DeclaringType.FullName == <span style=\"color: blue;\">typeof</span>(ModuleAttribute).FullName);\r\n\r\n                <span style=\"color: blue;\">if</span> (moduleAttribute != <span style=\"color: blue;\">null</span>)\r\n                {\r\n                    <span style=\"color: blue;\">foreach</span> (CustomAttributeNamedArgument argument <span style=\"color: blue;\">in</span> moduleAttribute.NamedArguments)\r\n                    {\r\n                        <span style=\"color: blue;\">string</span> argumentName = argument.MemberInfo.Name;\r\n                        <span style=\"color: blue;\">switch</span> (argumentName)\r\n                        {\r\n                            <span style=\"color: blue;\">case</span> <span style=\"color: #a31515;\">\"ModuleName\"</span>:\r\n                                moduleName = (<span style=\"color: blue;\">string</span>)argument.TypedValue.Value;\r\n                                <span style=\"color: blue;\">break</span>;\r\n\r\n                            <span style=\"color: blue;\">case</span> <span style=\"color: #a31515;\">\"OnDemand\"</span>:\r\n                                onDemand = (<span style=\"color: blue;\">bool</span>)argument.TypedValue.Value;\r\n                                <span style=\"color: blue;\">break</span>;\r\n\r\n                            <span style=\"color: blue;\">case</span> <span style=\"color: #a31515;\">\"StartupLoaded\"</span>:\r\n                                onDemand = !((<span style=\"color: blue;\">bool</span>)argument.TypedValue.Value);\r\n                                <span style=\"color: blue;\">break</span>;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                <span style=\"color: blue;\">var</span> moduleDependencyAttributes =\r\n                    CustomAttributeData.GetCustomAttributes(type).Where(\r\n                        cad =&gt; cad.Constructor.DeclaringType.FullName == <span style=\"color: blue;\">typeof</span>(ModuleDependencyAttribute).FullName);\r\n\r\n                <span style=\"color: blue;\">foreach</span> (CustomAttributeData cad <span style=\"color: blue;\">in</span> moduleDependencyAttributes)\r\n                {\r\n                    dependsOn.Add((<span style=\"color: blue;\">string</span>)cad.ConstructorArguments[0].Value);\r\n                }\r\n\r\n                ModuleInfo moduleInfo = <span style=\"color: blue;\">new</span> ModuleInfo(moduleName, type.AssemblyQualifiedName)\r\n                {\r\n                    InitializationMode =\r\n                        onDemand\r\n                            ? InitializationMode.OnDemand\r\n                            : InitializationMode.WhenAvailable,\r\n                    Ref = type.Assembly.CodeBase,\r\n                };\r\n                moduleInfo.DependsOn.AddRange(dependsOn);\r\n                <span style=\"color: blue;\">return</span> moduleInfo;\r\n            }\r\n        }\r\n    }\r\n</pre>\r\n</div>\r\n</p>\r\n<p>And here is the code of the PriorityAttribute:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>[AttributeUsage(AttributeTargets.Class, AllowMultiple = <span style=\"color: blue;\">false</span>)]\r\n<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">sealed</span> <span style=\"color: blue;\">class</span> PriorityAttribute : Attribute\r\n{\r\n    <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;summary&gt;</span>\r\n    <span style=\"color: gray;\">///</span><span style=\"color: green;\"> Constructor</span>\r\n    <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;/summary&gt;</span>\r\n    <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;param name=\"priority\"&gt;</span><span style=\"color: green;\">the priority to assign&lt;/param&gt;</span>\r\n    <span style=\"color: blue;\">public</span> PriorityAttribute(<span style=\"color: blue;\">int</span> priority)\r\n    {\r\n        <span style=\"color: blue;\">this</span>.Priority = priority;\r\n    }\r\n\r\n    <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;summary&gt;</span>\r\n    <span style=\"color: gray;\">///</span><span style=\"color: green;\"> Gets or sets the priority of the module.</span>\r\n    <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;/summary&gt;</span>\r\n    <span style=\"color: gray;\">///</span> <span style=\"color: gray;\">&lt;value&gt;</span><span style=\"color: green;\">The priority of the module.&lt;/value&gt;</span>\r\n    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">int</span> Priority { <span style=\"color: blue;\">get</span>; <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">set</span>; }\r\n}\r\n</pre>\r\n</div>\r\n</p>\r\n<p>Feel free to share any feedbacks/comments about the above code :)</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks !</p>",
    "PostedDate": "2011-11-16T05:32:03.197-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "698930",
    "ThreadId": "279499",
    "Html": "<p>Hi,</p>\r\n<p>Based on my understanding, you could benefit from the <strong>LoadModuleCompleted </strong>event provided by the <strong>ModuleManager </strong>service, which will allow you to track when a module loads or fails to load, this way you can react when a module completed its loading. You can find more information about this in the following <a href=\"http://msdn.microsoft.com/en-us/library/gg405479(v=PandP.40).aspx#sec37\">link</a> of the Prism documentation.</p>\r\n<p>Also, you could try decorating the views in your modules with the <strong>ViewSortHint </strong>attribute, this will allow you to define how views will appear in controls that displays multiple active views, instead of showing views in the order they were registered and added into the region.<br />You can find more information about this in the following chapter of the Prism documentation at MSDN:</p>\r\n<ul>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/ff921098(v=PandP.40).aspx#sec40\">Chapter 7: Composing the User Interface,Ordering Views in a Region</a></li>\r\n</ul>\r\n<p>I hope you find this handy</p>\r\n<p>Agustin Adami<a href=\"http://blogs.southworks.net/aadami\"><br /> http://blogs.southworks.net/aadami</a>﻿﻿</p>",
    "PostedDate": "2011-11-16T05:35:52.943-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "698935",
    "ThreadId": "279499",
    "Html": "<p>Hi,</p>\r\n<p>Thank you for sharing you solution with the rest of the community! At first sight it seems like a reasonable approach to fulfill your scenario, and it can also be re used on different occasions.</p>\r\n<p>Thanks,</p>\r\n<p>Guido Leandro Maliandi <br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-11-16T05:44:43.307-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "698937",
    "ThreadId": "279499",
    "Html": "<blockquote style=\"border: solid .1em #ccc; font-style: italic; margin: .25em 1em 0 1em; padding: 0 .25em 0 .25em;\"><strong>aadami wrote:</strong><br />\r\n<p>Hi,</p>\r\n<p>Based on my understanding, you could benefit from the <strong>LoadModuleCompleted </strong>event provided by the <strong>ModuleManager </strong>service, which will allow you to track when a module loads or fails to load, this way you can react when a module completed its loading. You can find more information about this in the following <a href=\"http://msdn.microsoft.com/en-us/library/gg405479(v=PandP.40).aspx#sec37\"> link</a> of the Prism documentation.</p>\r\n</blockquote>\r\n<p>I'm sorry but i'm not sure to understand how the event could help me to load my modules in a particular order.... Could you provide me an example ?</p>\r\n<blockquote style=\"border: solid .1em #ccc; font-style: italic; margin: .25em 1em 0 1em; padding: 0 .25em 0 .25em;\"><strong>aadami wrote:</strong><br />\r\n<p>Also, you could try decorating the views in your modules with the <strong>ViewSortHint </strong>attribute, this will allow you to define how views will appear in controls that displays multiple active views, instead of showing views in the order they were registered and added into the region.<br /> You can find more information about this in the following chapter of the Prism documentation at MSDN:</p>\r\n<ul>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/ff921098(v=PandP.40).aspx#sec40\">Chapter 7: Composing the User Interface,Ordering Views in a Region</a> </li>\r\n</ul>\r\n<p>I hope you find this handy</p>\r\n<p>Agustin Adami<a href=\"http://blogs.southworks.net/aadami\"><br /> http://blogs.southworks.net/aadami</a>﻿﻿</p>\r\n</blockquote>\r\n<p>Indeed, that might be useful.</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks !</p>",
    "PostedDate": "2011-11-16T05:48:04.62-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "698939",
    "ThreadId": "279499",
    "Html": "<blockquote style=\"border: solid .1em #ccc; font-style: italic; margin: .25em 1em 0 1em; padding: 0 .25em 0 .25em;\"><strong>GuidoMaliandi wrote:</strong><br />\r\n<p>Hi,</p>\r\n<p>Thank you for sharing you solution with the rest of the community! At first sight it seems like a reasonable approach to fulfill your scenario, and it can also be re used on different occasions.</p>\r\n<p>Thanks,</p>\r\n<p>Guido Leandro Maliandi <br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>\r\n</blockquote>\r\n<p>That's good news, thanks ! :)</p>",
    "PostedDate": "2011-11-16T05:49:35.217-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "698943",
    "ThreadId": "279499",
    "Html": "<p>Hi,</p>\r\n<p>If you know the order in which you will load your modules, you can load the first one, listen to the <strong>LoadModuleCompleted </strong>event, and load the following one after the first one has been loaded, and so forth until all your modules are loaded in order. However, in this case following the approach you mentioned in your previous post, or using the ViewSortHint attribute might be a better option for you. This is because, in my opinion, it's better to have each of your modules define itself its priority (using your custom <strong>PriorityAttribute</strong>) or the order of its views (through the <strong>ViewSortHint </strong>attribute), instead of a global component (e.g. your bootstrapper) managing the priorities in a centralized manner.</p>\r\n<p>I hope you find this useful.</p>\r\n<p>Guido Leandro Maliandi <br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-11-16T05:55:09.01-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "698955",
    "ThreadId": "279499",
    "Html": "<blockquote style=\"border: solid .1em #ccc; font-style: italic; margin: .25em 1em 0 1em; padding: 0 .25em 0 .25em;\"><strong>GuidoMaliandi wrote:</strong><br />\r\n<p>Hi,</p>\r\n<p>If you know the order in which you will load your modules, you can load the first one, listen to the <strong>LoadModuleCompleted </strong>event, and load the following one after the first one has been loaded, and so forth until all your modules are loaded in order. However, in this case following the approach you mentioned in your previous post, or using the  ViewSortHint attribute might be a better option for you. This is because, in my opinion, it's better to have each of your modules define itself its priority (using your custom <strong>PriorityAttribute</strong>) or the order of its views (through the <strong> ViewSortHint </strong>attribute), instead of a global component (e.g. your bootstrapper) managing the priorities in a centralized manner.</p>\r\n<p>I hope you find this useful.</p>\r\n<p>Guido Leandro Maliandi <br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>\r\n</blockquote>\r\n<p>I agree: in my mind, each module should define itself its priority and other information and should not depend of a global component.</p>",
    "PostedDate": "2011-11-16T06:15:02.59-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]