[
  {
    "Id": "83143",
    "ThreadId": "24804",
    "Html": "\r\nVoodoo - that's what our team has labeled the \"behind-the-scenes\" Microsoft magic that we can't see, as in the case of our discussions surrounding bindingsources, binding navigators, etc.<br /><br />There is some serious Voodoo, good mojo, going on with Prism - nothing in the StockTraderRI to indicate the view is instantiating a presenter and then injecting itself into it.   I had to plug in the Unity/Objectbuilder source to get some insight into the process and was hoping some blanks could be filled in.   <br /><br />My best guess is that the RegionManager.Region statements within the XAML are self-registering Workspaces (in SCSF terms); registering themselves during InitializeComponents.  I noted there is some dynamic IL buildplan mojo going on during the Buildup process - eventually we end up in the Presenter's contructor with a view reference - very cool voodo to say the least.  I'm very curious as to how the buildplan knew to utilize the IWatchListView mapping for the WatchListViewPresenter.<br /><br />Can't wait to see how this evolves!<br /><br /><br /><br /><br /><br />",
    "PostedDate": "2008-03-26T20:04:17.217-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "83147",
    "ThreadId": "24804",
    "Html": "\r\nIt's quite easy actually:<br /><br /><ul><li>Bootstrapper loads modules</li><li>PositionModule creates PositionSummaryPresenter which (with the aid of UnityContainer) will create/resolve the view</li><li>PositionSummaryPresenter.ShowViews() create ITrendLinePresenter which in turn creates/resolves TrendLineView</li></ul><br />This could go one and one but it's actually pretty straight forward.<br /><br />In order to understand dependency injection under the hood, you should look at the Unity project on codeplex.<br />",
    "PostedDate": "2008-03-26T20:41:59.707-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "83228",
    "ThreadId": "24804",
    "Html": "<div class=\"quote\" style=\"border: dotted .1em #aaa; border-left: none; border-right: none; font-style: italic; margin: 1em 0em 2.5em 3em;padding: .2em;\"><br />francois_tanguay wrote:<br /><br /><ul><li>PositionModule creates PositionSummaryPresenter which (with the aid of UnityContainer) will create/resolve the view</li></ul><br />In order to understand dependency injection under the hood, you should look at the Unity project on codeplex.<br /><br /></div><br />I remember back in the day I could look under the hood of my 70 Mustang and see my spark plug wires and coil; today my 99 mustang has fuel injection and more wires than I can trace.    I just about had my arms around the ObjectBuilder but with WCSF and Prism I'm seeing a lot of IL-code emitting - \"under the hood\" just got more complex - I havn't grasped it (yet).  <br /><br />Your response confirmed my suspicion that the Presenter's (Unity) buildplan creates/resolves the view - what wasn't apparent to me, because of the IL-code emitting, was how it was resolved, i.e, when I create my view and presenter where/how do I establish the dependency?<br />",
    "PostedDate": "2008-03-27T06:57:47.713-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "83253",
    "ThreadId": "24804",
    "Html": "\r\nBy default, Unity will automatically pick the Presenter's longest constructor. It will then look every parameter type through reflection and establish dependencies to inject this way.<br /><br />If those dependencies represent interfaces or abstract types, it will look into the registered types to find a match and then instantiate the concrete type to fulfill the dependency.<br />",
    "PostedDate": "2008-03-27T08:21:12.67-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "83257",
    "ThreadId": "24804",
    "Html": "<br /><div class=\"quote\" style=\"border: dotted .1em #aaa; border-left: none; border-right: none; font-style: italic; margin: 1em 0em 2.5em 3em;padding: .2em;\"><br />francois_tanguay wrote:<br />By default, Unity will automatically pick the Presenter's longest constructor. It will then look every parameter type through reflection and establish dependencies to inject this way.<br /><br />If those dependencies represent interfaces or abstract types, it will look into the registered types to find a match and then instantiate the concrete type to fulfill the dependency.<br /><br /></div><br />Very nice .....<br /><br />Thanks!  That clarifies a lot.<br />",
    "PostedDate": "2008-03-27T08:36:40.68-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "84327",
    "ThreadId": "24804",
    "Html": "\r\n@Bill<br /><br />Views and Presenters are being registered at the module level. This is how views are able to be discovered. Look into any of the module classes and you will see methods that do this registration.<br /><br />As far as regions, we are doing something different. We have a RegionManagerService that holds pointers to all the different regions that are created. To build up regions we are leveraging some WPF Voodoo :) We've created an attached Region property which can be attached to any region. A region from a WPF perspective is simply a wrapper to a UIElement that is a container. When you declare the region in XAML, the RegionManager will get invoked, and willl throw an event. The RegionManagerService listens to this event and then adds the Region to it's internal collection. The service is hard coded so it creates one of two classes, either an ItemRegion or a PanelRegion depending on the type of control.<br /><br />The downside to this approach is that we've hardcoded to allow creating only one of two regions. In the next drop this is going to get a face lift. Instead of hardcoding the handlers for regions, we've created an IRegion&lt;T&gt; interface, with T representing a UIElement. When a region is added, the RegionManagerService will look at the UIElement type and then attempt to resolve an IRegion&lt;&gt; for that type from the IPrismContainer. If it does not find one, it will recursively walk the inheritance tree until it does find one. Once it finds one, then it will manufacture an instance and register it. In this model, by using IPrismContainer we're externalizing the handlers for regions to being registered through config rather than hard-coding. Look for more on this in our wiki.<br /><br /><br /><div class=\"quote\" style=\"border: dotted .1em #aaa; border-left: none; border-right: none; font-style: italic; margin: 1em 0em 2.5em 3em;padding: .2em;\"><br />BillKrat wrote:<br />Voodoo - that's what our team has labeled the \"behind-the-scenes\" Microsoft magic that we can't see, as in the case of our discussions surrounding bindingsources, binding navigators, etc.<br /><br />There is some serious Voodoo, good mojo, going on with Prism - nothing in the StockTraderRI to indicate the view is instantiating a presenter and then injecting itself into it.   I had to plug in the Unity/Objectbuilder source to get some insight into the process and was hoping some blanks could be filled in.   <br /><br />My best guess is that the RegionManager.Region statements within the XAML are self-registering Workspaces (in SCSF terms); registering themselves during InitializeComponents.  I noted there is some dynamic IL buildplan mojo going on during the Buildup process - eventually we end up in the Presenter's contructor with a view reference - very cool voodo to say the least.  I'm very curious as to how the buildplan knew to utilize the IWatchListView mapping for the WatchListViewPresenter.<br /><br />Can't wait to see how this evolves!<br /><br /><br /><br /><br /><br /><br /><br /></div>",
    "PostedDate": "2008-04-01T15:24:14.13-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "84651",
    "ThreadId": "24804",
    "Html": "\r\n@Glenn<br /><br />Thank you for taking the time to clarify these very important areas to understanding Prism (under the hood).  For the benefit of those, like me, who are new to WPF and Dependency Injection (I was introduced to DI with the ObjectBuilder in SCSF and now WCSF - WPF is totally new) I will regurgitate what you noted above with the applicable source code and a laymans view.  This should make it easier for developers to visualize your comments while verifying that I understood the information you provided (I trust if I missed something someone will let us know).<br /><br />I provide the following within the context of a developer new to Prism and Unity (not in any way complaining about the architecture); the gurus may be to far removed from our ignorance (haven't learned - not can't learn) so it may be more difficult to provide us what we need to know to get off the ground without much patience; what is quite obvious to the gurus may have us totally lost.  Perhaps raising the awareness of this gap may make communications easier?  <br /><br />So I say again - THANK YOU -  your and francois_tanquays time and patience is deeply appreciated!<br />----<br /><div class=\"quote\" style=\"border: dotted .1em #aaa; border-left: none; border-right: none; font-style: italic; margin: 1em 0em 2.5em 3em;padding: .2em;\"><br />Views and Presenters are being registered at the module level. This is how views are able to be discovered. Look into any of the module classes and you will see methods that do this registration.<br /><br /></div><br /><br />The following is very straight-forward and easy to understand<br /><br /><b>Bootstrapper.cs</b><br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\n        private void InitializeModules()\r\n        {\r\n            IModule newsModule = new NewsModule(container);\r\n            IModule watchListModule = new WatchListModule(container);\r\n            IModule marketModule = new MarketModule(container);\r\n            IModule positionModule = new PositionModule(container);\r\n \r\n            newsModule.Initialize();\r\n            marketModule.Initialize();\r\n            watchListModule.Initialize();\r\n            positionModule.Initialize();\r\n        }\r\n</pre><br />Where it got very confusing is that outside of the presenter's constructor parameter list, the following class is the only reference to the IWatchListView and WatchListView.  The DI folks will chuckle at this confusion, but for us MVP folks we're looking for where the view instantiates the presenter and places a reference to itself into it.  I suspect that developers not familiar with MVP and DI will most likely be totally lost.<br /><br />The following Initialize() method will seem foreign to MVP folks (almost backwards) leaving us scratching our head trying to figure out how the view get's instantiated.  Fortunately francois_tanquay did a great job of clearing this up above.<br /><br /><b>WatchListModule.cs</b><br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\n    public class WatchListModule : IModule\r\n    {\r\n        private IUnityContainer container;\r\n \r\n        public WatchListModule(IUnityContainer container)\r\n        {\r\n            this.container = container;\r\n        }\r\n \r\n        public void Initialize()\r\n        {\r\n            RegisterViewsAndServices();\r\n \r\n            WatchListViewPresenter presenter = container.Resolve&lt;WatchListViewPresenter&gt;();\r\n            presenter.ShowViews();\r\n        }\r\n \r\n        public void RegisterViewsAndServices()\r\n        {\r\n            container.RegisterType&lt;IWatchListView, WatchListView&gt;();\r\n            container.RegisterType&lt;IWatchListService, WatchListService&gt;();\r\n        }\r\n \r\n        #endregion\r\n    }\r\n</pre><br />Immediately after the Unity container is instantiated and initialized the RegisterGlobalServices() method is called which ensures our RegionManagerService is available.<br /><br /><b>BootStrapper.cs</b><br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\n    public class Bootstrapper : IDisposable\r\n    {\r\n        IUnityContainer container;\r\n \r\n        public void Initialize()\r\n        {\r\n            InitializeContainer();\r\n==&gt;     RegisterGlobalServices();\r\n            InitializeShell();\r\n            InitializeModules();\r\n \r\n        }\r\n \r\n        private void RegisterGlobalServices()\r\n        {\r\n==&gt;         container.RegisterInstance&lt;IRegionManagerService&gt;(new RegionManagerService());\r\n        }\r\n</pre><br /><br />The constructor for the manager service will subscribe to the RegionManager's static <b>RegionPropertyChanged</b> event. When the event is raised the <b>RegionManager_RegionPropertyChanged</b> event handler will call the <b>SetRegion</b> method which wraps the panel or ItemsControl (later IRegion&lt;T&gt;) and adds it to the RegionManagerService _regions dictionary.<br /><br /><b>RegionManagerService.cs</b><br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\n    public class RegionManagerService : IRegionManagerService, IDisposable\r\n    {\r\n        private Dictionary&lt;string, IRegion&gt; _regions = new Dictionary&lt;string, IRegion&gt;();\r\n \r\n        public RegionManagerService()\r\n        {\r\n            RegionManager.RegionPropertyChanged += RegionManager_RegionPropertyChanged;\r\n        }\r\n \r\n        void RegionManager_RegionPropertyChanged(object sender, RegionPropertyChangedEventArgs e)\r\n        {\r\n            SetRegion(e.ContainerElement, e.RegionName);\r\n        }\r\n \r\n        public void SetRegion(DependencyObject containerElement, string regionName)\r\n        {\r\n            IRegion region = null;\r\n \r\n            if (containerElement is Panel)\r\n            {\r\n                region = new PanelRegion((Panel)containerElement);\r\n            }\r\n            else if (containerElement is ItemsControl)\r\n            {\r\n                region = new ItemsControlRegion((ItemsControl)containerElement);\r\n            }\r\n \r\n            if (region != null)\r\n                _regions.Add(regionName, region);\r\n        }\r\n</pre><br /><b>Shell.xaml</b><br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\n&lt;StackPanel Grid.Row=\"1\" Grid.Column=\"0\"&gt;\r\n   &lt;Grid prism:RegionManager.Region=\"mainRegion\"&gt;&lt;/Grid&gt;\r\n   &lt;TabControl Name=\"newsTab\" prism:RegionManager.Region=\"ResearchArticlesRegion\" \r\n \r\nItemContainerStyle=\"{StaticResource HeaderStyle}\" /&gt;\r\n&lt;/StackPanel&gt;\r\n</pre><br />The above is where your comments shed the most light and revealed some pretty powerful mojo.   If I understood you correctly the DependencyProperty.RegisterAttached(...) method is the Voodoo that you were referring to.   My assumption is that &lt;Grid <b>prism:RegionManager.Region=\"mainRegion\"</b>&gt;&lt;/Grid&gt;* is a dynamically generated property created by the RegisterAttached process - very very nice.  My second assumption is that the <b>prism:RegionManager.Region</b> setter is responsible for executing the callback method, i.e., OnSetRegionCallBack which in turn raises the RegionPropertyChanged event identified above.<br /><br /><b>RegionManager.cs</b><br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\nnamespace Prism\r\n{\r\n    public static class RegionManager\r\n    {\r\n        public static readonly DependencyProperty RegionProperty = DependencyProperty.RegisterAttached(\r\n            \"Region\",\r\n            typeof(string),\r\n            typeof(RegionManager),\r\n            new PropertyMetadata(OnSetRegionCallback));\r\n \r\n        public static event EventHandler&lt;RegionPropertyChangedEventArgs&gt; RegionPropertyChanged;\r\n \r\n        public static void SetRegion(DependencyObject containerElement, string regionName)\r\n        {\r\n            containerElement.SetValue(RegionProperty, regionName);\r\n        }\r\n \r\n        public static void OnSetRegionCallback(DependencyObject containerElement, \r\n \r\nDependencyPropertyChangedEventArgs args)\r\n        {\r\n            if (RegionPropertyChanged != null)\r\n            {\r\n                RegionPropertyChanged(null, new RegionPropertyChangedEventArgs(containerElement, \r\n \r\nargs.NewValue.ToString()));\r\n            }\r\n        }\r\n    }\r\n}\r\n \r\n</pre><br />",
    "PostedDate": "2008-04-02T19:11:42.227-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]