[
  {
    "Id": "158441",
    "ThreadId": "47338",
    "Html": "Hi,<br>\r\n<br>\r\nWe keep running up against an issue in WPF where changing the CommandParameter of an ICommandSource (e.g. Button or MenuItem) doesn't cause a call to CanExecute with the new parameter. Often we find that even if we never change the CommandParameter,&nbsp; the Command gets set first so we only get a call to CanExecute with a null parameter. It's also very annoying if the CommandParameter comes from a binding.<br>\r\n<br>\r\nI've written what I think is a fix in the form of an attached behavior that you can set on the Button, etc that will listen for changes to the CommandParameter and call RaiseCanExecuteChanged if the command is a DelegateCommand.<br>\r\n<br>\r\nUsage is like:<br>\r\n<pre>    &lt;Button Command=&quot;{Binding ...}&quot; <br>            CommandParameter=&quot;{Binding ...}&quot; <br>            prismCommands:CommandParameterBehavior.IsCommandRequeriedOnChange=&quot;true&quot; /&gt;</pre>\r\nYou can, of course, set this in an application wide style for the various controls you care about.<br>\r\n<br>\r\nWould you be interested in including this upstream? I'll post the patch below.<br>\r\nN.B. To get it to work, I had to create an interface for the non-generic bits of DelegateCommand&lt;T&gt; (i.e. RaiseCanExecuteChanged). \r\n",
    "PostedDate": "2009-02-17T04:13:16.443-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "158445",
    "ThreadId": "47338",
    "Html": "<strong>Edit:</strong>I've had to strip out all the xml comments, as they were messing up the formatting. If you want them, I have written some!<br>\r\n<br>\r\nFirstly, I had to add an IDelegateCommand interface, and make DelegateCommand&lt;T&gt; inherit from that (not shown).<br>\r\n<pre>    public interface IDelegateCommand : ICommand, IActiveAware<br>    {<br>        void RaiseCanExecuteChanged();<br>    }</pre>\r\nThe important class, though, is the one below with the attached behavior. <br>\r\n<br>\r\nNote that I've tried to handle the Unloaded event sensibly to avoid the memory leak that would otherwise be caused by using PropertyDescriptor.AddValueChanged. I'm pretty sure that works, but I've not tested it in anything other than a trivial scenario.<br>\r\n<pre>using System;<br>using System.ComponentModel;<br>using System.Windows;<br>using System.Windows.Input;<br><br>namespace Microsoft.Practices.Composite.Wpf.Commands<br>{<br>    public static class CommandParameterBehavior<br>    {<br>        public static readonly DependencyProperty IsCommandRequeriedOnChangeProperty =<br>            DependencyProperty.RegisterAttached(&quot;IsCommandRequeriedOnChange&quot;,<br>                                                typeof(bool),<br>                                                typeof(CommandParameterBehavior),<br>                                                new UIPropertyMetadata(false, new PropertyChangedCallback(OnIsCommandRequeriedOnChangeChanged)));<br><br>        public static bool GetIsCommandRequeriedOnChange(DependencyObject target)<br>        {<br>            return (bool)target.GetValue(IsCommandRequeriedOnChangeProperty);<br>        }<br><br>        public static void SetIsCommandRequeriedOnChange(DependencyObject target, bool value)<br>        {<br>            target.SetValue(IsCommandRequeriedOnChangeProperty, value);<br>        }<br><br>        private static void OnIsCommandRequeriedOnChangeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)<br>        {<br>            if (!(d is ICommandSource))<br>                return;<br><br>            if (!(d is FrameworkElement || d is FrameworkContentElement))<br>                return;<br><br>            if ((bool)e.NewValue)<br>            {<br>                HookCommandParameterChanged(d);<br>            }<br>            else<br>            {<br>                UnhookCommandParameterChanged(d);<br>            }<br><br>            UpdateCommandState(d);<br>        }<br><br>        private static PropertyDescriptor GetCommandParameterPropertyDescriptor(object source)<br>        {<br>            return TypeDescriptor.GetProperties(source.GetType())[&quot;CommandParameter&quot;];<br>        }<br><br>        private static void HookCommandParameterChanged(object source)<br>        {<br>            var propertyDescriptor = GetCommandParameterPropertyDescriptor(source);<br>            propertyDescriptor.AddValueChanged(source, OnCommandParameterChanged);<br><br>            // N.B. Using PropertyDescriptor.AddValueChanged will cause &quot;source&quot; to never be garbage collected,<br>            // so we need to hook the Unloaded event and call RemoveValueChanged there.<br>            HookUnloaded(source);<br>        }<br><br>        private static void UnhookCommandParameterChanged(object source)<br>        {<br>            var propertyDescriptor = GetCommandParameterPropertyDescriptor(source);<br>            propertyDescriptor.RemoveValueChanged(source, OnCommandParameterChanged);<br><br>            UnhookUnloaded(source);<br>        }<br><br>        private static void HookUnloaded(object source)<br>        {<br>            var fe = source as FrameworkElement;<br>            if (fe != null)<br>            {<br>                fe.Unloaded += OnUnloaded;<br>            }<br><br>            var fce = source as FrameworkContentElement;<br>            if (fce != null)<br>            {<br>                fce.Unloaded += OnUnloaded;<br>            }<br>        }<br><br>        private static void UnhookUnloaded(object source)<br>        {<br>            var fe = source as FrameworkElement;<br>            if (fe != null)<br>            {<br>                fe.Unloaded -= OnUnloaded;<br>            }<br><br>            var fce = source as FrameworkContentElement;<br>            if (fce != null)<br>            {<br>                fce.Unloaded -= OnUnloaded;<br>            }<br>        }<br><br>        static void OnUnloaded(object sender, RoutedEventArgs e)<br>        {<br>            UnhookCommandParameterChanged(sender);<br>        }<br><br>        static void OnCommandParameterChanged(object sender, EventArgs ea)<br>        {<br>            UpdateCommandState(sender);<br>        }<br><br>        private static void UpdateCommandState(object target)<br>        {<br>            var commandSource = target as ICommandSource;<br><br>            if (commandSource == null)<br>                return;<br><br>            var rc = commandSource.Command as RoutedCommand;<br>            if (rc != null)<br>            {<br>                CommandManager.InvalidateRequerySuggested();<br>            }<br><br>            var dc = commandSource.Command as IDelegateCommand;<br>            if (dc != null)<br>            {<br>                dc.RaiseCanExecuteChanged();<br>            }<br><br>        }<br>    }<br>}</pre>\r\n",
    "PostedDate": "2009-02-17T04:20:51.663-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "428939",
    "ThreadId": "47338",
    "Html": "<p>There's a relatively simple way to &quot;fix&quot; this problem with DelegateCommand, though it requires updating the DelegateCommand source and re-compiling the Microsoft.Practices.Composite.Presentation.dll.</p>\r\n<p>1)&nbsp; Download the Prism&nbsp;1.2 source code and open the CompositeApplicationLibrary_Desktop.sln.&nbsp; In here is a Composite.Presentation.Desktop project that contains the DelegateCommand source.</p>\r\n<p>2) Under the public event EventHandler CanExecuteChanged, modify to read as follows:</p>\r\n<p>&nbsp;&nbsp;&nbsp; public event EventHandler CanExecuteChanged<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WeakEventHandlerManager.AddWeakReferenceHandler( ref _canExecuteChangedHandlers, value, 2 );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // add this line<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CommandManager.RequerySuggested += value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WeakEventHandlerManager.RemoveWeakReferenceHandler( _canExecuteChangedHandlers, value );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // add this line<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CommandManager.RequerySuggested -= value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</p>\r\n<p>3) Under protected virtual void OnCanExecuteChanged(), modify it as follows:</p>\r\n<p>&nbsp;&nbsp;&nbsp; protected virtual void OnCanExecuteChanged()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // add this line<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CommandManager.InvalidateRequerySuggested();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WeakEventHandlerManager.CallWeakReferenceHandlers( this, _canExecuteChangedHandlers );<br>&nbsp;&nbsp;&nbsp; }</p>\r\n<p>4) Recompile the solution, then navigate to either the Debug or Release folder where the compiled DLLs live.&nbsp; Copy the Microsoft.Practices.Composite.Presentation.dll and .pdb (if you wish) to where you references your external assemblies, and then recompile your application to pull the new versions.</p>\r\n<p>After this, CanExecute should be fired every time the UI renders elements bound to the DelegateCommand in question.</p>\r\n<p>Take care,<br>Joe</p>\r\n<p>refereejoe at gmail</p>",
    "PostedDate": "2010-04-08T11:08:56.3-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "429170",
    "ThreadId": "47338",
    "Html": "<p>Thanks Joe. I notice that most other ICommand implementations do effectively the same thing (i.e. forward CanExecuteChanged through to CommandManager.RequerySuggested).</p>\r\n<p>I think if you're doing that, there's no need to leave the existing implementation (using _canExecuteChangedHandlers) in place, as it will be handled by the CommandManager. With both implementations in place the handlers will get called twice when you call OnCanExecuteChanged, won't they?</p>\r\n<p>The downside of this approach, IIUC, is that the CanExecuteChanged handlers will get called (more or less) every time the UI renders <strong>any </strong>element bound to <strong>any </strong>command, though, won't they? Some of our CanExecute methods are a bit slow (very bad design ,I know. I promise I'll fix them soon!) so calling them more often than necessary could be &quot;unfortunate&quot;.</p>\r\n<p>BTW: As it turns out, my implementation above wasn't good enough, as the Loaded &amp; Unloaded events don't come in pairs (the Loaded event is often fired more than once), so you can end up with multiple event subscriptions (e.g. for MenuItems, IIRC). If anyone is interested I can post an updated version. Given the amount of code necessary to do it my way, I'm tempted to switch to the CommandManager.InvalidateRequerySuggested solution. :-)</p>",
    "PostedDate": "2010-04-09T02:13:59.453-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1104967",
    "ThreadId": "47338",
    "Html": "The sad thing here is to change the PRISM code ourselves... It would be nice to have a patch or version with CommandManager...<br />\n",
    "PostedDate": "2013-10-08T05:12:28.553-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1127581",
    "ThreadId": "47338",
    "Html": "Would love to see this released as a patch so I don't have to keep rewriting this bit of code in all my projects.<br />\n",
    "PostedDate": "2013-11-21T08:20:31.537-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1161912",
    "ThreadId": "47338",
    "Html": "Running into the same problem.  I'm not sure I understand this architecture.  I have some generic commands (Open, Close, Properties) associated with MenuItem commands in a ContextMenu.  I'm using the CompositeCommand pattern of PRISM to implement.  So that I don't have to create 1,000 different ContextMenus on the line items I show in my grid, I just create a single ContextMenu and use the DataContext of each of the line items to provide a context for the ContextMenu.  However, when I change the CommandParameter on the menu item to be the new DataContext of the current line item, the CanExecuteChanged event is not invoked.  What am I missing here?  How do you construct a complex, multi-module application if you need access to the DelegateCommand of every command you create?<br />\n",
    "PostedDate": "2014-01-13T10:26:20.783-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1161932",
    "ThreadId": "47338",
    "Html": "I think one should think carefully before choose PRISM as their framework.\r<br />\nI'm stuck with it, and if I was in the project from the beginning I had chose Calibur.Micro. Prism not even get updates. Caliburn is always lauching new versions.<br />\n",
    "PostedDate": "2014-01-13T10:33:45.117-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1165852",
    "ThreadId": "47338",
    "Html": "Hello DRairey1,\r<br />\n<br />\nI am afraid I don't completely understand the scenario where you are experiencing this issue. The items list that are shown in the grid, would they be the names of different <strong>Views</strong> to navigate to? \r<br />\nIt would be helpful if you describe us the behaviour you are trying to accomplish. Also, you could send us a code sample of your app so we could reproduce and debug the issue to provide you better support.\r<br />\n<br />\nPlease notice that this discussion thread is related to <strong>Prism v1</strong>, which is not available anymore (<em>The current version since February 2012 is <strong>Prism v4.1</strong></em>). Therefore, I would suggest you to open a new discussion in order to mantain and motivate a clean and ordered forum, unless your issue directly relates to the one discussed above.\r<br />\n<br />\nRegards,\r<br />\nGabriel Ostrowsky.\r<br />\n<a href=\"https://blogs.southworks.net/gostrowsky\" rel=\"nofollow\">https://blogs.southworks.net/gostrowsky</a><br />\n",
    "PostedDate": "2014-01-14T10:45:55.713-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1169248",
    "ThreadId": "47338",
    "Html": "<strong>GOstrowsky wrote:</strong><br />\n<blockquote>\nI am afraid I don't completely understand the scenario where you are experiencing this issue. The items list that are shown in the grid, would they be the names of different <strong>Views</strong> to navigate to? <br />\nIt would be helpful if you describe us the behaviour you are trying to accomplish. Also, you could send us a code sample of your app so we could reproduce and debug the issue to provide you better support.<br />\n</blockquote>\nI actually hit this again the other day (when I was working in a new codebase without my workaround). My scenario was this:<br />\n<ul>\n<li>There is a TextBox on a form</li>\n<li>The TextBox has a custom ContextMenu, with an extra MenuItem of the form &quot;Copy Special&quot;</li>\n<li>\nThe &quot;Copy Special&quot; command must be disabled unless the text displayed in the TextBox  (not just the bound value) is &quot;valid&quot;<br />\n</li>\n</ul>\nMy first attempt was to bind the Command property of the MenuItem to a DelegateCommand exposed by the VM, and bind the CommandParameter to the Text property of the TextBox. This <em>does not work</em> as the CanExecute handler doesn't get called by WPF when the CommandParameter changes; the MenuItem stays in the same state forever, depending on the validity of the text the first time the context menu is opened. \r<br />\n<br />\nThis wasn't <em>too</em> hard to work-around, as I only had one property to worry about, but imagine I was using the same Command &amp; CommandParameter binding in a DataTemplate.<br />\n<blockquote>\nPlease notice that this discussion thread is related to <strong>Prism v1</strong>, which is not available anymore (<em>The current version since February 2012 is <strong>Prism v4.1</strong></em>). Therefore, I would suggest you to open a new discussion in order to mantain and motivate a clean and ordered forum, unless your issue directly relates to the one discussed above.<br />\n</blockquote>\nAFAICT there would be no difference in behaviour between Prism v1 &amp; v4.1 here (although I've not tested). I can't see anything in the code that has changed. Starting a new thread seems a bit pointless, as that would actually hide the fact that I posted a workaround.<br />\n",
    "PostedDate": "2014-01-15T07:54:26.533-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1169278",
    "ThreadId": "47338",
    "Html": "GOstrowsky, thanks for your reply.<br />\n<br />\nThe issue is exactly the one posted by SWYTHAN.  I've got a relatively large, composite application that uses PRISM extensively, so it will take me a little time to remove just the ContextMenu part for a reproduction.  Since my post Monday, I've reworked the logic to use a View Model to generate the context menu but the original problem remains.  The code that creates the context menu looks like this:<br />\n<pre><code>                    &lt;Grid&gt;\n                        &lt;Grid.ContextMenu&gt;\n                            &lt;ContextMenu ItemsSource=&quot;{Binding ListViewMenuItems}&quot;/&gt;\n                        &lt;/Grid.ContextMenu&gt;\n                    &lt;/Grid&gt;</code></pre>\n\nThe DataTemplate used to create the menu items looks like this:<br />\n<pre><code>        &lt;Style.Resources&gt;\n            &lt;DataTemplate DataType=&quot;{x:Type local:MenuItemViewModel}&quot;&gt;\n                &lt;MenuItem Header=&quot;{Binding Header}&quot;\n                          Icon=&quot;{Binding Icon}&quot;\n                          CommandParameter=&quot;{Binding CommandParameter}&quot;\n                          Command=&quot;{Binding Command}&quot;/&gt;\n            &lt;/DataTemplate&gt;\n        &lt;/Style.Resources&gt;</code></pre>\n\nand, finally, the View Model for the menu items looks like this:<br />\n<pre><code>    public class MenuItemViewModel : NotificationObject\n    {\n        private Object headerField;\n        private Object iconField;\n        private ICommand commandField;\n        private Object commandParameterField;\n\n        public Object Header\n        {\n            get\n            {\n                return this.headerField;\n            }\n            set\n            {\n                if (this.headerField != value)\n                {\n                    this.headerField = value;\n                    this.RaisePropertyChanged(&quot;Header&quot;);\n                }\n            }\n        }\n\n        public Object Icon\n        {\n            get\n            {\n                return this.iconField;\n            }\n            set\n            {\n                if (this.iconField != value)\n                {\n                    this.iconField = value;\n                    this.RaisePropertyChanged(&quot;Icon&quot;);\n                }\n            }\n        }\n\n        public ICommand Command\n        {\n            get\n            {\n                return this.commandField;\n            }\n            set\n            {\n                if (this.commandField != value)\n                {\n                    this.commandField = value;\n                    this.RaisePropertyChanged(&quot;Command&quot;);\n                }\n            }\n        }\n\n        public Object CommandParameter\n        {\n            get\n            {\n                return this.commandParameterField;\n            }\n            set\n            {\n                if (this.commandParameterField != value)\n                {\n                    this.commandParameterField = value;\n                    this.RaisePropertyChanged(&quot;CommandParameter&quot;);\n                }\n            }\n        }\n    }</code></pre>\n\nAnd the implementation of the MenuItemViewModel property looks like like this:<br />\n<pre><code>        public override ObservableCollection&lt;Object&gt; ListViewMenuItems\n        {\n            get\n            {\n                var list = new ObservableCollection&lt;Object&gt;();\n                list.Add(new MenuItemViewModel\n                {\n                    Header = &quot;Delete&quot;,\n                    Command = GlobalCommands.Delete,\n                    CommandParameter = this\n                });\n                return list;\n            }\n        }</code></pre>\n\nNote that the delete command is a CompositeCommand and the CommandParameter is set to the ViewModel that I want to be passed to the command handler to determine if it can be deleted.  The CommandParameter will always be set and will always point to a valid view model.<br />\n<br />\nThe first time, and then randomly after the first time, the DelegateCommand CanExecute handler gets a null when it is called:<br />\n<pre><code>            this.deleteCommandField = new DelegateCommand&lt;IExplorerItem&gt;(this.DeleteItem, this.CanDeleteItem);\n            GlobalCommands.Delete.RegisterCommand(this.deleteCommandField);</code></pre>\n\n<pre><code>        private Boolean CanDeleteItem(IExplorerItem explorerItem)\n        {\n            CustomerNode customerNode = explorerItem as CustomerNode;\n            if (customerNode != null)\n            {\n                return customerNode.Children.Count == 0;\n            }\n            return false;\n        }</code></pre>\n\n",
    "PostedDate": "2014-01-15T08:03:48.837-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1174216",
    "ThreadId": "47338",
    "Html": "Hi everybody,\r<br />\n<br />\nThe main issue behind the problem being discussed here is that the command parameter is not part of the <strong>Command</strong> implementation itself. As it can be seen, when you usually set the <strong>CommandParameter</strong> binding, you are doing it in the <strong>Button</strong> (or the corresponding UI element) not in the command. Also, the command does not have access to the parameter, it only recieves it when the <strong>Execute</strong> and <strong>CanExecute</strong> parameters are invoked. Therefore, the command is not aware of when the parameter is changed.\r<br />\n<br />\nTo check the state of the command the corresponding elements need to re-query the command by executing the <strong>CanExecute</strong> method with the command parameter. This is done automatically when the <strong>CanExecuteChanged</strong> event is raised, but as mentioned above, the command is not aware of changes in the command parameter and cannot raise the event by its own. It needs for <strong><em>something else</em></strong> to raise it.\r<br />\n<br />\nRaising the <strong>CanExecutedChanged</strong> event in a <strong>DelegateCommand</strong> can be done simply by invoking the <strong>RaiseCanExecuteChanged</strong> method. This method should be called manually each time the command parameter is changed. If the command parameter is changed in the view model, you can invoke this method after changing it. In case you want to update the state of a <strong>CompositeCommand</strong> the aforementioned method is not available, but invoking it in any of its child commands should raise the event in the composite one. If the command parameter is changed by sources outside the view model or by elements of the view, you could react to those events by using interactions.\r<br />\n<br />\nFor example, in the following code snippet the command parameter is the text of the TextBox. Each time the text is changed the <strong>RaiseCanExecuteChanged</strong> is invoked.<br />\n<pre><code>    &lt;StackPanel&gt;\n        &lt;TextBox Name=&quot;TextBox&quot;&gt;\n            &lt;i:Interaction.Triggers&gt;\n                &lt;i:EventTrigger EventName=&quot;TextChanged&quot; SourceName=&quot;TextBox&quot;&gt;\n                    &lt;ie:CallMethodAction MethodName=&quot;RaiseCanExecuteChanged&quot; TargetObject=&quot;{Binding Command, ElementName=GreenButton}&quot; /&gt;\n                &lt;/i:EventTrigger&gt;\n            &lt;/i:Interaction.Triggers&gt;\n            \n        &lt;/TextBox&gt;\n        &lt;TextBlock TextWrapping=&quot;Wrap&quot;&gt;This button can be executed only when the text above is equal to 'Green'.&lt;/TextBlock&gt;\n        &lt;Button Name=&quot;GreenButton&quot; Command=&quot;{Binding GreenCommand}&quot; CommandParameter=&quot;{Binding Text, ElementName=TextBox}&quot; &gt;\n            Green Button\n        &lt;/Button&gt;\n    &lt;/StackPanel&gt;</code></pre>\n\nSomething I want to point out is that, as far as I know, there is currently no active work item in the issue tracker section regarding this. Usually, the team takes the issues / suggestions from there, chose the ones with the most votes and analyze them to see if it make sense to address those work items in future releases of the library.\r<br />\n<br />\nIf you are interesting in changing the current behavior of the <strong>DelegateCommand</strong> / <strong>CompositeCommand</strong> classes, please create a work item in the issue tracker section explaining your scenario, and the possible changes you might want to add to the library.\r<br />\n<br />\nI hope this helps,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2014-01-17T09:04:48.18-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1174861",
    "ThreadId": "47338",
    "Html": "Damian,<br />\n<br />\nThanks for a description of the root of the problem.  I've used .NET Reflector to dig a little further.  This root of the issue is the MenuItem (or Button) control implementation.  The 'CanExecute' on the ICommand interface is only called when the Command is set.  In spite of other posts, I've not found that the order of the Command and CommandParameter in the XAML makes a difference (if it does, it's a random difference at best).<br />\n<br />\nThe problem with your suggestion is that CompositeCommands are built for composite applications.  The menu item that invokes the CompositeCommand (e.g. 'Save All') may not reside in the module where the 'Save' DelegateCommand is implemented and where the 'RaiseCanExecuteChanged()' method is found.  So how do I force the 'Save All' command to re-evaluate after the initial binding if I don't have access to the DelegateCommand (because it's in a dynamically loaded module)?<br />\n",
    "PostedDate": "2014-01-17T13:01:17.46-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1184906",
    "ThreadId": "47338",
    "Html": "Hi DRAirey1,\r<br />\n<br />\nOne possible approach you could achieve is by using <strong>EventAggregator</strong> for communication between <strong>CompositeCommand</strong> and every corresponding <strong>ViewModelÂ´s DelegateCommand</strong>. This way, you would publish a <strong>Save</strong> event for example, from the <strong>CompositeCommand</strong>, and each of the related <strong>ViewModels</strong> would subscribe to it in order to handle the event. \r<br />\n<br />\nTherefore, each <strong><em>eventHandler</em></strong> would call the <strong><em>RaiseCanExecuteChanged()</em></strong> and the condition would get reevaluated:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">class</span> ViewModel()\n{\n     ...\n     SaveEvent saveEvent = eventAggregator.GetEvent&lt;SaveEvent&gt;();\n     saveEvent.subscribe(SaveEventHandler, ThreadOption.UIThread);\n}\n\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">void</span> SaveEventHandler()\n{\n      SaveCommand.RaiseCanExecuteChanged();\n}\r\n</pre></div>I hope this helps, \r<br />\nRegards.\r<br />\n<br />\nGabriel Ostrowsky\r<br />\n<a href=\"https://blogs.southworks.net/gostrowsky\" rel=\"nofollow\">https://blogs.southworks.net/gostrowsky</a><br />\n",
    "PostedDate": "2014-01-20T09:32:50.68-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]