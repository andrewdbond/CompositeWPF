[
  {
    "Id": "97130",
    "ThreadId": "29157",
    "Html": "This is my first day with PRISM and I'm really impressed (and somewhat overwhelmed)! One thing bugged me, though. When I look at theÂ code, I see the modules &quot;looking in&quot; to the shell to position themselves:<br>\r\n<br>\r\n<span style=\"font-size:10px\">\r\n<p>Find all &quot;MainRegion&quot;, Subfolders, Find Results 1, &quot;Entire Solution&quot;</p>\r\n<p>C:\\OSI\\Lab\\Visual Studio 2008\\Downloaded\\Prism\\2008-05-29Drop\\Source\\QuickStarts\\Modularity\\ConfigurationModularity\\ConfigurationModularity\\Shell.xaml(6): &lt;ItemsControl Name=&quot;MainRegion&quot; prism:RegionManager.RegionName=&quot;MainRegion&quot; /&gt;</p>\r\n<p>C:\\OSI\\Lab\\Visual Studio 2008\\Downloaded\\Prism\\2008-05-29Drop\\Source\\QuickStarts\\Modularity\\ConfigurationModularity\\ModuleA\\ModuleA.cs(33): _regionManager.GetRegion(&quot;MainRegion&quot;).Add(new DefaultViewA());</p>\r\n<p>C:\\OSI\\Lab\\Visual Studio 2008\\Downloaded\\Prism\\2008-05-29Drop\\Source\\QuickStarts\\Modularity\\ConfigurationModularity\\ModuleB\\ModuleB.cs(35): _regionManager.GetRegion(&quot;MainRegion&quot;).Add(_defaultViewB);</p>\r\n<p>C:\\OSI\\Lab\\Visual Studio 2008\\Downloaded\\Prism\\2008-05-29Drop\\Source\\QuickStarts\\Modularity\\ConfigurationModularity\\ModuleC\\ModuleC.cs(33): _regionManager.GetRegion(&quot;MainRegion&quot;).Add(new DefaultViewC());</p>\r\n<p>C:\\OSI\\Lab\\Visual Studio 2008\\Downloaded\\Prism\\2008-05-29Drop\\Source\\QuickStarts\\Modularity\\ConfigurationModularity\\ModuleD\\ModuleD.cs(33): _regionManager.GetRegion(&quot;MainRegion&quot;).Add(new DefaultViewD());</p>\r\n<p>C:\\OSI\\Lab\\Visual Studio 2008\\Downloaded\\Prism\\2008-05-29Drop\\Source\\Prism\\Prism.Tests\\Regions\\RegionManagerFixture.cs(38): regionManager.Register(&quot;MainRegion&quot;, region1);</p>\r\n<p>C:\\OSI\\Lab\\Visual Studio 2008\\Downloaded\\Prism\\2008-05-29Drop\\Source\\Prism\\Prism.Tests\\Regions\\RegionManagerFixture.cs(40): IRegion region2 = regionManager.GetRegion(&quot;MainRegion&quot;);</p>\r\n<p>Matching lines: 7 Matching files: 6 Total files searched: 143<br>\r\n<br>\r\n<span style=\"font-size:14px\">Maybe I'm being a moron and misunderstanding things, but this doesn't seem good. Seems like modules should have no knowledge of the shell. Someone please help me understand!<br>\r\n</span><br>\r\n<span style=\"font-size:14px\">Oh, I'm also interested in the PRISM road map. I saw a couple of posts about that today. I'll follow those posts for any updates. <br>\r\n<br>\r\nThanks!</span></p>\r\n</span>\r\n",
    "PostedDate": "2008-06-05T15:09:23.197-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "98486",
    "ThreadId": "29157",
    "Html": "I'm really surprised that nobody else seems bothered by this.&nbsp;If what I'm seeing is correct, it totally breaks encapsulation and decreases the possibility for reuse. For example, suppose I have a General Ledger Accounting module. Based on what I'm seeing, that module is to be hardcoded to register itself in &quot;MainRegion&quot;. That's nice, provided the shell has a &quot;MainRegion&quot;. What if I want to use this module in various applications, some of which have no &quot;MainRegion&quot;? This seems totally backwards to me, having the module look in to the hosting shell. Am I misunderstanding something, or is everyone so impressed with this technology (I admit it's impressive) that we're willing to overlook this big architectural no-no? Is this a temporary hack? Someone please explain!\r\n",
    "PostedDate": "2008-06-12T09:42:26.927-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "98494",
    "ThreadId": "29157",
    "Html": "Hi Idiot (man I feel bad saying that, lol)<br>\r\n<br>\r\nI think it's as you say, just a temporary thing, I don't think it was intended as a design model and purely as a RegionManager exmaple, even though most of the samples have a reference to the modules for each project.<br>\r\n<br>\r\nSome of the examples where the shell does not have knowledge of the modules are:<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp; Prism\\Source\\QuickStarts\\Modularity\\ConfigurationModularity<br>\r\n&nbsp;&nbsp;&nbsp; Prism\\Source\\QuickStarts\\Modularity\\DirectoryLookupModularity<br>\r\n<br>\r\nActually, now I look they're the only two. Take a look at my saple if you like (<a href=\"http://code.google.com/p/cwpfsamples/\">Composite WPF samples</a>), I never refer to the shell in modules and the shell will never refer to modules. Any interaction the modules need to perform with the shell they use services exposed as interfaces through the &quot;Infrastructure&quot; model. I think this is a pattern I'm inherent from CAB, but it's a good practice all the same.<br>\r\n<br>\r\nI hope the sample I have is simple enough and helps you out with how I've acheived the modularity concept.<br>\r\n<br>\r\n-Brett<br>\r\n",
    "PostedDate": "2008-06-12T10:04:42.367-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "98531",
    "ThreadId": "29157",
    "Html": "<br>\r\n<div style=\"border-right:medium none;padding-right:0.2em;border-top:#aaa 0.1em dotted;padding-left:0.2em;padding-bottom:0.2em;margin:1em 0em 2.5em 3em;border-left:medium none;padding-top:0.2em;border-bottom:#aaa 0.1em dotted;font-style:italic\"><br>\r\nID10T wrote:<br>\r\nI'm really surprised that nobody else seems bothered by this.&nbsp;If what I'm seeing is correct, it totally breaks encapsulation and decreases the possibility for reuse. For example, suppose I have a General Ledger Accounting module. Based on what I'm seeing, that module is to be hardcoded to register itself in &quot;MainRegion&quot;. That's nice, provided the shell has a &quot;MainRegion&quot;. What if I want to use this module in various applications, some of which have no &quot;MainRegion&quot;? This seems totally backwards to me, having the module look in to the hosting shell. Am I misunderstanding something, or is everyone so impressed with this technology (I admit it's impressive) that we're willing to overlook this big architectural no-no? Is this a temporary hack? Someone please explain! <br>\r\n<br>\r\n</div>\r\n<br>\r\nJust&nbsp; to keep the conversation going, because it is&nbsp;a good question. ( and to stir the pot a bit )<br>\r\n<br>\r\nWhere would you suggest the &quot;glue&quot; exist?&nbsp; Something has to understand what region to place a modules views into.&nbsp; You dont want to have to change the code in the shell to add a new module, so it cant go there.&nbsp; Would you want a &quot;mother of all controllers&quot; that knew about every module and where it should go?&nbsp; The module init&nbsp;seems to be the right place to me. The app has to have well known places for things to plug into.&nbsp;&nbsp;One is usually not building a generic app.&nbsp; The modules need to understand what they are pluggin into.&nbsp; The views should not know where they go, but I think that the module is where the glue should go.<br>\r\n<br>\r\nStrings like &quot;MainRegion&quot; are wrong IMO, but there have to be well known names or lookups that allow the module to plug views in.<br>\r\n<br>\r\n( good question, IMO )<br>\r\nPaul<br>\r\n<br>\r\n",
    "PostedDate": "2008-06-12T12:43:20.603-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "98536",
    "ThreadId": "29157",
    "Html": "Hi ID10T<br>\r\n<br>\r\nThis is one approach for UI Composition, that is the modules inject views into the shell. The modules themselves do not have direct knowledge of the shell. The region provides an abstraction that allows a module to grab a named area which it can inject into. This level of abstraction is similar to when one retrieves a type instance from an IOC&nbsp;container by a key. Encapsulation is not broken in that the module only knows the name, it does not have any other information about how the region is implemented or where it is ACTUALLY located. Regions can also be localized within the same module, in either case the name is the moniker for accessign it. <br>\r\n<br>\r\nIf there is a concern, you can easily further abstract the region through a custom service that accesses the region manager itself. So for example if you want your Order module to be reused in several applications, you can have a LayoutService that the Order Module calls instead of calling the region manager directly. You can also have a service that simply returns a region name based on configuration, and have the module call that service in order to figure out which region to use.&nbsp;<br>\r\n<br>\r\nFinally a third option, is to not have modules have any access to regions period. In this&nbsp;model you can have a service at the shell that queries the container for views based on an interface, and then displays them itself. If you look in our new Family Show spike (in our recent drop), we used a similar approach. Each module registers views that implement an interface. The shell queries the container based on this.\r\n",
    "PostedDate": "2008-06-12T13:02:50.403-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "98540",
    "ThreadId": "29157",
    "Html": "Good comments - this is the kind of feedback I was hoping to get. [UPDATE: I wrote this before I saw gblock's reply.]<br>\r\n<br>\r\nYes, if the shell has to place the modules then this violates the &quot;Open - Closed&quot; principle. But if the modules attach themselves to the shell by breaking encapsulation (e.g., looking for&nbsp;a &quot;Main Region&quot; to attach to), well, that's also bad. How about some sort of configurable mediator that softens the tie between the shell and the attaching modules? For example, the GLA module could be configured to attach to &quot;Main Region&quot; in application/shell A, but it could be configured to attach to &quot;External Modules&quot; region in application/shell B. That seems to be a better solution to me than relying on well known regions or magic strings, and it allows the GLA module to be reused. If others agree, perhaps this is something that can be baked into the PRISM framework so we all don't have to write our own...?<br>\r\n<br>\r\nBrett, thanks for the code. I was easily able to add a new module with AbstractDocument content; I like what you did. I did notice mention of RegionNames.ViewMenu in the WelcomeModule, though. I think that this mediator idea would eliminate the need for that.<br>\r\n<br>\r\nThanks guys. Maybe we'll get more discussion on this...\r\n",
    "PostedDate": "2008-06-12T13:10:40.57-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "98608",
    "ThreadId": "29157",
    "Html": "@ID10T<br>\r\n<br>\r\nNo worries, yeah I think I mentioned either in my svn commits or some comments in the code that I don't like regions and will try to avoid them at all costs. The only place where (I think) I've used the pattern was in the menu, oh that's right, I actually put the comment in the RegionNames file itself.<br>\r\n<br>\r\nMy idea would be to have a menu service where you register the menus instead of adding them, this was the service can control how the menu items are added and allow greater flexibility (position, what it must come before/after).<br>\r\n<br>\r\nService contracts are my flavour of choice, where both shell and modules know nothing about each other, both have a contract mechanism through the infrastructure project.<br>\r\n<br>\r\nI've not thought of module reuse through other programs even though I've taken mixed modules from different apps in CAB, but now that's made the old light bulb go on.<br>\r\n<br>\r\n-Brett<br>\r\n",
    "PostedDate": "2008-06-12T20:46:08.19-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]