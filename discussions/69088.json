[
  {
    "Id": "235073",
    "ThreadId": "69088",
    "Html": "<p>Hello,</p>\r\n<p>I am new to Prism and I'd like to know why the PRISM has by default some strange architectural limitations: when we are implementing a new module we should know where its views will appear (actual region names). It's seems to be a bit wrong. I want to build modular applications with some of independent modules which cann be shown in different places and can be reused by other teams in their projects. I think it would be nice if we can register regions with views somewhere in one place (for ex. in Shell project). So we can compose different applications based on the same modules as we like. No particular region names should be specified.</p>\r\n<p>Maybe I misunderstand something but that's my point of view for today.</p>\r\n<p>Please correct me if I am worng or give me a piece of advice how this problem could be solved using standard approaches.</p>\r\n<p>Thanks in advance.</p>\r\n<p>Best regards,</p>\r\n<p>Alexander Kalinovski.</p>",
    "PostedDate": "2009-09-16T03:16:39.88-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "236343",
    "ThreadId": "69088",
    "Html": "<p>Hi Alexander,</p>\r\n<p>Views are actually the reusable components, ideally they are encapsulated and can standalone.&nbsp;&nbsp; Event aggregation and shared ViewModels are methods of sharing state/data between views.&nbsp;&nbsp; Where there are numerous ways to manage your views one way that I use is to have a shell that has only a MainRegion.&nbsp;&nbsp;&nbsp;&nbsp;Each module&nbsp;holds a <strong>main view</strong> that serves as the template/layout/regions for various views&nbsp;the module&nbsp;will use - the module.initialize() routine is then responsible for populating the regions with the various views.</p>\r\n<p>The Module places&nbsp;its main view in the shell's MainRegion - the first view placed in the MainRegion will be the default view.&nbsp;&nbsp; The various module views can be activated which will bring them to the front.&nbsp;</p>\r\n<p>Another approach, from a recent forum message, would be to have your MainRegion have a leftRegion (treeview) and a rightRegion where the left region is a navigation treeview - as you click a node it loads the applicable modules main view into the right region.&nbsp;&nbsp; PRISMs flexibility gives you a lot of control over your layout.&nbsp;&nbsp;</p>\r\n<p>PRISM is very powerful and extensible - for example, I am creating a Multi-Targeting application using PRISM that allows me to use a single code base for Silverlight, WPF and WinForms (<a href=\"http://multitargeting.CodePlex.com\">http://multitargeting.CodePlex.com</a>).&nbsp;&nbsp; (shameless plug)</p>\r\n<p>TIP: If you understand the MVP and MVVM patterns as well as&nbsp;the concepts of Dependency Injection and Separation of Concerns&nbsp;the QuickStarts won't be such a steep learning curve; if you are not familiar with them, the time invested in doing&nbsp;so&nbsp;will help&nbsp;a great deal.&nbsp;&nbsp;</p>\r\n<p>If you have a specific layout in mind I trust there are many members in this forum that could provide you ideas/solutions to meeting them.</p>",
    "PostedDate": "2009-09-18T22:24:21.52-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "236908",
    "ThreadId": "69088",
    "Html": "<p id=7d12ecc0-86c0-012c-dcb8-12313b00e181>Hi Alexander,</p>\r\n<p id=7d130670-86c0-012c-dcb9-12313b00e181>One of the main concerns when developing composite application is the decoupling of functionality. Splitting an application in different <a href=\"http://msdn.microsoft.com/en-us/library/dd458911.aspx\">modules</a> which are not aware of each other is one of the main points of this kind of applications. Each module has its own views, which no one else can know of, as this would highly increase the coupling in your application.</p>\r\n<p id=7d132a70-86c0-012c-dcba-12313b00e181>Imagine Prism did provide a centralized place for <a href=\"http://msdn.microsoft.com/en-us/library/dd458944.aspx\">composing the UI</a> (View Injection and View Discovery sections are related in the article), such as the Shell project. Without a lot of analysis, this would require having a reference to each of the assemblies that contains the views (for example one per module) in your Shell. You would have control of every view in the application in a single place, which is typical for monolithic applications. If this was the case, the application would not be able to evolve independently, and every new view/functionality would require changing both the new/updated module and the components that manage the registering of views.</p>\r\n<p id=7d1362a0-86c0-012c-dcbb-12313b00e181>As all modules are do not know of the Shell, there has to be a way to locate a view at a particular place in the Shell. By making each module register its own views you are simply saying, &ldquo;hey, I do not care whether the module is loaded or not, the rest of the application should work either way&rdquo;. Also consider that it makes it easier to change the layout of your application or reuse views, simply changing the layout of the Shell/providing a new one will set up a whole new layout without having to change any of the modules (they care about the region name, not how it is placed in the Shell).</p>\r\n<p><a href=\"http://blogs.msdn.com/erwinvandervalk/\">Erwin van der Valk</a> talks about a similar subject in <a href=\"View.aspx?ThreadId=48654\">this post</a>.</p>\r\n<p id=7d13e650-86c0-012c-dcbd-12313b00e181>To sum up:</p>\r\n<ul>\r\n<li>You can change the layout of the Shell, or make your views appear in other Shells simply by having a Region Naming convention. </li>\r\n<li>You do not have to change any of the existing modules to have a new layout. </li>\r\n<li>Your modules evolve independently, and are easier to maintain are test.&nbsp; </li>\r\n</ul>\r\n<p id=7d141fc0-86c0-012c-dcbe-12313b00e181>There is a lot more information about this in the Prism documentation:</p>\r\n<ul>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/dd458868.aspx\">UI Composition</a> </li>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/dd490825.aspx\">Modularity</a> </li>\r\n</ul>\r\n<p id=7d148e50-86c0-012c-dcbf-12313b00e181>Please let me know if this helps.</p>\r\n<p id=7d151b20-86c0-012c-dcc0-12313b00e181>Damian Schenkelman    <br><a href=\"http://blogs.southworks.net/dschenkelman\">http://blogs.southworks.net/dschenkelman</a></p>",
    "PostedDate": "2009-09-21T08:10:03.527-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "629863",
    "ThreadId": "69088",
    "Html": "<p>Hi everyone,</p>\n<p>I think we all of us got it wrong somehow.</p>\n<p>Let me explain what wrong paths I followed by reading junk posts over the internet which all tells you \"do it like this do it like so\".</p>\n<ol>\n<li>I tried somehow to make my views not aware of shell regions, I wrote a custom view registry/manager system to specify which view goes in what region =&gt;&nbsp;WRONG !!! and this was my only agent who knew that. </li>\n<li>I tried to abstract the idea of view to be used in more that one application =&gt; WRONG !!!!!. I tried only to use User Controls (generic controls) and not use a specific type of controls (let say the Telerik controls) and put them into regions.Instead I  wrote my custom regions, region adapters etc. and even a&nbsp;generic navigation system&nbsp;(navigating without knowing the region, the view manager resolved that).&nbsp;I just ended up with very limited&nbsp;capabilities and many lines of code written for nothing.&nbsp;My user controls  (views)&nbsp;were added to regions and adapters were responsible to wrap&nbsp;them in containers lets say RadWindows, so I ended up not been able to use all the features of the RadWindow, an I also needed to write attached&nbsp;(to views) properties to bee able to control  let's say the Title of the RadWindow &nbsp;=&gt; ALL VERRY VERRY WRONG !!!! (too much noise for nothing). </li>\n<li>And many many more WRONG things which I will tell if someone will ask. </li>\n</ol>\n<p>So in conclusion I learn a lot but important is I learned what is WRONG (from my point of view).</p>\n<p>Now I want to tell you about my way of doing things with Prism.</p>\n<ol>\n<li>In a prism application the only generic things are the Model (100% generic) and&nbsp;the View Model (generic in some degree&nbsp;and reusable in some degree.), the views are the specific implementation of the application and you can't reuse them in other applications.You  could&nbsp;do it by abstracting the idea of view into a generic layer&nbsp;of objects&nbsp;and publish&nbsp;them from the modules, good luck I will not follow that path because I know I have to write 100000000000000 lines of code (adapters/generic layer of objects etc...) just  to end up with a system which is generic/reusable (nice in theory, maybe I can use it in the future in my coffee maker :))) but also with limited&nbsp;capabilities. </li>\n<li>NEVER BUT NEVER put a View Model in the same assembly where you put your Views (However you can but you lose the view model's reuse ability or let say you pollute the view model's assembly with views).There are always 3 assemblies. 1.&nbsp;The module assembly&nbsp;which contains the module controller and the views 2. The View Model Assembly&nbsp;&nbsp; 3. The View Model's infrastructure assembly. </li>\n<li>NEVER BUT NEVER wire up interface from the view model (start windows, put views in regions etc), The idea of interaction service or interaction request is so wrong if used from the view model (even is is abstract made with interfaces) and it goes against  of what o view model is (a view model is just an adapter of the model&nbsp;data to be used better in the view).If we wire up interface from the view model then we know about the view layer&nbsp;in the view model (so that violates the following MVVM pattern rule View  -&gt; knows about View Model -&gt; knows about Model) </li>\n<li>Commands ca be used in the view model but again not to wire up interface but to do something with the model (let's say save some data). If you want to wire up interface you can declare a command at the view level and use it there.<strong>MVVM is a TOP -&gt;  DOWN 3 level architecture</strong>.A level know about it's underneath level and it's peers.<strong>I never understood ﻿﻿why for God sake they put the view model in the same assembly with the view (I think people who implemented prism got it wrong at that moment)</strong>.  Commands in the View Model are just methods of the view model&nbsp;with one additional feature availability (CanExecute() .method) </li>\n<li>You can write code in the view's code behind. They say only the view model instantiation is permitted etc ... why ?I an ideal world where you can do everything from xaml why not but till then if it becomes hard to write the view's behavior in xaml&nbsp;you can  just use the code behind. </li>\n<li>Add many many more if someone asks me. </li>\n</ol>\n<p>Hope this&nbsp;is right&nbsp;or I&nbsp;got it all wrong :)).</p>\n<p>Please let me know if this helps someone and sorry for my bad English (I learned it from movies :), not my native language)</p>\n<p>Axente Adrian</p>\n<p><a title=\"Title\" href=\"mailto:adrianaxente@yahoo.com\" target=\"_blank\">adrianaxente@yahoo.com</a></p>",
    "PostedDate": "2011-06-19T18:12:43.223-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]