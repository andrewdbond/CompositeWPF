[
  {
    "Id": "869771",
    "ThreadId": "370754",
    "Html": "\r\n<p>I've been looking at validation with Prism for WPF applications. I'm new to validation in WPF in general, but have been looking through various examples and my books. Here's my thoughts.</p>\r\n<p>My WPF book shows data binding validation by implementing your own <strong>ValidationRules</strong>. I really like this approach because it would allow me to simply implement reusable validation logic rules (e.g. StringIsNotEmpty, IsDirectoryPath) and specify\r\n them at the time of binding in the XAML code. Once I wrote my ValidationRules, I would not need any C# code to implement most validation logic. Awesome.</p>\r\n<p>However, if you think of this in context of MVVM with Prism, this solution is not really acceptable. It relies on the view (UI) to implement the validation logic. Even if you implemented validation logic in the accept command for a form in your ViewModel,\r\n there doesn't seem to be a good way to connect the two together, and you<strong> would be doing the work for validation twice for no reason.</strong></p>\r\n<p>Of course, the Prism book says that you should be using <strong>IDataErrorInfo\r\n</strong>and there is example of it in the <strong>Commanding Quickstart</strong>. That example is nicely done. However, the validation logic is hard coded in the ViewModel. This requires me to write code and perhaps leaves me more prone to errors. Sure, I\r\n could implement my own static validation functions that are reusable, but it still doesn't seem as&nbsp;eloquent&nbsp;as adding ValidationRules in XAML. Also, similar to the difference between INotifyPropertyChanged and NotifcationObject, hard coded validation\r\n on properties breaks after refactoring code changes.</p>\r\n<p>I guess I'm wondering what the best approach is with validating using IDataErrorInfo that I can reuse validation logic code. Create my own static validation utility class? I just don't want to reinvent the wheel every time I need a certain validation logic.\r\n I want to create the rules once in a common project and re-use it everywhere. I'm sure I can do the static classes, or similar. But, is there a better solution?</p>\r\n<p><strong><br>\r\n</strong></p>\r\n",
    "PostedDate": "2012-07-16T08:55:13.81-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "870084",
    "ThreadId": "370754",
    "Html": "<p>Hi Alan,</p>\r\n<p>Based on my understanding, there is not a \"better\" approach, in my opinion which approach you should use would depend mostly on your personal preferences and the requirements of your scenario.</p>\r\n<p>What is more, you could have both <strong>ValidationRules </strong>to validate things like formatting, empty fields, etc, and validation in the <strong>view model / model</strong> through the&nbsp; <strong>IDataErrorInfo</strong> interface to validate business related information. For example, in a <strong>TextBox </strong>that binds to a numeric type property, you could validate the text to check if it's a number though a <strong>ValidationRule </strong>and then validate if the value is in the correct range in the view model.</p>\r\n<p>Regarding this, I believe you could find the following articles useful:</p>\r\n<ul>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/system.windows.controls.dataerrorvalidationrule.aspx\">DataErrorValidationRule </a>- A <strong>ValidationRule </strong>that reacts to errors raised through the <strong>IDataErrorInfo </strong>interface.</li>\r\n<li><a href=\"http://weblogs.asp.net/marianor/archive/2009/04/17/wpf-validation-with-attributes-and-idataerrorinfo-interface-in-mvvm.aspx\">WPF Validation with Attributes and IDataErrorInfo interface in MVVM</a> - A blog post proposing an approach to simplify the validation in the view model / model side through attributes.</li>\r\n</ul>\r\n<p>I hope you find this useful,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-07-16T12:45:07.343-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "870900",
    "ThreadId": "370754",
    "Html": "\r\n<p>Thanks for the response. What you said about the ability to split validation between the view and view model makes sense. If the View is bound to an integer, then there is no way that it will accidentally get a string value assigned. I assume the default&nbsp;behavior&nbsp;is\r\n the ExceptionValidationRule with an integer parse exception string. If I desired to provide a better message, I could add custom ValidationRules to the binding.</p>\r\n<p>The Attributes are a nice example of another way in which validation can be done&nbsp;declaratively. But, I think for my preferences, I will stick to implementing my own ValidatingViewModel base class which implements IDataErrorInfo. I have added a GetPropertyName(Expression&lt;Func&lt;T&gt;&gt;\r\n property) method to it as a helper method to avoid magic strings using lambda expressions similar to NotificationObject versus INotifyPropertyChanged. I have also added some basic logic to it similar to the Commanding Quickstart's implementation of the OrderPresentationModel.</p>\r\n",
    "PostedDate": "2012-07-17T09:41:17.937-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]