[
  {
    "Id": "925874",
    "ThreadId": "399130",
    "Html": "\r\n<p>Hi,</p>\r\n<p><strong>Goal</strong></p>\r\n<p>If a view has already been injected (eg Customer = 15) then make that view visible instead of injecting a new view.</p>\r\n<p><strong>Concern</strong></p>\r\n<p>We're using event driven design with view injection only. &nbsp;No <strong>INavigation\r\n</strong>patterns are being used.</p>\r\n<p><strong>Example</strong></p>\r\n<p>The Shell has a tab control region for main workspaces.</p>\r\n<p>There is a search view injected into the shell.</p>\r\n<p>User types in a keyword, presses search, this raises a Search event.</p>\r\n<p>The search controller subscribes to that event, injects a search results workspace which shows as a new tab in the shell.</p>\r\n<p>Other modules subscribe to events from the search process and if they find a match they inject their search results into the search workspace region (using scoped regions).</p>\r\n<p>Example: customer module matched the customer name on a keyword search and injects a results view into the search workspace (tab in the shell's main workspace region).</p>\r\n<p>The customer search results view has a button that when clicked raises the event CustomerSearchResultEditButtonClicked(payload = customerID 15).</p>\r\n<p>The customer controller subscribes to that event and injects a new customer edit view into the shell's main workspace, which shows up as a new tab.</p>\r\n<p>Up to this point everything is working as expected.</p>\r\n<p>If the user goes back to the search results tab, click's the same customer search result button again I want to make the existing customer view active (make the tab active) instead of injecting a duplicate of the customer edit view.</p>\r\n<p>I've looked at some navigation methods but being fully event driven the event raised has no knowledge of what region the target view will end up in. &nbsp;That is the responsibility of the controller. &nbsp;The event only cares about what happened (user\r\n clicked a button), not what's going to happen. &nbsp;The navigation methods seem to need to have some knowledge about what's going to happen and where.</p>\r\n<p>At this point I'm experimenting with IActiveAware and managing a list of injected views in the controller (iterate the list, find an existing view that matches the customer ID and activate that view somehow, if it doesn't exist then inject a new view).</p>\r\n<p>Once I get something working my next challenge is to get it working for deeply nested views.</p>\r\n<p>For example:</p>\r\n<ul>\r\n<li>Customer Workspace contains an edit view and a CustomerInfo region as a tab control\r\n</li><li>Many modules inject their own view into the CustomerInfo region as new tabs (eg. Orders, History, Contact info etc)\r\n</li><li>In each of those injected views they may contain a list of records. </li><li>Clicking on a single record may open up a secondary item with nested views and other lists. &nbsp;eg. Click on an Order, that injects Order Details into the Orders view, expanding the Order Details shows a list of order detail items. &nbsp;Clicking a single\r\n order detail item would inject the order detail edit view. &nbsp;Think of it like being able to drill down many levels into more and more detail.\r\n</li></ul>\r\n<p>Then, perhaps from the search results view I want to link to a single order details record.</p>\r\n<p>I'd like to see the customer workspace injected, the orders list injected and populated, the parent order click simulated, the order details view and list injected and the correct order detail record clicked to bring up its edit view.</p>\r\n<p>Any thoughts or suggestions?</p>\r\n",
    "PostedDate": "2012-10-12T09:11:21.243-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "925966",
    "ThreadId": "399130",
    "Html": "<p>Hi,</p>\r\n<p>Based on my understanding of your scenario and the architecture you were using in your previous uploaded samples, where the controllers injected the corresponding views by raising events, I believe leaving the responsibility to activate the already existent views or injecting a new one if not present to the corresponding controllers seems like a reasonable approach.</p>\r\n<p>In my opinion, for the views in the inner regions you could follow a similar approach like the one you mentioned for the customer views, from example when your customer controller injects or activate an specific customer view, you could raise another custom event for each type of the inner views required based on the search results. This way you could have a custom controller for each of those types that could handle these events. And based on the payload passed (corresponding scoped region manager and for example an orderID in which case this would be used by the orders controller), similarly like above, in the handler of the event you could iterate the existing views&nbsp; and decide to activate the corresponding view or inject a new one. Following this you should be able to use the sane approach for the different levels of your composite views.</p>\r\n<p>Take into account that how to implement this will depend mostly on your personal preferences and the requirements of your scenario, In my opinion to achieve this kind of scenarios you will need to design a highly structured architecture to support the deeper regions, which could be based on the one you used in your samples.<br /><br />Best regards,</p>\r\n<p>Agustin Adami<a href=\"http://blogs.southworks.net/aadami\"><br /> http://blogs.southworks.net/aadami</a></p>",
    "PostedDate": "2012-10-12T12:20:13.78-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "928314",
    "ThreadId": "399130",
    "Html": "<p>Thanks for that info.</p>\r\n<p>I've been experimenting with some things and want to clarify.</p>\r\n<p>It appears I will have to handle and implement code to activate all views from the nested view up through all parent views ultimately arriving at the top level view to make the nested view visible.</p>\r\n<p>And, that there is nothing \"built-in\" to Prism that will do that for me?</p>\r\n<p>For example:</p>\r\n<ul>\r\n<li>In my shell I have top level views as tabs, I can activate top level views easily to force them to become the visible tab (active) if they are not currently visible</li>\r\n<li>If I have a nested view inside one of these top level tabs but the top level tab is not currently visible (active), I have to activate every view from the nested view upwards ending with the top level tab view. &nbsp;If I don't, calling region.Activate(view) will succeed, but will not do anything to cascade activating parent views to the point they are actually visible.</li>\r\n</ul>\r\n<p>Assuming I'm always starting from the nested view (it starts by receiving an event) and need to activate up the parent tree, I'll need a re-usable pattern so it will work in any injected/nested view combination. &nbsp;It simply needs to continually activate parent views until there are no more to activate. &nbsp;That should ensure the nested view will be visible to the user no matter where the request to view it came from.</p>\r\n<p>Does that summarize it the way you are thinking it needs to work given my situation?</p>",
    "PostedDate": "2012-10-17T13:22:21.8-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "929021",
    "ThreadId": "399130",
    "Html": "<p>Hi,</p>\r\n<p>As far as I know, <strong>Prism </strong>does not provide functionality to activate the parent views when an inner view is activated. In fact, with <strong>Regions</strong>, <strong>Prism </strong>aims to compose the user interface without needing the views to know each other. Hence, <strong>Prism </strong>does not even provide any functionality to obtain a view's parent.</p>\r\n<p>Based on this, <em><strong>climbing up</strong></em> the visual tree and activating corresponding views would require to implement your own custom functionality not only to activate the views; but to find them, their <strong>Regions </strong>and their <strong>RegionsManagers </strong>too. Therefore, I believe it would be simpler to activate the top view first and then start activating the inner views up to the required one. In order to do this, you would need to have the information to know which views you need to activate. Then, for example, you could activate the top view and check the views of its <strong>Regions </strong>to check if it contains a view that needs to be activated. This inner view that was activated could repeat the process with its inner views and so on.</p>\r\n<p>On the other hand, if you want to have a re-usable functionality that could be used to activate directly an inner view and their parents, regardless of the cost of implementing this functionality, I believe you could use an approach like the following one:</p>\r\n<p>First you will need some infrastructure in your views / view models to support this kind of scenario. For this example, we will use the <strong>ViewModelBase </strong>class that I saw in one of your previous samples which defines a <strong>BaseRegionManager </strong>property where the scoped <strong>RegionManager </strong>is stored. Also, we will define an interface (lets call it <strong>IActivateVisualTree</strong>) that defines an <strong>ActivateVisualTree </strong>method. This interface could be implemented in your views.</p>\r\n<p>Second, you will need a service in charge of activating the view and its corresponding tree. This service could be either a simple static class or a <em><strong>shared service</strong></em> registered in the container. How to implement it would depend mostly of your personal preferences. This service could for example expose a single static method that could then be invoked when needed to do the job. In this example, it will be invoked inside the implementation of the <strong>ActivateVisualTree </strong>method that we defined before for each view:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\">// Some view 's code...</span>\r\nActivateVisualTree()\r\n{\r\n    <span style=\"color: green;\">// The service...</span>\r\n    VisualTreeActivator.Activate(<span style=\"color: blue;\">this</span>);\r\n}\r\n</pre>\r\n</div>\r\nHence, when you need to activate an specific view, you could cast the view to an <strong>IActivateVisualTree </strong>object and invoke the <strong>ActivateVisualTree </strong>method. By doing this, neither the code that requests the view to be activated or the view itself need to know how to activate the visual tree; that will be the responsibility of the service.</p>\r\n<p>The complex part here is the implementation of the aforementioned service. Based on my understanding the service will need to do something similar to the following steps to activate the visual tree involved:</p>\r\n<ol>\r\n<li>Taking the view passed as a parameter, start <em><strong>climbing up</strong></em> the visual tree until you find a element with a <strong>DataContext </strong>of type <strong>ViewModelBase</strong>. Then, obtain the <strong>RegionManager </strong>contained in the <strong>BaseRegionManager </strong>property. This should be the <strong>RegionManager </strong>that contains the <strong>Region </strong>where the view is injected. (I believe you could find the code in the <strong>RegionManagerRegistrationBehavior</strong> class provided by <strong>Prism </strong>useful to implement your own logic to <em><strong>climb up</strong></em> the visual tree.)</li>\r\n<li>Again, taking the view as a base, start <em><strong>climbing up</strong></em> the visual tree until you find an element that has a <strong>RegionManager.RegionNameProperty</strong> attached to it. You can use the <strong>GetRegionName </strong>static method of the <strong>RegionManager </strong>class to check for the aforementioned property. Once found, save the <strong>Region</strong>'s name. It should be the name of the <strong>Region </strong>where the view is injected.</li>\r\n<li>Obtain the <strong>Region </strong>from the <strong>RegionManager </strong>found in step 1. To do so, use the <strong>Region</strong>'s name obtained in step 2. With this you should have the <strong>Region</strong> where the view is injected.</li>\r\n<li>Activate the view using the <strong>Activate </strong>method of the <strong>Region </strong>obtained in step 3.</li>\r\n<li>Finally, in order to activate the parent views, <em><strong>climb up</strong></em> the visual tree again until you find an element that implements our <strong>IActivateVisualTree </strong>interface. Once found, stop <em><strong>climbing </strong></em>and invoke the <strong>ActivateVisualTree </strong>method of this element.</li>\r\n</ol>\r\n<p>So, when you need to activate an specific view and their parents, you would only need to invoke its <strong>ActivateViewTree </strong>method. This method consumes the service that will activate the view and invoke the <strong>ActivateVisualTree </strong>method on the parent view, activating all the views \"recursively\" until no parent that implements the <strong>IActivateVisualTree </strong>interface is found.</p>\r\n<p>Take into account that we haven't tested this approach, and that it's only one possible approach to implement the functionality you are mentioning. Again, how to implement this will depend mostly of your personal preferences and the requirements of your scenario.</p>\r\n<p>Finally, I would like to mention that this approach might not be useful if you have <strong>DataTemplates </strong>in your visual tree, as a <strong>DataTemplate </strong>is not a <strong>FrameworkElement </strong>and it has no <strong>Parent </strong>property you can use to <em><strong>climb up</strong></em>.</p>\r\n<p>I hope this helps,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-10-18T13:49:21.147-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]