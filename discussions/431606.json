[
  {
    "Id": "994950",
    "ThreadId": "431606",
    "Html": "OK,<br />\nLets say this is my  ModuleA.cs:<br />\n<pre><code>    public class MyModuleA : IModule\n    {\n        private readonly IUnityContainer _container;\n        private readonly IRegionManager _regionManager;\n\n        public MyModuleA (IUnityContainer container, IRegionManager regionManager)\n        {\n            _container = container;\n            _regionManager = regionManager;\n        }\n\n        public void Initialize()\n        {\n            // Register ViewModels\n            _container.RegisterType&lt;MyModuleAViewModel&gt;();\n\n            //Register Views\n            _container.RegisterType&lt;Object, MyModuleARibbonTab&gt;();\n            _container.RegisterType&lt;Object, MyModuleAView&gt;();\n            _regionManager.RegisterViewWithRegion(&quot;RibbonRegion&quot;, ResolveRibbonTabView);\n            _regionManager.RegisterViewWithRegion(&quot;MainRegion&quot;, ResolveMainView);\n        }\n\n        private object ResolveRibbonTabView()\n        {\n            return _container.Resolve&lt;MyModuleARibbonTab&gt;();\n        }\n\n        private object ResolveMainView()\n        {\n            return _container.Resolve&lt;MyModuleAView&gt;();\n        }\n    }</code></pre>\n\nand this is my ModuleAViewModel.cs:<br />\n<pre><code>    public class MyModuleAViewModel : NotificationObject\n    {\n        public MyModuleAViewModel()\n        {\n            SaveCommand = new DelegateCommand(Save, CanSave);\n        }\n\n\n        private string _message = &quot;Hello from My Module!&quot;;\n\n        public string Message\n        {\n            get { return _message; }\n            set\n            {\n                if (_message != value)\n                {\n                    _message = value;\n                    RaisePropertyChanged(() =&gt; Message);\n                }\n            }\n        }\n\n        public static ICommand SaveCommand { get; private set; }\n        \n        public void Save()\n        {\n            this.Message = &quot;Save Command Executed.&quot;;\n        }\n\n        public bool CanSave()\n        {\n            return true;\n        }\n    }</code></pre>\n\nI also have a View in my module, named MyModuleAView.xaml:<br />\n<pre><code>&lt;TabItem x:Class=&quot;PrismApp.Modules.MyModule.Views.MyModuleAView&quot;\n             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;\n             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;\n             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; \n             xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; \n             mc:Ignorable=&quot;d&quot; Header=&quot;My First Module&quot;\n             xmlns:vm=&quot;clr-namespace:PrismApp.Modules.MyModuleA.ViewModels&quot;\n             d:DesignHeight=&quot;300&quot; d:DesignWidth=&quot;300&quot; IsSelected=&quot;True&quot;&gt;\n    &lt;Grid&gt;\n        &lt;TextBlock VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;{Binding Path=Message, Mode=TwoWay}&quot;&gt;&lt;/TextBlock&gt;\n        &lt;Button VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Content=&quot;Save&quot; Command=&quot;{x:Static vm:MyModuleAViewModel.SaveCommand}&quot;&gt;&lt;/Button&gt;\n    &lt;/Grid&gt;\n&lt;/TabItem&gt;</code></pre>\n\nand code behind:<br />\n<pre><code>    public partial class MyModuleAView : TabItem\n    {\n        public MyModuleAView(MyModuleAViewModel viewModel)\n        {\n            InitializeComponent();\n            this.Loaded += (obj, e) =&gt; this.DataContext = viewModel;\n        }\n    }</code></pre>\n\nAnd finally, this is my RibbonTab:<br />\n<pre><code>&lt;ribbon:RibbonTab x:Class=&quot;PrismApp.Modules.MyModuleA.Views.MyModuleARibbonTab&quot;\n             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;\n             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;\n             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; \n             xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; \n             xmlns:ribbon=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation/ribbon&quot;\n             xmlns:vm=&quot;clr-namespace:PrismApp.Modules.MyModuleA.ViewModels&quot;\n             xmlns:prism=&quot;http://www.codeplex.com/prism&quot;\n             Header=&quot;My Module&quot;\n             mc:Ignorable=&quot;d&quot; d:DesignHeight=&quot;300&quot; d:DesignWidth=&quot;300&quot;&gt;\n    &lt;ribbon:RibbonGroup Header=&quot;My Module Items&quot;&gt;\n        &lt;ribbon:RibbonButton Label=&quot;Save&quot; Command=&quot;{x:Static vm:MyModuleAViewModel.SaveCommand}&quot;&gt;&lt;/ribbon:RibbonButton&gt;\n    &lt;/ribbon:RibbonGroup&gt;\n&lt;/ribbon:RibbonTab&gt;</code></pre>\n\nNow, when I click on Button inside MyModuleAView.xaml, SaveCommand execute and every thing works fine, but when I click on RibbonButton, SaveCommand not execute. What should I do for this? What is best practice?<br />\n<br />\nAnd, I have another question: Should I map Command to methods inside my ViewModel, or It's better to keep them in another class which implements ICommand interface?<br />\n<br />\n(I'm using <a href=\"http://www.microsoft.com/en-us/download/details.aspx?id=11877\" rel=\"nofollow\">Ribbon for WPF October 2010</a> in .NET 4)<br />\n",
    "PostedDate": "2013-01-31T15:14:35.04-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "995324",
    "ThreadId": "431606",
    "Html": "Hi,\r<br />\n<br />\nBased on my understanding of the code snippets you provided, this behavior could be caused by a timing issue, as by the time you resolve the <strong>ResolveRibbonTabView</strong> instance, no <strong>ICommand</strong> object instance has been passed to the <strong>SaveCommand</strong> property, as this will be done in your <strong>MyModuleAViewModel</strong> constructor:<br />\n<pre><code> public MyModuleAViewModel()\n        {\n            SaveCommand = new DelegateCommand(Save, CanSave);\n        }</code></pre>\n\nWhich in your case, I believe it will be called after this instance is resolved when registering the <strong>ResolveMainView</strong> . As a quick test you could try changing the order on how these views are registered, in order to ensure the view model instance is resolved before retrieving the <strong>ResolveRibbonTabView</strong>:<br />\n<pre><code>(...)\n_regionManager.RegisterViewWithRegion(&quot;MainRegion&quot;, ResolveMainView);\n_regionManager.RegisterViewWithRegion(&quot;RibbonRegion&quot;, ResolveRibbonTabView);\n(...)</code></pre>\n\nOn the other hand, in my opinion a cleaner approach could be to define a globally available command in a static class, for example benefiting of the <strong>CompositeCommand</strong> class provided by <strong>Prism</strong>. Which will allow you to dynamically register child commands to this globally available command (e.g you could register your save commands methods in your view model to this static class and in your different views bind to this global command), this way once the command is registered all your views should execute it without problems.\r<br />\n<br />\nFor more detailed information on this approach, I believe you could check the following section of the documentation:<br />\n<ul>\n<li>\n<a href=\"http://msdn.microsoft.com/en-us/library/ff921122(v=pandp.40).aspx#sec4\" rel=\"nofollow\">Making a Command Globally Available</a><br />\n</li>\n</ul>\nI hope you find this helpful,\r<br />\n<br />\nAgustin Adami\r<br />\n<a href=\"http://blogs.southworks.net/aadami\" rel=\"nofollow\">http://blogs.southworks.net/aadami</a><br />\n",
    "PostedDate": "2013-02-01T09:56:08.503-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]