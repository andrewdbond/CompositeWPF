[
  {
    "Id": "572560",
    "ThreadId": "247687",
    "Html": "\r\n<p>Hi all,</p>\r\n<p>I want have the content of a Grid's row (not DataGrid) bound to a given DataContext property. In others words, I want that the UserControl that appear in, lets say... row 1 of my Grid, change when the DataContext property XX change from an UserControl to\r\n another UserControl. Any idea how do that?</p>\r\n<p>What I'm trying to achieve is a loosely couple UI consisting of a Shell (main window) with placeholders (lets said that the placeholders are Grid's row 0 and Grid's row 1 for example), but with the capability to allow the content of such placeholders be\r\n changed from any of the placeholders, How? well, binding the Commands property of some placeholder controls to the Shell DataContext's Commands (the ShellViewModel), Shell DataContext by hierarchy is the DataContext of all controls inside any placeholder that\r\n don't overwrite the DataContext property. Then inside the implementation of such commands change Shell's DataContext property XX.</p>\r\n<p>More specifically, I want that the navigation controls (UI) of my applications can be easily changed without affect the semantic of the navigation, and the only thing that come to my newbie mind after read about MVVM is the above approach. Do you have a\r\n better idea? Is that correct or is too loosely couple ;)</p>\r\n<p>The idea is have a Shell with placeholders, and that the Shell expose Commands through its DataContext (the Shell's ViewModel) to any of the\r\n<em>UNKNOWN AT FRONT</em> UIs components that will fill such placeholders. Such commands can be saw as a kind of API/Interface used to interact with, for example, the navigation system. I'm in the right path? or I'm just saying newbie crap.</p>\r\n<p>Cheers</p>\r\n<p>Frank Abel</p>\r\n",
    "PostedDate": "2011-02-26T07:22:21.273-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "572581",
    "ThreadId": "247687",
    "Html": "<p>Well, after think and read more I get a way:</p>\n<pre><div style=\"color: black; background-color: white;\"><pre><span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">ContentControl</span> <span style=\"color: red;\">Grid.Row</span><span style=\"color: blue;\">=</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">1</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">&gt;</span>\n    <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">Binding</span> <span style=\"color: red;\">Path</span><span style=\"color: blue;\">=</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">CurrentView</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">/&gt;</span>\n<span style=\"color: blue;\">&lt;/</span><span style=\"color: #a31515;\">ContentControl</span><span style=\"color: blue;\">&gt;</span>\n</pre>\n</div>\n<br />Still want know what the Gurus of the composite world have to said about this way of decouple the Shell components while allow that such components change the system navigation/view-state.<br /><br />Frank<br /></pre>",
    "PostedDate": "2011-02-26T09:17:46.397-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "573414",
    "ThreadId": "247687",
    "Html": "<p>Hi Frank,</p>\r\n<p>In order to achive what you've mentioned in your first question, you could bind the Grid's Children collection to an observable collection in your ViewModel.</p>\r\n<p>As for the approach you've chosen to decouple the UI from the navigation semantics seems a valid possibility to achieve that requirement.</p>\r\n<p>Thanks,</p>\r\n<p>Miguel Bronzovic<br /><a href=\"http://blogs.southworks.net/mbronzovic\">http://blogs.southworks.net/mbronzovic</a></p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-02-28T11:20:58.323-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "573481",
    "ThreadId": "247687",
    "Html": "<p>Hi Miguel,</p>\r\n<p>Thanks for your reply.</p>\r\n<p>I will try to explain what I'm doing in order to receive criticism again or to favor this pattern or whatever thing it is. May be this pattern isn't new and I'm reinventing the wheel, but I want share it with the community to contribute with something useful or realize how crazy I'm.&nbsp; I don't have time to research more right now cos I already consume all the time I can spent learning without get in troubles in my current project ;) so here we go:</p>\r\n<p>What I'm proposing is a way to organize the Views of an application in the composite world. I'm thinking that may be in some scenarios is good exposes a set of properties to the Shell through its ViewModel and consider such properties as the semantic definition of the UI. For example, in the following Shell:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\"><strong><br /><br /></strong>&lt;</span><span style=\"color: #a31515;\">Grid</span><span style=\"color: blue;\">&gt;</span>\r\n       <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">Grid.DataContext</span><span style=\"color: blue;\">&gt;</span>\r\n            <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">local</span><span style=\"color: blue;\">:</span><span style=\"color: #a31515;\">ShellViewModel</span> <span style=\"color: blue;\">/&gt;</span>\r\n       <span style=\"color: blue;\">&lt;/</span><span style=\"color: #a31515;\">Grid.DataContext</span><span style=\"color: blue;\">&gt;</span>\r\n\r\n        <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">Grid.RowDefinitions</span><span style=\"color: blue;\">&gt;</span>\r\n            <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">RowDefinition</span><span style=\"color: blue;\">/&gt;</span>\r\n            <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">RowDefinition</span><span style=\"color: blue;\">/&gt;</span>\r\n            <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">RowDefinition</span><span style=\"color: blue;\">/&gt;</span>\r\n        <span style=\"color: blue;\">&lt;/</span><span style=\"color: #a31515;\">Grid.RowDefinitions</span><span style=\"color: blue;\">&gt;</span>\r\n \r\n        <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">views</span><span style=\"color: blue;\">:</span><span style=\"color: #a31515;\">MainMenuView</span> <span style=\"color: red;\">Grid.Row</span><span style=\"color: blue;\">=</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">0</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">/&gt;</span>\r\n        \r\n        <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">ContentControl</span> <span style=\"color: red;\">Grid.Row</span><span style=\"color: blue;\">=</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">1</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">&gt;</span>\r\n            <span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">Binding</span> <span style=\"color: red;\">Path</span><span style=\"color: blue;\">=</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">CenterPlaceholder</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">/&gt;</span>\r\n        <span style=\"color: blue;\">&lt;/</span><span style=\"color: #a31515;\">ContentControl</span><span style=\"color: blue;\">&gt;</span>\r\n\r\n\t<span style=\"color: blue;\">&lt;</span><span style=\"color: #a31515;\">views</span><span style=\"color: blue;\">:</span><span style=\"color: #a31515;\">FooterView</span> <span style=\"color: red;\">Grid.Row</span><span style=\"color: blue;\">=</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">2</span><span style=\"color: black;\">\"</span><span style=\"color: blue;\">/&gt;</span>\r\n \r\n<span style=\"color: blue;\">&lt;/</span><span style=\"color: #a31515;\">Grid</span><span style=\"color: blue;\">&gt;</span>\r\n\r\n</pre>\r\n</div>\r\n<p>are referenced two views statically (the MainMenuView and the FooterView) and one other view dynamically (the view that is assigned to the CenterPlaceholder ShellViewModel&rsquo;s property), so what is showed at a given time in the row 1 depend of the implementation of the CenterPlaceholder property. If then we add a set of ICommands to the ShellViewModel and said that those ICommands are the way to change the semantic status of the UI (the navigation system), we got a system with some advantages. To clarify let&rsquo;s suppose that exist another two views, ProductListView and CustomerListView, and due to, two ShellViewModel &nbsp;ICommands named ShowProductListViewAtCenter and ShowCustomerListViewAtCenter that basically switch the CenterPlaceholder ShellViewModel&rsquo;s property to one view and to the other.</p>\r\n<p>&nbsp;</p>\r\n<p>Expect you get the point, pls, don&rsquo;t look the logic of the example or how tuned is the code, etc. get the idea and talk about it, again or to favor.</p>\r\n<p>&nbsp;</p>\r\n<p>Using the above approach we can get the following advantages in some scenarios:</p>\r\n<p>1-<span style=\"font: 7pt 'Times New Roman';\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Very clear division between the navigations views (MainMenuView in the above example) and the navigation semantic (what each navigation action imply in term of UI semantic changes).</p>\r\n<p>2-<span style=\"font: 7pt 'Times New Roman';\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Very clear division between navigation semantic and the navigation-system-layout UI.</p>\r\n<p>3-<span style=\"font: 7pt 'Times New Roman';\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Possibility of easily implement view caching when desired, think that a given view can be stored as a ShellViewModel field and just created the first time its corresponded property is acceded, saving processing when user request show other view and the it again through the navigation system.</p>\r\n<p>Exist others pro, but let&rsquo;s first gurus tell me how wrong I&rsquo;m ;)</p>\r\n<p>Miguel, if we store the dynamic views in a Children collection we lost ones of the points of this pattern, cos then designers can&rsquo;t arrange the placeholders/dynamic-views (the semantic of the UI) to define the UI as they want.</p>\r\n<p>Cheers</p>\r\n<p>Frank Abel</p>",
    "PostedDate": "2011-02-28T13:03:30.59-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "573994",
    "ThreadId": "247687",
    "Html": "<p>Hi Frank,</p>\r\n<p>The approach you're mentioning seems right, but it might have one drawback regarding the tight coupling of the shell with the views that are going to be placed in it. That is to say, by placing such commands in the ShellViewModel, you are bound to place the logic for achieving the operations such as showing a customer list in the Shell project. The guidance in Prism shows that it's possible to place such logic in the modules themselves, in order to achieve a loose-coupling between your components.</p>\r\n<p>I hope you find this helpful.</p>\r\n<p>Guido Leandro Maliandi<br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-03-01T11:02:00.943-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "574105",
    "ThreadId": "247687",
    "Html": "<p>Completely agreed with you Guido. I just put the ICommands there to put it at some place, but don't mean that such commands must be fixed in the ShellViewModel. In fact, I think that the location of a given ICommands set is determined for to witch UI semantic items the ICommand set interact, so, ICommands for a set \"UI semantic elements\" must be as near as possible regard modularity without break the access mechanics (datacontext in this case).</p>\r\n<p>&nbsp;</p>\r\n<p>Thank for your reply</p>\r\n<p>Frank Abel</p>",
    "PostedDate": "2011-03-01T14:25:27.89-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]