[
  {
    "Id": "918665",
    "ThreadId": "397222",
    "Html": "\r\n<ul>\r\n<li>WPF </li><li>MEF </li><li>Many nested views using scoped regions </li><li>View Injection only, no INavaigation </li></ul>\r\n<p>I'm starting to implement <strong>RegionMemberLifetime </strong>to help destroy views when they are removed from a region.</p>\r\n<p>The problem I'm having is when I apply the attribute to a view or it's viewModel, the view will not show up.&nbsp; My suspicion is there ends up being no reference to it after injecting the view, so it gets cleaned up right away.</p>\r\n<p>Example:</p>\r\n<p>There is an existing shell and main tab control as a target region.<br>\r\nUser clicks a button in the shell to open a new tab for Patient Details (injected view all using scoped regions), after injecting the Patient View the Patient module raises the event\r\n<strong>OnParentWorkspaceInjected </strong>(event payload contains the scoped region used to inject the Patient View).</p>\r\n<p>Other modules subscribe to the <strong>OnParentWorkspaceInjected </strong>event and inject their own view into a region on the PatientView called\r\n<strong>PatientDetailModules</strong>.</p>\r\n<p>There are several modules that inject their views, all done using this appraoch:</p>\r\n<p><strong>View</strong></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>  [Export]\r\n  [PartCreationPolicy(System.ComponentModel.Composition.CreationPolicy.NonShared)]\r\n  [RegionMemberLifetime(KeepAlive = <span style=\"color:blue\">false</span>)]\r\n  <span style=\"color:blue\">public</span> <span style=\"color:blue\">partial</span> <span style=\"color:blue\">class</span> LoanView : UserControl\r\n  {\r\n\r\n...\r\n</pre>\r\n</div>\r\n<p><strong>In the controller class in the module for that view</strong></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">private</span> <span style=\"color:blue\">void</span> OnParentWorkspaceInjected(PatientWorkspaceInjectedEvent viewEvent)\r\n{\r\n  LoanView view = <span style=\"color:blue\">this</span>.serviceLocator.GetInstance&lt;LoanView&gt;();\r\n  IRegionManager scopedParentRegion = viewEvent.ScopedRegionManager;\r\n  IRegion region = scopedParentRegion.Regions[RegionNames.PatientDetailModules];\r\n  IRegionManager scopedRegion = region.Add(view, <span style=\"color:blue\">null</span>, <span style=\"color:blue\">true</span>);\r\n\r\n  view.ViewModel.SessionKey = viewEvent.SessionKey;\r\n  view.ViewModel.UniqueKey = viewEvent.UniqueKey;\r\n  view.ViewModel.ScopedRegionManager = scopedRegion;\r\n  <span style=\"color:blue\">region</span>.Activate(view);\r\n\r\n  Guid uniqueKey = Guid.NewGuid();\r\n  <span style=\"color:blue\">this</span>.SetView(uniqueKey, view);\r\n  view.ViewModel.UniqueKey = uniqueKey;\r\n\r\n  view.ViewModel.RaisePublishGetList();\r\n}\r\n</pre>\r\n</div>\r\n<p>The only code change I made was adding&nbsp;<strong>[RegionMemberLifetime(KeepAlive =\r\n<span style=\"color:blue\">false</span>)]</strong> to the view.</p>\r\n<p>If I add that attribute to either the view or viewModel, the view will not show up.</p>\r\n<p>If that attribute isn't used the views show up and behave as expected.</p>\r\n<p>Thanks in advance.</p>\r\n",
    "PostedDate": "2012-09-27T11:58:28.457-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "919146",
    "ThreadId": "397222",
    "Html": "<p>Hi,</p>\r\n<p>We have tried setting up a spike to analyze this scenario, but so far we were unable to reproduce this behavior.</p>\r\n<p>It would be helpful if you could provide us with a repro-sample application portraying this problem, so that we can analyze it in further detail and help you find the cause behind this behavior.</p>\r\n<p>Regards,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-09-28T11:45:32.907-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "922855",
    "ThreadId": "397222",
    "Html": "\r\n<p>Hi,</p>\r\n<p>Thanks for looking into this.</p>\r\n<p>I've created an example solution that is based on our real solution. &nbsp;The example uses the same event and injection patterns but is a dramatically reduced and simplified code example. &nbsp;Some things in the example may not make sense but are there\r\n because they match our actual code.</p>\r\n<p>At this point I cannot reproduce the missing view, but I can reproduce something else I was running into before the views stopped showing up.</p>\r\n<p>I could decorate views/viewmodels with the KeepAlive=false but when trying to remove the view but would get this error&nbsp;<strong>The region does not contain the specified view.</strong></p>\r\n<p>If you take the KeepAlive attribute off that view the removal works as expected. &nbsp;The weird thing is, stepping through the code you can see the view object in the regionManager.Views collection. &nbsp;I'm thinking whatever is causing this problem may\r\n be related to the other missing view problem, so If one problem can be solved it may resolve them all. &nbsp;In other words, I have never been able to get KeepAlive=false to work.</p>\r\n<p><strong>Example Solution Instructions</strong></p>\r\n<ul>\r\n<li>Download from my skydrive here&nbsp;http://sdrv.ms/TdOYpr </li><li>Build and run </li><li>To reproduce the error\r\n<ul>\r\n<li>Click ok on login screen (no username/pwd needed) </li><li>Click &quot;Customer: Injected via View Discovery&quot; button to inject a customer workspace\r\n</li><li>Click &quot;Raise Event&quot; button in the Orders View </li><li>Click &quot;Remove View&quot; button in the Order Details View </li><li>Get the&nbsp;<strong>The region does not contain the specified view </strong>\r\nerror </li></ul>\r\n</li><li>To run without the error\r\n<ul>\r\n<li>Edit <strong>OrderDetailsView.xaml.cs</strong> and remove the <strong>[RegionMemberLifetime(KeepAlive = false)]</strong> attribute\r\n</li><li>Run and follow the steps above and the view will remove successfully </li></ul>\r\n</li></ul>\r\n<p>The solution is using Prism 4.1 and Visual Studio 2010.</p>\r\n<p>I will continue to try and reproduce the scenario where the view won't show at all as stated in my opening post.</p>\r\n<p>I really appreciate the help.</p>\r\n<p>Cheers</p>\r\n",
    "PostedDate": "2012-10-06T09:00:31.45-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924058",
    "ThreadId": "397222",
    "Html": "<p>I think I've resolved the second issue noted in my last post. &nbsp;I was still using region.Remove(view) but should have been using region.Deactivate(view) in combination with KeepAlive=false.</p>\r\n<p>Related discussion in this post:&nbsp;<a href=\"http://compositewpf.codeplex.com/discussions/272855\">http://compositewpf.codeplex.com/discussions/272855</a></p>\r\n<p>I still cannot reproduce in the example solution the views not showing up but am continuing to work on that as it is still a problem in our main solution.</p>",
    "PostedDate": "2012-10-09T08:14:10.037-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924095",
    "ThreadId": "397222",
    "Html": "\r\n<p>Another related problem.</p>\r\n<p>Now that I'm deactivating views, the views are being removed fine it seems. &nbsp;On each test of injection/deactivation there seems to only be 1 view in the region collection which gets deactivated leaving no views in the collection.</p>\r\n<p>But, the view models are not getting destroyed.</p>\r\n<p>I set KeepAlive=false on the view models as well.</p>\r\n<p>I'm testing if the viewModels are still in memory or not by subscribing to the event raised on the home page. &nbsp;If I see output in the console I believe that viewModel to still be active despite it's view having been deactivated and removed from the\r\n region collection.</p>\r\n<p>If I inject/deactivate only one OrderDetails view, the viewModel will not pick up the event.</p>\r\n<p>If I inject/deactivate more than one, I will see output from the ViewModel for the event, but never for the first viewModel.</p>\r\n<p>In other words, I always see events handled for the total number of views injected minus 1.</p>\r\n<p>I tried hacking in some cleanup code to both un-subscribe from the event as well as setting the view's datacontext to null hoping to drop references, but no change.</p>\r\n<p>Are the viewModels just not getting garbage collected yet or is something else keeping them around? I don't make any other references to them as far as I know. &nbsp;But I've never been able to get this part of Prism working correctly so may be missing something...</p>\r\n",
    "PostedDate": "2012-10-09T08:56:51.833-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924281",
    "ThreadId": "397222",
    "Html": "<p>Hi,</p>\r\n<p>First, regarding your problem when removing views, it seems that (as you mentioned) it was related to a known issue in <strong>Prism </strong>when removing a view with <strong>KeepAlive </strong>set as <strong>false </strong>using the <strong>Remove </strong>method:</p>\r\n<ul>\r\n<li><a href=\"http://compositewpf.codeplex.com/workitem/8224\">Silverlight - Add/Remove view - ArgumentException</a></li>\r\n</ul>\r\n<p>In the aforementioned work item you can find another approach to workaround this problem by modifying the <strong>RegionMemberLifetimeBehavior </strong>class.</p>\r\n<p>Second, regarding the issue you are mentioning about your view models not being destroyed, it seems to be that the reason behind it was that the view models were ready to be garbage collected but the garbage collector was not run. You can check this, for example, by adding the following line to manually run the garbage collector before publishing the <strong>HomePageButtonClickEvent</strong>:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>GC.Collect();\r\n</pre>\r\n</div>\r\n</p>\r\n<p>After doing so, you should see that only one <strong>OrderDetailsViewModel </strong>responds to the <strong>HomePageButtonClickEvent</strong>: the view model of the current <strong>OrderDetailsView</strong>. The previous view models are effectively being garbage collected.</p>\r\n<p>I hope this helps,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-10-09T13:59:05.76-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924771",
    "ThreadId": "397222",
    "Html": "<p>I'm thinking that is a problem then if viewModels will linger with valid event subscriptions. &nbsp;What would be the best practice to ensure my \"removed\" viewModels won't interfere with executing code, implement IDisposable and use a region extension method? &nbsp;I definitely don't want \"removed\" viewModels to continue to handle events.</p>\r\n<p>Regarding my original problem of missing views I have finally been able to reproduce it.<br />I've uploaded a new solution to the same location here: <span>&nbsp;http://sdrv.ms/TdOYpr see Example2</span>&nbsp;</p>\r\n<p>The problem seems to be related to injecting multiple views into a tab control region. &nbsp;Here's the combination of problems:</p>\r\n<p><strong>KeepAlive=false</strong> is being added to the views only for this testing:</p>\r\n<p>When both modules show up, <strong>Orders </strong>is first, <strong>History </strong>is second from left to right.</p>\r\n<ul>\r\n<li>Mark no modules as KeepAlive=false, both&nbsp;<strong>Orders </strong>and <strong>History </strong>show up</li>\r\n<li>Mark both modules&nbsp;as KeepAlive=false, only&nbsp;<strong>History </strong>shows up</li>\r\n<li>Mark only <strong>History </strong>KeepAlive=false,&nbsp;both&nbsp;<strong>Orders&nbsp;</strong>and&nbsp;<strong>History&nbsp;</strong>show up</li>\r\n<li>Mark only <strong>Orders</strong> KeepAlive=false,&nbsp;only&nbsp;<strong>History&nbsp;</strong>shows up</li>\r\n</ul>\r\n<p>This is similar to behaviour I see in our main solution. &nbsp;I've experimented with <strong>ViewSortHint </strong>but didn't come up anything conclusive.</p>\r\n<p>I don't have this problem in other areas of our solution, I can apply KeepAlive=false and the views show up as expected. &nbsp;So far, the only time I have this problem is with the structure of nested views and injecting to the tab control as demonstrated in the Example solution.</p>",
    "PostedDate": "2012-10-10T09:03:43.06-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924921",
    "ThreadId": "397222",
    "Html": "<p>Hi,</p>\r\n<p>In the same scenario that your repro-sample application, where the <strong>OrderDetailsView </strong>will be always removed when deactivated, a possible approach could be to unsubscribe from the <strong>HomePageButtonClickEvent </strong>when the view is deactivated. For doing so, you could take advantage of the <strong>IActiveAware </strong>interface, which defines an <strong>IsActive </strong>property. When the state of the view changes, <strong>Prism </strong>change the value of this property to inform the view of its current state. Therefore, in the setter of this property, you could check if the value is <strong>false </strong>and invoke the <strong>Cleanup </strong>method to unsubscribe from the event:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">private</span> <span style=\"color: blue;\">bool</span> isActive;\r\n\r\n<span style=\"color: blue;\">public</span> <span style=\"color: blue;\">bool</span> IsActive \r\n{\r\n    <span style=\"color: blue;\">get</span>\r\n    {\r\n        <span style=\"color: blue;\">return</span> isActive;\r\n    }\r\n    <span style=\"color: blue;\">set</span>\r\n    {\r\n        <span style=\"color: blue;\">this</span>.isActive = value;\r\n\r\n        <span style=\"color: blue;\">if</span> (<span style=\"color: blue;\">this</span>.IsActive == <span style=\"color: blue;\">false</span>)\r\n        {\r\n            <span style=\"color: blue;\">this</span>.Cleanup();\r\n        }\r\n\r\n        <span style=\"color: blue;\">this</span>.RaisePropertyChanged(<span style=\"color: #a31515;\">\"IsActive\"</span>);\r\n    }\r\n}\r\n</pre>\r\n</div>\r\nAlso, in order for this to work, you will need to subscribe / unsubscribe passing the method directly instead of a lambda expression (when using lambda expressions, the lambda passed to the <strong>Subscribe </strong>method will be different from the one passed to the <strong>Unsubscribe </strong>method and hence, the un-subscription fails:)</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">this</span>.eventManager.Subscribe&lt;HomePageButtonClickEvent&gt;(<span style=\"color: blue;\">this</span>.OnHomePageButtonClick);\r\n<span style=\"color: blue;\">this</span>.eventManager.Unsubscribe&lt;HomePageButtonClickEvent&gt;(<span style=\"color: blue;\">this</span>.OnHomePageButtonClick);\r\n</pre>\r\n</div>\r\n</p>\r\n<p>Regarding your original problem with the <strong>OrdersView </strong>and <strong>HistoryView</strong>, as far as I know, this is a normal behavior when using a <strong>TabControl </strong>as a region. Based on my understanding, a <strong>\"TabRegion\"</strong> only has one active view: the currently selected tab. All the other views in the <strong>\"TabRegion\"</strong> are considered deactivated.</p>\r\n<p>Basically, after injecting the <strong>OrdersView </strong>you are injecting and activating the <strong>HistoryView</strong>. Hence, as only one view can be active, the <strong>OrdersView </strong>is deactivated. As the view is marked with <strong>KeepAlive </strong>set to <strong>false</strong>, <strong>Prism </strong>removes it from the region.</p>\r\n<p>You can check this behavior in with other <strong>TabControls</strong>. For example, if you set <strong>KeepAlive </strong>to be <strong>false </strong>in the <strong>HomePageView</strong>, when the <strong>CustomerWorkspaceView </strong>is injected the <strong>HomePageView </strong>is also removed.</p>\r\n<p>I hope you find this useful,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-10-10T13:56:59.457-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "925556",
    "ThreadId": "397222",
    "Html": "<p>Thanks for all the info so far, this is helping narrow down what we need to at least.</p>\r\n<p>I'd appreciate your opinions on these approaches:</p>\r\n<p>&nbsp;</p>\r\n<p><strong>Using KeepAlive=False</strong></p>\r\n<p><strong>\r\n<hr />\r\n</strong></p>\r\n<p>I don't think we're going to use this approach at all since it doesn't work in our tabbed region scenarios.</p>\r\n<p>I'd also rather not have multiple patterns to support or chose from especially when one simply won't work well if they get mixed up.</p>\r\n<p>So, I'm thinking to not use the KeepAlive=false pattern and continue to use&nbsp;<strong>region.Remove</strong> instead of <strong>region.Deactivate</strong>.</p>\r\n<p>My question there is what happens with the view/viewModel and garbage collection? &nbsp;If the view is removed, is the viewModel flagged for GC like it is when using the KeepAlive=false/region.Deactivate combination? &nbsp;Or do I need to do something different to deal with the viewModel if .remove(view) only removes the view?</p>\r\n<p>Do you have suggestions on a best practice for cleaning up views/viewModels when not using <strong>KeepAlive=false</strong>?</p>\r\n<p>&nbsp;</p>\r\n<p><strong>IActiveAware and Cleanup</strong></p>\r\n<p>\r\n<hr />\r\n</p>\r\n<p>I can see where implementing <strong>IActiveAware </strong>will be beneficial, but again since it is called all the time when a tabbed view isn't active I can't use it for viewModel cleanup since the view will be used again once the user clicks on it.</p>\r\n<p>That leads me to think I need to use an extension method (as I believe you've mentioned before in other posts) to help control when view/viewModels are destroyed and cleaned up in a consistent fashion.</p>\r\n<p>Something like:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>region.RemoveAndCleanup(view)<br />{\r\n  view.ViewModel.Cleanup()\r\n<span style=\"color: blue;\">  this</span>.remove(view) \r\n</pre>\r\n<pre>}</pre>\r\n</div>\r\n</p>\r\n<p>Thoughts on that?</p>\r\n<p>&nbsp;</p>\r\n<p>I'll continue experimenting in the meantime.</p>\r\n<p>Regards.</p>",
    "PostedDate": "2012-10-11T15:45:42.363-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "925855",
    "ThreadId": "397222",
    "Html": "<p>Hi Again,</p>\r\n<p>I think I've got this all figured out and mostly tested.</p>\r\n<p>We won't be using <strong>KeepAlive=false</strong> and instead will use <strong>region.Remove()</strong>. &nbsp;This does flag viewModels for cleanup which I can prove the same way as done above calling <strong>GC.Collect()</strong> to see the events no longer subscribing.</p>\r\n<p>The next related step is to upgrade the solution to <strong>Prism 4.1</strong> to take advantage of the&nbsp;<span><strong>ClearChildViewsRegionBehavior</strong> to ensure nested views/viewModels are also removed properly.</span></p>\r\n<p>We can use the region extension method pattern if we need special cleanup routines but for now won't do anything different.</p>\r\n<p>So after a lot of effort, trial and error, we're basically changing nothing but I at least understand how things work much better :)</p>\r\n<p>Thanks again for all the help and if you have any additional comments or opinions please share.</p>\r\n<p>Cheers</p>",
    "PostedDate": "2012-10-12T08:20:09.893-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "925929",
    "ThreadId": "397222",
    "Html": "<p>Hi,</p>\r\n<p>I am glad you found this useful.</p>\r\n<p>As a side note, I would like to comment that <strong>Prism </strong>does not only provide the <strong>RegionMemberLifetimeAttribute</strong>, it also provides an <strong>IRegionMemberLifetime </strong>interface. The <strong>RegionMemberLifetimeBehavior </strong>(the one in charge of removing the deactivated views) checks if the view / view model implements either the attribute or the interface to know if the view should be removed or not. The main difference between using the attribute or the interface is that the interface allows you to change the value of the <strong>KeepAlive </strong>property during run-time, while the attribute defines the <strong>KeepAlive </strong>value in design-time.</p>\r\n<p>Hence, when using the interface instead of the attribute you can change the <strong>KeepAlive </strong>property of a view, for example, if the view is related to the information being shown to the user or not (for example a details view), if a view contains modified data that need to be saved or not (for example an edit view), if the region where the view was injected can contain deactivated views or not (for example a <strong>TabControl</strong>,) etc. Therefore, the <strong>IRegionMemberLifetime </strong>interface can provide you with more flexibility than the attribute, which could be useful in some scenarios.</p>\r\n<p>Regards,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-10-12T10:47:21.19-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]