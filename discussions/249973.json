[
  {
    "Id": "581531",
    "ThreadId": "249973",
    "Html": "\r\n<p>I believe I have an issue common to the community that has not been directly addressed.&nbsp; I have a WPF application based off StocktraderRI and therefore relies heavily on MEF (AggregateCatalog).<br>\r\n<br>\r\nThe application will have a ConfigurationView (Popup Window) which will allow the user to choose which extension modules to enable.&nbsp; The problem is that it appears that I need to have 2 containers to accomplish this goal. The Prism examples always just\r\n create 1 AggregateCatalog that is statically set via config file, XAML, or code.&nbsp; Below is my best guess at a solution.&nbsp; For illustration purposes assume I have 2 Modules A and B, but the user placed a check&nbsp; mark&nbsp; (selected) only next\r\n to Module A in the ConfigurationView.<br>\r\n<br>\r\n<strong>Module MEF Container</strong>: A preliminary Module MEF pass looks at all assemblies for the &ldquo;IModule&rdquo; interface so the ConfigurationView can show the user all modules possibilities (Module A and B).&nbsp; This is briefly used outside MefBootstrapper\r\n flow and then somehow discarded.&nbsp; The Modules selected for the user are stored in a config file for use by the &ldquo;Complete MEF Container&rdquo;.<br>\r\n<br>\r\n<strong>Complete MEF Container</strong>: This pass uses only the assemblies associated with the selected Modules (Module A assembly), which is contained in the Prism AggregateCatalog.&nbsp; This is the container used within MEFBootstrapper.&nbsp; Note this\r\n container will resolve everything which includes IModule, Views, ViewModules, and Services&hellip;<br>\r\n<br>\r\n<span style=\"text-decoration:underline\">Questions:</span><br>\r\n<br>\r\n1) First is my approach the best strategy for use with the Prism framework?<br>\r\n<br>\r\n2) In my proposed solution how do I create an IModuleCatalog and ModuleManager for the sole purpose of getting a list/description of available modules (Will use DirectoryModuleCatalog)?&nbsp; I do not want the Module initialize routines called, and will discard\r\n the ModuleManager somehow once the list is complete.&nbsp; If I do not discard the ModuleManager I will have 2 of them sitting around when I later want to locate the prism IModuleManger with the servicelocator.<br>\r\n<br>\r\n3)&nbsp; I thought about using methods of the ModuleManager like &ldquo;LoadOnDemand&rdquo;, which might allow me to load modules later depending on user selection.&nbsp; The problem is MEF resolves everything (Views, Services, &hellip;) so the Module methods\r\n like &ldquo;Initialize()&rdquo; and &ldquo;LoadOnDemand()&rdquo; are fairly useless in a full MEF world?<br>\r\n<br>\r\n4) If the user selects or deselects a module within ConfigurationView how in the world do I recompose the container (basically an application reboot) using the prism flow.<br>\r\n<br>\r\n5) What is the best way to gather a detailed description for each module to display in the ConfigurationView.&nbsp; I read that ModuleCatalog a collection ModuleInfo class, which in turn has a few properties ModuleName and ModuleType.&nbsp; However I would\r\n like a custom property called description that the Module creator would add to the metadata. Then I could display this custom text to the user so they can understand details of the module they are enabling/disabling.<br>\r\n<br>\r\nThanks,<br>\r\naidesigner</p>\r\n",
    "PostedDate": "2011-03-16T09:57:18.797-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "582117",
    "ThreadId": "249973",
    "Html": "<p>Hi,</p>\r\n<p>Based on my understanding of your scenario, you could achieve your requirement by using the app.config file to configure your module catalog (you could set modules to be loaded on demand and manage dependencies between them). By following this approach, you shouldn&rsquo;t have to deal with nested containers.</p>\r\n<p>Therefore, you could easily retrieve module names to be shown in your view, and finally load on demand the modules selected by the user.</p>\r\n<p>You might find handy the following links:</p>\r\n<ul>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/gg405479(v=PandP.40).aspx\">Chapter 4: Modular Application Development</a> (especially the section titled &ldquo;Downloading Remote Modules in the Background&rdquo;)</li>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/ff921068(v=PandP.40).aspx\">Modularity QuickStarts for WPF</a></li>\r\n</ul>\r\n<p>I hope you find this information useful.</p>\r\n<p>Thanks,</p>\r\n<p>Miguel Bronzovic<br /><a href=\"http://blogs.southworks.net/mbronzovic\">http://blogs.southworks.net/mbronzovic</a></p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-03-17T08:06:06.97-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "582309",
    "ThreadId": "249973",
    "Html": "<p>First thank you for your reply.&nbsp; I have read all the Prism documentation and Quickstarts in search of answers.</p>\r\n<p>I do not believe your approach will work because my extension modules are created by the community.&nbsp; Individuals may then install a module in a specific directory and my WPF Prism application will import the modules through MEF.&nbsp; Also note there is no real purpose for IModule, as the AggregateCatalog of MEFBootstrap will resolve all imports (Modules, Views, and Services) using MEF.</p>\r\n<p><span style=\"text-decoration: underline;\">Problem:</span></p>\r\n<p>It still seems I need some type of container that reveals all available modules (DirectoryModuleCatalog).&nbsp; After that I can follow the normal MEFBootstrap flow, but only include the module (assemblies) selected by the user in my configuration pop-up window.&nbsp; If you agree with my analysis can you answer a few of the questions above (Especially #2)...</p>\r\n<p>Thanks,</p>\r\n<p>aidesigner</p>",
    "PostedDate": "2011-03-17T13:05:26.867-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "582732",
    "ThreadId": "249973",
    "Html": "<p>Hi,</p>\r\n<p>If you specify that the modules should be loaded OnDemand, you could use the <strong>DirectoryModuleCatalog</strong>, to get the modules you have in your folder, and then launch the configuration pop-up window, in which a list of the available modules could be obtained, as you've mentioned, from the <strong>ModuleCatalog</strong> (you could pass the same instance of <strong>DirectoryModuleCatalog </strong>that you've used, which contains a list of all the modules in the directory you've specified in its <strong>Modules </strong>property). You could then use call the <strong>ModuleManager.LoadModule</strong> method (which indicates that a module should be loaded) for each module that you want to load (based on the selection the user has made in the pop up).</p>\r\n<p>As for using nested containers, if you follow the aforementioned approach there should be no need to do so. The modules and the exports associated to them will only be added to the AggregateCatalog once a module is loaded.</p>\r\n<p>I hope you find this helpful.</p>\r\n<p>Guido Leandro Maliandi&nbsp;<br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-03-18T10:15:34.453-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "582806",
    "ThreadId": "249973",
    "Html": "<p>Thanks for stikcing with this issue...</p>\r\n<p>LoadModule only has any meaning if the modules implement IModule and more importantly use the initialize() method to register views and services.&nbsp; However with the introduction of MEF examples like the StockTraderRI MEF import everything (views, services, ...) and leave Module.initialize() empty.&nbsp; A Quote from Chapter 4 \"Instead of using the initialization mechanism provided by the <strong>IModule</strong> interface, the Stock Trader RI uses a declarative, attribute-based approach for registering views, services, and types.\"</p>\r\n<p>Given these facts if I create my AggregateCatalog with all assemblies I get everything imported (views, services) for all modules.&nbsp; Therefore it stills seems I have to create AggregateCatalog only utilizing the assemblies for the Modules enabled within my popup ConfigView.&nbsp; Hence I need a means of creating an \"available modules list\" using a ModuleCatalog container that is outside of the Prisim/MEFBootstrap/Aggregate Catalog flow.&nbsp; The list can then be used by the ConfigView, which in turn outputs a list (ie config.txt) of selected modules.&nbsp; This selected module list is then utilized to populate the Aggregate Catalog (Contain a subset of available modules).</p>\r\n<p>Also note I don't think my solution deals with nested containers.&nbsp; It simply has 2 independent parallel containers 1) Container just to find available Modules (imports IModule). 2) Standard Prism AggreateContainer(Modules, views, services) in MEFBootstrap, which only uses a subset of module assemblies.</p>\r\n<p>If you agree with my problem can you help me with my initial questions (Espically #2, #4, #5)...</p>\r\n<p>Thanks,</p>",
    "PostedDate": "2011-03-18T11:51:26.933-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "583944",
    "ThreadId": "249973",
    "Html": "<p>Hi,</p>\r\n<p>The <strong>ModuleExport</strong> attribute is used by MEF to declare that the class being exported is a module (that is to say, implements <strong>IModule</strong>), therefore, when you load that module through the <strong>ModuleManager.LoadModule</strong> method, its exports will be added to the MEF container. This is true even if the <strong>Initialize </strong>method is left empty.</p>\r\n<p>Therefore, there is no need to maintain separate containers, since you would only add the types of the modules you've selected to the container. The usage of the <strong>ModuleExport </strong>attribute in your case would be something like this:</p>\r\n<pre>[ModuleExport(<span style=\"color: blue;\">typeof</span>(MyModule), InitializationMode = InitializationMode.OnDemand)]<br /></pre>\r\n<p>In order to have the list of the available modules in the <strong>ConfigView</strong> you could use the <strong>DirectoryModuleCatalog</strong>; since you will have defined that your modules should be loaded on demand, retrieving the list of the available modules in a directory won't export its types into the container. They will only be exported when the <strong>ModuleManager.LoadModule </strong>method is called.</p>\r\n<p>Please let me know if this scenario doesn't fit your requirements.</p>\r\n<p>I hope you find this helpful.</p>\r\n<p>Guido Leandro Maliandi&nbsp;<br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-03-21T12:58:02.707-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "584369",
    "ThreadId": "249973",
    "Html": "<p>Allow me to summarize to make sure I got this correct.&nbsp; ModuleManager finds IModule imports and then associates the respective assembly with the Module.&nbsp; For \"OnDemand\" Modules, only when LoadModule is called is the Module assembly added to the AggregateCatalog.&nbsp; For this reason all classes (ie. views, viewmodels, services) in the Module assembly will not be imported until LoadModule called.&nbsp; My new understanding requires that a Module be associated with only 1 assembly (Perhaps Partial IModule Classes resolves this issue)?<br /><br />If you can help a little futher I am now just left with questions 4 and 5 of the first post (Included below).&nbsp; I believe the answer to #4 is that it is not possible to unload a Module.</p>\r\n<p><span style=\"text-decoration: underline;\">Reposted Questions</span><br />4) If the user selects or deselects a module within ConfigurationView how in the world do I recompose the container (basically an application reboot) using the prism flow.<br /><br />5) What is the best way to gather a detailed description for each module to display in the ConfigurationView.&nbsp; I read that ModuleCatalog a collection ModuleInfo class, which in turn has a few properties ModuleName and ModuleType.&nbsp; However I would like a custom property called description that the Module creator would add to the metadata. Then I could display this custom text to the user so they can understand details of the module they are enabling/disabling.<br /><br />Thanks Again!</p>",
    "PostedDate": "2011-03-22T06:20:32.887-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "584426",
    "ThreadId": "249973",
    "Html": "<p>Hi,</p>\n<p>Based on my understanding, your assumption of my explanation is correct. Modules are usually associated to a single assembly. If you have different assemblies that compose a single \"unit\" or fulfilll a single use case, you could create a dependency between  those modules. You could read more about that in the <strong>Specifying Module Dependencies</strong> of the <a href=\"http://msdn.microsoft.com/en-us/library/gg405479%28PandP.40%29.aspx\">Modularity chapter</a> of the Prism MSDN documentation.</p>\n<p>As for your fourth question, you're correct, it's not possible to unload a module. What you could do is to publish an event with the EventAggregator to notify the module that all its services and views should be unregistered and removed. You can read more  about this in the following threads:</p>\n<ul>\n<li><a href=\"http://compositewpf.codeplex.com/discussions/223941\"><span>Prism Unload Module</span></a> </li>\n<li><a href=\"http://compositewpf.codeplex.com/discussions/217492\"><span>Loading and unloading modules on demand </span></a></li>\n</ul>\n<p>Regarding your fifth question, what you're mentioning isn't supported out of the box in Prism. You could extend Prism to support this, or create a custom mechanism to display such descriptions, for example retrieving the values from a database. For example,  if you wish to achieve your scenario storing modules in a configuration file, you could extend the <strong>ModuleConfigurationElement </strong>and <strong>ConfigurationModuleCatalog </strong>classes located in the <strong>Modularity </strong>folder of the <strong> Prism.Desktop</strong> project, to include an additional parameter which represents the description. Note that, in that case, you should also extend the <strong>ModuleInfo</strong> class to support having such a parameter, since the <strong> ConfigurationModuleCatalog </strong>ultimately uses the information in the <strong> App.config</strong> file to build <strong>ModuleInfo </strong>instances.</p>\n<p>You might also find the following threads useful to your purposes:</p>\n<ul>\n<li><a href=\"http://compositewpf.codeplex.com/discussions/79345\"><span>Conditional loading of Modules </span></a></li>\n<li><a href=\"http://compositewpf.codeplex.com/discussions/58292\"><span>Show login modal form before </span></a></li>\n<li><a href=\"http://compositewpf.codeplex.com/discussions/67191\"><span>Too many regions in my shell </span></a></li>\n<li><a href=\"http://compositewpf.codeplex.com/discussions/49448\"><span>User Defined Module Loading using Prism</span></a> </li>\n</ul>\n<p>I hope you find this helpful.</p>\n<p>Guido Leandro Maliandi&nbsp;<br /> <a href=\"http://blogs.southworks.net/gmaliandi\">http://blogs.southworks.net/gmaliandi</a></p>",
    "PostedDate": "2011-03-22T07:57:37.167-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]