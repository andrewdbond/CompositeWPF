[
  {
    "Id": "199895",
    "ThreadId": "59035",
    "Html": "<p>The situation is: I have an abstract &nbsp;PresenterBase class with abstract method</p>\r\n<p><span style=\"font-weight:bold\">public abstract class PresenterBase{</span></p>\r\n<p><span style=\"font-weight:bold\">abstract Guid ID();</span></p>\r\n<p><span style=\"font-weight:bold\">void ExecuteCommand(string commandName);</span></p>\r\n<p><span style=\"font-weight:bold\">}</span></p>\r\n<p>And some of presenters a derived from PresenterBase. When a presenter do something it sends some information + <span style=\"font-weight:bold\">ID. </span>Something happens and called object returns result + caller ID using an event. A controller catch this event and should recognize a presenter using ID from the event. So I'm trying to do the next code:</p>\r\n<p>\r\n<p>&nbsp;<span style=\"white-space:pre\"> </span>&nbsp;&nbsp;<span style=\"font-weight:bold\">&nbsp;var asm = System.Reflection.Assembly.GetExecutingAssembly();</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;foreach (Type tp in asm.GetTypes())</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (tp.IsInterface)</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PresenterBase presenter = null;</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;presenter = _container.Resolve&lt;<span style=\"font-style:italic\"><span style=\"color:#ff0000\"><span style=\"text-decoration:underline\">tp</span></span></span>&gt;() as PresenterBase;</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ((presenter != null) &amp;&amp; (presenter.ID() == command.CallerID))</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;presenter.ExecuteCommand(command.Command);</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p>\r\n<p><span style=\"font-weight:bold\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p>\r\n</p>\r\n<p>But have a problem in the line&nbsp;<span style=\"font-weight:bold\">presenter = _container.Resolve&lt;<span style=\"font-style:italic\"><span style=\"color:#ff0000\"><span style=\"text-decoration:underline\">tp</span></span></span>&gt;() as PresenterBase;</span></p>\r\n<p>Is there an another way to pass through an each presenter and check the condition for ID(). There is another reason whi this approach is't good - if presenter was't &nbsp;created before but just registered .Resolve&lt;&gt; invoke a contructor and memory is fillings an presenter that maybe never be called during this session.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-06-10T02:34:46.917-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "200506",
    "ThreadId": "59035",
    "Html": "<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>Hi dunenko,</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>&nbsp;</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>To fix the problem with the line of code you mentioned you might use the following one:</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>&nbsp;</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt 35.4pt\"><span style=\"font-size:10pt;font-family:'Courier New'\" lang=EN-US>presenter = unityContainer.Resolve(tp) as <span style=\"color:#2b91af\">PresenterBase</span>;</span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>&nbsp;</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>Though I don't know you whole scenario, but there might be some drawbacks in the approach you are using:</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt 53.4pt;text-indent:-18pt\"><span style=\"\"><span style=\"\"><span style=\"font-size:small;font-family:Calibri\">1.</span><span style=\"font:7pt &quot;Times New Roman&quot;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>The use of reflection might have performance issues. More over if the method is going to execute each time an event is published.</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt 53.4pt;text-indent:-18pt\"><span style=\"\" lang=EN-US><span style=\"\"><span style=\"font-size:small;font-family:Calibri\">2.</span><span style=\"font:7pt &quot;Times New Roman&quot;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=\"\" lang=EN-US><span style=\"font-size:small\"><span style=\"font-family:Calibri\">You will need to register all the types in the container. If not an exception is going to be thrown when trying to resolve an unregistered type.</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt 53.4pt;text-indent:-18pt\"><span style=\"\"><span style=\"\"><span style=\"font-size:small;font-family:Calibri\">3.</span><span style=\"font:7pt &quot;Times New Roman&quot;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>Even if you register all the types you need, you are creating a new instance of the presenter (and calling the <strong>ExecuteCommand</strong> method on the new instance, not in the one that actually published the event). (This might not be an issue if you intend it to be that way)</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>&nbsp;</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>If I understood your scenario correctly, you need the presenter to send some information (using an event?) that will trigger some operation. When the operation is finished, you need to execute the <strong>ExecuteCommand</strong> method on the presenter.</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>To achieve this you might, instead of handling the event published when the operation is finished in the controller, &nbsp;have it handled in the presenters using a filters (to filter by the presenter's ID). For example:</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>&nbsp;</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt 35.4pt\"><span style=\"font-size:10pt;color:black;font-family:'Courier New'\" lang=EN-US>event.Subscribe(ExecuteCommand, </span><span style=\"font-size:10pt;color:#2b91af;font-family:'Courier New'\" lang=EN-US>ThreadOption</span><span style=\"font-size:10pt;color:black;font-family:'Courier New'\" lang=EN-US>.PublisherThread, </span><span style=\"font-size:10pt;color:blue;font-family:'Courier New'\" lang=EN-US>false</span><span style=\"font-size:10pt;color:black;font-family:'Courier New'\" lang=EN-US>, command =&gt; command.CallerID == this.ID);</span><span style=\"font-size:10pt;font-family:'Courier New'\"></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>&nbsp;</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"\" lang=EN-US><span style=\"font-size:small\"><span style=\"font-family:Calibri\">This way you will avoid all of the above drawbacks, reduce the controller's logic, and keep everything decoupled (though having the ID going around might not be that decoupled).</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:10pt;font-family:'Courier New'\" lang=EN-US>&nbsp;</span><span style=\"font-size:10pt;font-family:'Courier New'\" lang=EN-US>&nbsp;</span><span style=\"\" lang=EN-US></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>Hope it helps!</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\"><span style=\"\" lang=EN-US>&nbsp;</span></span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-size:small\"><span style=\"font-family:Calibri\">Matias Bonaventura</span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><a href=\"http://blogs.southworks.net/\"><span style=\"font-size:small;font-family:Calibri\">http://blogs.southworks.net/matiasb</span></a></p>",
    "PostedDate": "2009-06-11T11:11:02.633-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "201429",
    "ThreadId": "59035",
    "Html": "<p>Hi, Matias!</p>\r\n<p>You understood my scenario exactly. I'm registering presenters with<strong>&nbsp;ContainerControlledLifetimeManager </strong>inside a RegisterType method, so I don't care about the third drawback. but at the same time you are right the Resolve method will create a new instance of the presenter if it wasn't resolved before. I'm really wanted to decrease of code lines processing the back event at the one place of code, because another team persons will be create presenters and with this approach they should't care about handlig the event. I estimated the pros and cons and now &nbsp;using your way.</p>\r\n<p>Thank you for your justification advice. It's really helped.</p>",
    "PostedDate": "2009-06-14T21:49:22.143-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]