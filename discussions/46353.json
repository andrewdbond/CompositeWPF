[
  {
    "Id": "154833",
    "ThreadId": "46353",
    "Html": "<div>Hello,</div><div><br></div><div>What are some ideas or guidance for the best practice when doing things that require user input in the below example.</div><div><br></div><div>Say you have a RemoveCommand on the presenter that needed to ask the user &quot;Are you sure you want to do this?&quot; (Ok, Cancel...) With the view's xaml RemoveButton bound directly to the presentation class's RemoveCommand. You can't put a MessageBox.Show(&quot;Are You Sure&quot;) in the Presentaion.RemovComand because the testability of the remove command will become difficult.</div><div><br></div><div>Does this mean all presentation classes that need this functionality should take a dependency on something like...</div><div><br></div><div><div>public interface IMessageBoxService</div><div>{</div><div><span style=\"white-space:pre\">\t</span>MessageBoxResult Show(string messageBoxText);</div><div><span style=\"white-space:pre\">\t</span>MessageBoxResult Show(string messageBoxText, string caption, MessageBoxButton button);</div><div>}</div></div><div><br></div><div>Where during test you can mock the message box functionality? What is the guidance in this scenario?</div><div><br></div><div><br></div><div>OR</div><div><br></div><div>Is it not the responsibility of the Presentation class to ask the user for this input, it should be asked before the command executes, meaning the xaml binds to a view level method that does the validatoin and then calls the model's command? </div><div><br></div><div>Some issues I see with that option are:</div><div>1. the interaction isn't very testable</div><div>2. what if you had mounds of business logic before the question was asked? You'd be forced to put that logic in the code behind which violates the benifit of the seperation of concerns to begin with.</div><div><br></div><div>Any thoughts?</div><div><br></div>",
    "PostedDate": "2009-02-05T14:00:39.687-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "155360",
    "ThreadId": "46353",
    "Html": "<p>Using an injected MessageBox service is a good decoupled approach. Jeremy Miller (<a href=\"http://www.codebetter.com/blogs/jeremy.miller\">www.codebetter.com/blogs/jeremy.miller</a>) has done a post on this &quot;humble dialog&quot; method. Another possibility if you are passing in an IView is to have the method be on the view itself. Both are testable, though the sevice is a bit more decoupled.<br>\r\n<br>\r\nThere are other options using property databinding and commands, but they start to get more hokey, this is the cleanest in my exprience.</p>\r\n<p>Glenn </p>\r\n",
    "PostedDate": "2009-02-07T11:09:08.81-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "155374",
    "ThreadId": "46353",
    "Html": "Thanks Glen.<div><br></div><div>I will stick with the IMessageBoxService.</div><div><br></div><div>It seems more readable and if I choose to create a more sylish wpf message box to use throughout the app I can do so without having to change many other places.</div>",
    "PostedDate": "2009-02-07T12:03:56.09-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "155499",
    "ThreadId": "46353",
    "Html": "I'm with Glenn and have done the message box service approach before myself. The only counter argument is that if it might make sense to make that prompting part of the view itself (i.e. one that can be styled/templated and made pretty as part of the embedded user experience), then I would have an interface-based call back to the view that could be stubbed out instead and let the view implementation decide what the right way to present that prompt is. It is being done within the visual context of the view after all, and it is the view's responsibility to decide what appropriate rendered content is for a given piece of functionality.\r\n",
    "PostedDate": "2009-02-08T03:55:34.313-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "155550",
    "ThreadId": "46353",
    "Html": "I'm with Bryan on this one.  I just had to do this a couple days ago, in fact, and the approach I took was to define an interface specific to the particular prompt that I needed to perform.  In my case, we have no desire for the prompt to be asynchronous, so we did it like so:<br>\r\n<br>\r\ninterface IPromptForContinueOfOperationXXX<br>\r\n{<br>\r\n    bool PromptForContinue(...);<br>\r\n}<br>\r\n<br>\r\nwhere XXX is the specific operation I'm prompting for, and ... is any context arguments that represent context of the particular callback.  Then, I inject this interface onto my presentation model and provide the implementation in my view.  Under test, I just fake this (or mock it) to return the value I expect.<br>\r\n<br>\r\nI do the &quot;specific interface&quot; so that the callee can decide how to visualize the prompt (and can handle remembering 'saved answers' (i.e. the user clicked the check box that says &quot;don't ask me again&quot;) and whatever else the UI should know about that I don't care about the presentation model knowing).\r\n",
    "PostedDate": "2009-02-08T09:38:57.347-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "155659",
    "ThreadId": "46353",
    "Html": "I'm not seeing the <span style=\"color:rgb(48, 51, 45);font-family:'segoe ui';font-size:13px\">IPromptForContinueOfOperationXXX </span>idea all that much different from the IMessageBoxService that I have above. Althought one thing I like about your idea is not being coupled to the MessageBoxResult.<div><br></div><div>I could see some small value in having more generic prompts where we don't have to go...</div><div><br></div><div>if( _promptUserToContinueService.Show(...) == MessageBoxResult.Ok)...</div><div><br></div><div>Instead we could just</div><div><br></div><div><div>if( _promptUserToContinueService.Show(...))...</div><div><br></div></div><div>The symantic difference is small, but I like it a little more.</div>",
    "PostedDate": "2009-02-08T20:04:06.23-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "155850",
    "ThreadId": "46353",
    "Html": "The difference is in who decides the 'content' of the messagebox.  In the &quot;IPromptForContinueOfOperationXXX&quot;, the contents of the dialog are determined by the object providing the service (with the exception of any parameters it needs to receive in order to properly display the dialog, which would be the arguments to the Show method).  In the IMessageBoxService approach, the 'content' of the message box is defined by the view model/presentation model.  I am not sure exactly where I stand on this, but currently I prefer to have the contents of the message box defined by the view, not the model.<br>\r\n<br>\r\nAgain, I'm not sure where the details really belong for the contents of the dialog, but I currently prefer them in the view, that way when my UI users say &quot;I'd really rather this dialog read 'xxx' here and 'yyy' there&quot; I can just move around the static text blocks (possibly filled by resource strings if needing localization), without having to modify the model.  Others could argue that this should be testable code (i.e. providing the 'contents' of the dialog) and thus should not be determined by the service but rather the caller.  I'm not convinced of the value of testing these sorts of things yet, so I prefer the former.<br>\r\n<br>\r\nKelly\r\n",
    "PostedDate": "2009-02-09T09:28:30.82-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "157275",
    "ThreadId": "46353",
    "Html": "Hello,<br>\r\n<br>\r\nI had to solve this problem recently. Take for example a detail window that is bound to some business object (in my case a CSLA object). If the user attempts to close the window before saving their edits they should be prompted. 'Are you sure you want to close?'. I solved this the most simple way I could. I put a method on my IEditiableView called 'PromptForContinue(IDialogInfo)'. In my PresentationModel object I simply call this methods when the CloseViewCommand is executed. I am able to test this just fine and it is fairly decoupled.<br>\r\n<br>\r\nBrette21\r\n",
    "PostedDate": "2009-02-12T20:13:27.68-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "190377",
    "ThreadId": "46353",
    "Html": "<p>I was looking for a solution to this problem as well. It seems that there are three aspects to this problem. The first is whether or not a specific&nbsp;command has the capability to be cancelled, the&nbsp;second is the determination of when the client/user should be&nbsp;prompted and the third is how to present the prompt to the client/user. Because the presentation model&nbsp;represents both the structural model as well as the behavioral model of the use case,&nbsp;it seems that the first two aspects of the problem&nbsp;should be completely defined by the presentation model and the third should be defined by the view (and of course the view could optionally use a centralized message box service).</p>\r\n<p>With this in mind, my solution was to simply extend the ICommand interface and create an ICancelableCommand that exposes a cancel event that&nbsp;should be&nbsp;executed by the Execute method of the ICommand. By doing this any object that has a reference to the presentation model (i.e. the View)&nbsp;can elect to handle the cancel event and prompt however is appropriate and set the CancelEventArgs.Cancel property if necessary. This also nicely encapsulates the behavior (capability/prompt timing)&nbsp;within the command itself and does not couple the entire&nbsp;presentation model to some special IPromptForContinueOfOperationXXX interface.</p>\r\n<p><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">public</span></span><span style=\"font-size:x-small\"> </span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">interface</span></span><span style=\"font-size:x-small\"> </span><span style=\"font-size:x-small;color:#2b91af\"><span style=\"font-size:x-small;color:#2b91af\">ICancelableCommand</span></span><span style=\"font-size:x-small\"> : </span><span style=\"font-size:x-small;color:#2b91af\"><span style=\"font-size:x-small;color:#2b91af\">ICommand<br></span></span><span style=\"font-size:x-small\">{<br></span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">&nbsp;&nbsp;&nbsp; event</span></span><span style=\"font-size:x-small\"> </span><span style=\"font-size:x-small;color:#2b91af\"><span style=\"font-size:x-small;color:#2b91af\">CancelEventHandler </span></span><span style=\"font-size:x-small\">Executing;<br>}</span></p>\r\n<p><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">public</span></span><span style=\"font-size:x-small\">&nbsp;</span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">interface</span></span><span style=\"font-size:x-small\"> </span><span style=\"font-size:x-small;color:#2b91af\"><span style=\"font-size:x-small;color:#2b91af\">ISomePresentationModel<br></span></span><span style=\"font-size:x-small\">{<br></span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">&nbsp;&nbsp;&nbsp; </span></span><span style=\"font-size:x-small;color:#2b91af\"><span style=\"font-size:x-small;color:#2b91af\">ICancelableCommand</span></span><span style=\"font-size:x-small\"> CloseCommand { </span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">get</span></span><span style=\"font-size:x-small\">;&nbsp;</span><span style=\"font-size:x-small\">}<br></span>}</p>\r\n<p><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">public</span></span><span style=\"font-size:x-small\"> </span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">class</span></span><span style=\"font-size:x-small\"> </span><span style=\"font-size:x-small;color:#2b91af\"><span style=\"font-size:x-small;color:#2b91af\">SomeView<br></span></span><span style=\"font-size:x-small\">{<br></span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">&nbsp;&nbsp;&nbsp; public</span></span><span style=\"font-size:x-small\"> </span><span style=\"font-size:x-small;color:#2b91af\"><span style=\"font-size:x-small;color:#2b91af\">ISomePresentationModel</span></span><span style=\"font-size:x-small\"> Model<br><span style=\"color:#0000ff\">&nbsp;&nbsp;&nbsp; </span>{<br></span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get</span></span><span style=\"font-size:x-small\"> {&nbsp;</span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">. . .</span></span><span style=\"font-size:x-small\">&nbsp;}<br></span><span style=\"font-size:x-small\"><span style=\"font-size:x-small;color:#0000ff\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set<br></span></span><span style=\"font-size:x-small\"><span style=\"color:#0000ff\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<span style=\"color:#0000ff\">&nbsp;&nbsp;&nbsp;&nbsp;. . .<br><span style=\"color:#008000\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This of course could be bound in XAML</span></span></span><span style=\"font-size:x-small\"><br><span style=\"color:#0000ff\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value</span>.CloseCommand.Executing += CloseCommand_Executing;<br><span style=\"color:#0000ff\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<br><span style=\"color:#0000ff\">&nbsp;&nbsp;&nbsp; </span>}<br><br></span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">&nbsp;&nbsp;&nbsp; void</span></span><span style=\"font-size:x-small\"> CloseCommand_Executing(</span><span style=\"font-size:x-small;color:#0000ff\"><span style=\"font-size:x-small;color:#0000ff\">object</span></span><span style=\"font-size:x-small\"> sender, </span><span style=\"font-size:x-small;color:#2b91af\"><span style=\"font-size:x-small;color:#2b91af\">CancelEventArgs</span></span><span style=\"font-size:x-small\"> e)<br><span style=\"color:#0000ff\">&nbsp;&nbsp;&nbsp; </span>{<br></span><span style=\"font-size:x-small;color:#008000\"><span style=\"font-size:x-small;color:#008000\"><span style=\"color:#0000ff\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// Prompt and optionally set e.Cancel = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This of course could be entirely handled&nbsp;in XAML :)</span></span><span style=\"font-size:x-small;color:#008000\"><span style=\"font-size:x-small;color:#008000\"><br></span></span><span style=\"font-size:x-small\"><span style=\"color:#0000ff\">&nbsp;&nbsp;&nbsp; </span>}<br>}</span></p>\r\n<p><span style=\"font-size:x-small\">Doug</span></p>",
    "PostedDate": "2009-05-14T11:18:06.427-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]