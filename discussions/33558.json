[
  {
    "Id": "111200",
    "ThreadId": "33558",
    "Html": "I'm playing around with using the ConfigurationModuleEnumerator.<br>\r\n<br>\r\nFor some reason, I can only seem to get the modules loaded properly if I give the assemblyFile tag the absolute path. If I give it a relative path (with &quot;..&quot; in it) it doesn't seem to be found. Also, the moduleType tag requires the complete namespace. Is this intended?<br>\r\n<br>\r\nIt seems odd that both moduleType and moduleName are both required. In the module, by default, moduleName is the same as moduleType, so you have to duplicate yourself in the configuration. If the ModuleName attribute is used, then I can see using moduleName but then not needing moduleType anymore. I can see an agrument for the requirement for having one of them, just not both. I can also see the argument for not needing either: just load all the classes that support the IModule interface. Any thoughts?<br>\r\n<br>\r\nThanks,<br>\r\nHarley<br>\r\n",
    "PostedDate": "2008-08-14T13:29:13.707-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "111928",
    "ThreadId": "33558",
    "Html": "Relative paths work - if you were to modify the QuickStarts / Modularity / ConfigurationModularity.sln and place the ModuleA, B, C and D DLL files into the bin folder (versus debug\\modules) the application will work.<br>\r\n<br>\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;<br>\r\n&lt;configuration&gt;<br>\r\n&nbsp; &lt;configSections&gt;<br>\r\n&nbsp;&nbsp;&nbsp; &lt;section name=&quot;modules&quot; type=&quot;Microsoft.Practices.Composite.Modularity.ModulesConfigurationSection, Microsoft.Practices.Composite&quot;/&gt;<br>\r\n&nbsp; &lt;/configSections&gt;<br>\r\n&nbsp; &lt;modules&gt;<br>\r\n&nbsp;&nbsp;&nbsp; &lt;module assemblyFile=&quot;../ModuleD.dll&quot; moduleType=&quot;ModuleD.ModuleD&quot; moduleName=&quot;ModuleD&quot;&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;dependencies&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;dependency moduleName=&quot;ModuleB&quot;/&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/dependencies&gt;<br>\r\n&nbsp;&nbsp;&nbsp; &lt;/module&gt;<br>\r\n&nbsp;&nbsp;&nbsp; &lt;module assemblyFile=&quot;../ModuleB.dll&quot; moduleType=&quot;ModuleB.ModuleB&quot; moduleName=&quot;ModuleB&quot;/&gt;<br>\r\n&nbsp;&nbsp;&nbsp; &lt;module assemblyFile=&quot;../ModuleA.dll&quot; moduleType=&quot;ModuleA.ModuleA&quot; moduleName=&quot;ModuleA&quot;&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;dependencies&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;dependency moduleName=&quot;ModuleD&quot;/&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/dependencies&gt;<br>\r\n&nbsp;&nbsp;&nbsp; &lt;/module&gt;<br>\r\n&nbsp;&nbsp;&nbsp; &lt;module assemblyFile=&quot;../ModuleC.dll&quot; moduleType=&quot;ModuleC.ModuleC&quot; moduleName=&quot;ModuleC&quot; startupLoaded=&quot;false&quot;/&gt;<br>\r\n&nbsp; &lt;/modules&gt;<br>\r\n&lt;/configuration&gt;<br>\r\n<br>\r\nAs for the moduleType and moduleName it becomes apparent by the above the importance of the distinction, particularly since the type typically includes the namespace.<br>\r\n<br>\r\nAs for your argument for just loading all classes that support IModule, it is an argument won :) because it is incorporated and available - you can run the DirectoryLookupModularity solution (a peer to the ConfigurationModularity solution).&nbsp;&nbsp; I also blog about it <a href=\"http://www.global-webnet.net/BlogEngine/post/2008/08/04/CompositeWPF-using-Module-configuration-files-for-resolving-types.aspx\">HERE</a>.&nbsp; <br>\r\n<br>\r\n<br>\r\n<br>\r\n",
    "PostedDate": "2008-08-18T18:33:48.187-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "112097",
    "ThreadId": "33558",
    "Html": "<em>Relative paths work - if you were to modify the QuickStarts /\r\nModularity / ConfigurationModularity.sln and place the ModuleA, B, C\r\nand D DLL files into the bin folder (versus debug\\modules) the\r\napplication will work.</em><br>\r\n<br>\r\nI must have had a typo, they're working for me now too.<br>\r\n<br>\r\n<em>As for the moduleType and moduleName it becomes apparent by the above\r\nthe importance of the distinction, particularly since the type\r\ntypically includes the namespace.</em><br>\r\n<br>\r\nI must be dense as I don't see the apparent need for it above. Are you referring to it's use by the dependency tags? If so, I see two solutions: 1) either the dependency tag could optionally support moduleType 2) or the moduleName on the module tag could be inferred by the type (everything after the last period), just like the compiler does. (There's no need for the ModuleName attribute, it's inferred by the type.)<br>\r\n<br>\r\n<em>As for your argument for just loading all classes that support IModule,\r\nit is an argument won :) because it is incorporated and available - you\r\ncan run the DirectoryLookupModularity solution (a peer to the\r\nConfigurationModularity solution).</em><br>\r\n<br>\r\nBut I still want to control which files get loaded, I just don't want to have to specify each module in the file. So I still want to have a configuration file with module tags, just without moduleType and moduleName.<br>\r\n<br>\r\n<em>I also blog about it <a href=\"http://www.global-webnet.net/BlogEngine/post/2008/08/04/CompositeWPF-using-Module-configuration-files-for-resolving-types.aspx\">HERE</a>.</em> <br>\r\n<br>\r\nI've been reading your blog before this; showed up in some Google\r\nsearches. Interesting and good stuff, thanks for taking the time to\r\nwrite.<br>\r\n<br>\r\n",
    "PostedDate": "2008-08-19T09:38:30.277-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "112533",
    "ThreadId": "33558",
    "Html": "<p>[hpebley3]&nbsp;&quot;I must be dense as I don't see the apparent need for it above.&quot;<br>\r\n<br>\r\nNo, not dense, outside of the context of&nbsp;a source code reference I guess it wouldn't make much sense.&nbsp;&nbsp; To clarify I'll use the DirectoryLookupModuleEnumerator.cs file - specifically the GetModulesInfos() method which returns a type of ModuleInfo[]; ModuleInfo is the core structure used by the ModuleLoader and dependent processes.<br>\r\n<br>\r\n-----[ excerpt from GetModuleInfos() ]------<br>\r\n<br>\r\nAssembly[] alreadyLoadedAssemblies = AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies();<br>\r\nvar modules = directory.GetFiles(&quot;*.dll&quot;)<br>\r\n&nbsp;&nbsp;&nbsp; .Where(file =&gt; alreadyLoadedAssemblies<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .FirstOrDefault(assembly =&gt; String.Compare(Path.GetFileName(assembly.Location), file.Name, StringComparison.OrdinalIgnoreCase) == 0) == null)<br>\r\n&nbsp;&nbsp;&nbsp; .SelectMany(file =&gt; <strong><span style=\"text-decoration:underline\">Assembly.ReflectionOnlyLoadFrom(file.FullName)<br>\r\n</span></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .GetExportedTypes()<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Where(IModuleType.IsAssignableFrom)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Where(t =&gt; t != IModuleType)<br>\r\n<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"text-decoration:underline\"> .Select(type =&gt; CreateModuleInfo(type)));</span></strong></p>\r\n<p>var array = modules.ToArray();<br>\r\nAppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve -= resolveEventHandler;<br>\r\nreturn array;</p>\r\n<p>---------------------------------------<br>\r\n<br>\r\nThe CreateModuleInfo(type) method is responsible for processing each type sent to it by Assembly.ReflectionOnlyLoadFrom() - if you examine the code you'll see it parses the information and instantiates a ModuleInfo from it.&nbsp; The end result is that &quot;var array&quot; will contain an array of ModuleInfo.<br>\r\n<br>\r\nI processed a solution that has a single module (VisioToolModule) - a breakpoint after &quot;var array = modules.ToArray()&quot; results in the following:<br>\r\n<br>\r\n- array&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {Microsoft.Practices.Composite.Modularity.ModuleInfo[1]}&nbsp;&nbsp;&nbsp;&nbsp; Microsoft.Practices.Composite.Modularity.ModuleInfo[]<br>\r\n&nbsp;&nbsp;&nbsp;- &nbsp;[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {Microsoft.Practices.Composite.Modularity.ModuleInfo}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Microsoft.Practices.Composite.Modularity.ModuleInfo<br>\r\n&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AssemblyFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;D:\\\\GWN\\\\MainShell\\\\bin\\\\Debug\\\\VisioToolModule.dll&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DependsOn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;Count =&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{System.Collections.Generic.List&lt;string&gt;}<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;ModuleName&nbsp;&nbsp;&nbsp;&nbsp; &quot;VisioToolModule&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;ModuleType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;ProcessSolutionModule.VisioToolModule&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;StartupLoaded&nbsp;&nbsp;&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool<br>\r\n<br>\r\nIf you'll review the ModuleLoader code you'll find that it uses each of the above ModuleInfo properties in different ways (beyond the scope of this message but somewhat apparent).&nbsp; Bear in mind that your AssemblyFile (ddl name) may not match your ModuleName, i.e., I renamed my VisioToolModule to VisioToolModule1 the results follow:<br>\r\n<br>\r\n- array&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {Microsoft.Practices.Composite.Modularity.ModuleInfo[1]}&nbsp;&nbsp;&nbsp;&nbsp; Microsoft.Practices.Composite.Modularity.ModuleInfo[]<br>\r\n&nbsp;&nbsp;&nbsp;- &nbsp;[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {Microsoft.Practices.Composite.Modularity.ModuleInfo}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Composite.Modularity.ModuleInfo<br>\r\n&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AssemblyFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;D:\\\\GWN\\\\MainShell\\\\bin\\\\Debug\\\\VisioToolModule.dll&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DependsOn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;Count = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {System.Collections.Generic.List&lt;string&gt;}<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;ModuleName&nbsp;&nbsp;&nbsp;&nbsp; &quot;VisioToolModule1&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;ModuleType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;ProcessSolutionModule.VisioToolModule1&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;StartupLoaded&nbsp;&nbsp;&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool<br>\r\n<br>\r\nWith the notion that&nbsp;the ModuleType could have been a very long namespace it is understandable that the ModuleName (which is used as a key throughout the ModuleLoader process) is parsed from the ModuleType (class name).<br>\r\n<br>\r\n---<br>\r\n<br>\r\n[hpebley3]&nbsp;&quot;But I still want to control which files get loaded, I just don't want to have to specify each module in the file. So I still want to have a configuration file with module tags, just without moduleType and moduleName.&quot;<br>\r\n<br>\r\nFrom my reflection days I know that you'll need the filename to load the assembly and to instantiate a type (dynamically) you'll need the complete namesspace (to include class name); this locks you into providing at least those two parameters; I don't think you can get away from loading a class dynamically without these...&nbsp;If you search the ModuleLoader.cs code for moduleName you'll find it uses it as a key for multiple processes/purposes. &nbsp;I do see where moduleName could be dropped but in every instance where you see it being used (throughout the various classes) you would have to either use the ModuleType as a key or parse it for the key - which could amount to a lot of unnecessary processing.<br>\r\n<br>\r\nIn my humble opinion the P&amp;P team did an efficient job in providing an extensible ModuleLoading process.</p>\r\n",
    "PostedDate": "2008-08-20T21:05:31.92-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]