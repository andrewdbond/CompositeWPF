[
  {
    "Id": "1018763",
    "ThreadId": "437472",
    "Html": "A question on the implementation of <code>SelectorItemsSourceSyncBehavior</code>:\r<br />\n<br />\n<em>Why is the collection Selector.Items &quot;manually&quot; kept in sync with the observable collection this.Region.Views?</em>\r<br />\n<br />\nWhy isn't the <code>Selector.ItemsSource</code> simply bound to that collection?\r<br />\n<br />\nI did the following change in the <code>OnAttach</code> method:<br />\n<pre><code>protected override void OnAttach()\n        {\n...\n            //this.SynchronizeItems();\n...\n            //this.Region.Views.CollectionChanged += this.Views_CollectionChanged;\n            this.hostControl.SetBinding(Selector.ItemsSourceProperty, new Binding { Source = this.Region.Views });\n        }</code></pre>\n\nThis results in one failing unit test: AddingViewToTwoRegionsThrows:<br />\n<blockquote>\nTest method Microsoft.Practices.Prism.Tests.Regions.Behaviors.SelectorItemsSourceSyncRegionBehaviorFixture.AddingViewToTwoRegionsThrows did not throw expected exception System.InvalidOperationException.<br />\n</blockquote>\nThe reason is that the (dummy) <code>Button</code> in the test is now not actually added a visual tree.<br />\n<h2>Why am I even investigating this?</h2>\nI would like the views in a <code>TabControl</code> to only <code>Load</code> at the moment the tab gets activated\r<br />\n(and unload when the <code>TabItem</code> gets un-selected).\r<br />\nThis works well when binding an observable collection of Views to the <code>ItemsSource</code>.\r<br />\nWhen manually adding and removing the Views in the actual <code>Items</code> collection, <em>all</em> <code>TabItems</code> get loaded when the <code>TabControl</code> gets Loaded.\r<br />\nActions during the <code>OnLoaded</code> of the Views are thus executed too early.\r<br />\nThis also results in an unpredictable sequence of <code>Loaded</code> and <code>Unloaded</code> events: activating an inactive <code>TabItem</code>, loads it twice without ever being unloaded in between.\r<br />\n<br />\nI'm considering overriding this implementation with our own, using MEF.\r<br />\nAnyone strongly advising against this?\r<br />\n<br />\nThanks in advance!\r<br />\njan<br />\n",
    "PostedDate": "2013-03-21T03:54:13.757-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1019154",
    "ThreadId": "437472",
    "Html": "Hi Jan,\r<br />\n<br />\nAs far as I know, the <strong>Prism</strong> library was designed so that significant components of it could be extended or replaced to fit the functionality required in your application. Taking this into account, there is no advice against replacing the <strong>SelectorItemsSourceSyncBehavior</strong>.\r<br />\n<br />\nRegarding the implementation of directly mapping the <strong>ItemsSource</strong> to the <strong>Views</strong> collection, this is the approach used for regions defined in <strong>ItemsControls</strong>. The difference between a region in a <strong>Selector</strong> and in an <strong>ItemsControl</strong> is that the latest one does not need to synchronize the active view with the control (because all views are considered as active.) This might be the reason behind the difference between the two approaches.\r<br />\n<br />\nI am not aware of how much you have customized you behavior, but take into account that besides mapping the <strong>ItemsSource</strong> to the <strong>Views</strong> collection you will also need to keep in sync the region's active view and the control's selected item manually (including the deactivation of non selected views in the region).\r<br />\n<br />\nAlso, based on my understanding, I believe that data binding can swallow exceptions. Hence, the failing test could be related to this.\r<br />\n<br />\nRegards,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-03-21T13:28:03.11-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1019363",
    "ThreadId": "437472",
    "Html": "Thanks for the reply and pointing me to the active view!<br />\n<br />\nAs far as I can see,  the synchronization of the <code>SelectedItem</code> and <strong>active view</strong> is handled separately from the synchronization of the actual <code>Items</code> collection and <strong>Views</strong>.<br />\n<br />\nIn <code>SelectorItemsSourceSyncBehavior.OnAttach()</code> the first is handled by these 2 subscriptions <br />\n<pre><code>this.hostControl.SelectionChanged += this.HostControlSelectionChanged;\nthis.Region.ActiveViews.CollectionChanged += this.ActiveViews_CollectionChanged;</code></pre>\n\nwhile the second is handled by these 2 calls:<br />\n<pre><code>this.SynchronizeItems();\n...\nthis.Region.Views.CollectionChanged += this.Views_CollectionChanged;</code></pre>\n\nI see no reason why the second cannot be solved using a binding.<br />\n<br />\nI intend to modify the behavior only with respect to the second synchronisation of the actual <code>Items</code> collection and <strong>Views</strong>.<br />\nIn fact my implementation is just a copy of the Prism's own 'SelectorItemsSourceSyncBehavior' (including the Copyright), with the modifications listed in my first post.<br />\n<br />\n<strong>EDIT:</strong> Unfortunately <code>SelectorRegionAdapter.AttachBehaviors</code> references <code>new SelectorItemsSourceSyncBehavior()</code> (line 61) directly, so I'll have to replace the default 'SelectorRegionAdapter' as well.<br />\n<br />\njan<br />\n<br />\n<br />\nPS: For completeness, this is my <code>OnAttach()</code> method:<br />\n<pre><code>    protected override void OnAttach()\n    {\n      bool itemsSourceIsSet = this.hostControl.ItemsSource != null;\n#if !SILVERLIGHT\n      itemsSourceIsSet = itemsSourceIsSet || (BindingOperations.GetBinding(this.hostControl, ItemsControl.ItemsSourceProperty) != null);\n#endif\n      if (itemsSourceIsSet)\n      {\n        throw new InvalidOperationException(Resources.ItemsControlHasItemsSourceException);\n      }\n\n      this.hostControl.SelectionChanged += this.HostControlSelectionChanged;\n      this.Region.ActiveViews.CollectionChanged += this.ActiveViews_CollectionChanged;\n\n      this.hostControl.SetBinding(Selector.ItemsSourceProperty, new Binding { Source = this.Region.Views });\n    }</code></pre>\n\n",
    "PostedDate": "2013-03-22T01:39:20.91-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]