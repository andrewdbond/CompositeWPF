[
  {
    "Id": "422372",
    "ThreadId": "206954",
    "Html": "<p>Hello</p>\r\n<p>I have a question that I am hoping the community can help me resolve...</p>\r\n<p>My shell application is comprised of a &quot;MainRegion&quot; which is visually represented by a TabControl. The TabControl's two TabItems are each populated by instances of views from two separate modules (let's call them ModuleOne and ModuleTwo). In a separate module, (let's call this one TreeModule) I have a TreeControl view and all the necessary logic to fill the tree view with data.</p>\r\n<p>I would like the views from ModuleOne and ModuleTwo to each display an instance of the TreeModule&rsquo;s view. I have declared a Region (inside a ContentControl) in each of the views of ModuleOne and ModuleTwo. This is where I would like to load an instance of TreeModule view. My question is about the proper way to accomplish this.</p>\r\n<p>My requirement is to maintain a clear separation between the TreeModule the other Modules (I believe the TreeModule should be reusable for future applications).</p>\r\n<p>I have started by creating a scoped region manager in the Initialization method of ModuleOne and ModuleTwo.&nbsp; It seems that I now need to add an instance of the TreeModule's view to the proper region within the scoped region manager(s).</p>\r\n<p><strong>How can I do this without directly referencing the TreeModule from within ModuleOne and ModuleTwo?</strong> In order to resolve using the Unity, I would need to at least have access to the view's interface. I have considered adding the Interface for the view to the common infrastructure project. Then I could use it to resolve using the container. <strong>Would</strong> <strong>this be the correct solution?</strong></p>\r\n<p>Also, in many of the examples I have seen online, modules (like my TreeModule) often add themselves to regions within the injected RegionManager. In my current situation, this causes an error as the Shell&rsquo;s Region Manager does not have a named region for the Tree View (because the views within the TabItems do). This leads me to believe I should be registering the scoped region managers and injecting those into the TreeModule? However, that seems incorrect as well because I believe the application should have only 1 instance of the module.</p>\r\n<p>I am confused! Any help will be really appreciated.</p>\r\n<p>---Edit---</p>\r\n<p>Here is a code snippet of the Init Method for ModuleOne (variable names changed for simplicity)</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Green\">// ModuleOne's Init Logic </span>\r\n<span style=\"color:Green\">//(ModuleOne's view represents one TabItem in a TabControl)</span>\r\n_container.RegisterType&lt;ISomeModel, SomeModel&gt;(<span style=\"color:Blue\">new</span> ContainerControlledLifetimeManager());\r\n_container.RegisterType&lt;ISomeViewModel, SomeViewModel&gt;();\r\n_container.RegisterType&lt;ISomeView, SomeView&gt;();\r\n\r\n<span style=\"color:Blue\">var</span> mainView = _container.Resolve&lt;ISomeView&gt;();\r\n\r\n<span style=\"color:Green\">// this sets the datacontext of the view to the viewmodel</span>\r\nmainView.ApplyModel(_container.Resolve&lt;ISomeViewModel&gt;());\r\n\r\n<span style=\"color:Green\">// add to main region and create a scoped region manager for the nested regions</span>\r\nIRegionManager scopedRegionManager = \r\n    _regionManager.Regions[<span style=\"color:#A31515\">&quot;MainRegion&quot;</span>].Add(mainView, <span style=\"color:Blue\">null</span>, <span style=\"color:Blue\">true</span>);\r\n\r\n<span style=\"color:Green\">// adding treeview to scoped region <br>// I have to directly reference the TreeModule in ModuleOne to get these </span>\r\n<span style=\"color:Green\">// types and that seems like too much coupling</span>\r\n<span style=\"color:Blue\">var</span> scopedTreeView = _container.Resolve&lt;ITreeView&gt;();\r\nscopedTreeView.ApplyModelITreeViewModel&gt;());\r\nscopedRegionManager.AddToRegion(<span style=\"color:#A31515\">&quot;TreeView&quot;</span>, scopedTreeView);\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-03-22T20:44:07.293-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "423301",
    "ThreadId": "206954",
    "Html": "<p>Hi,</p>\r\n<p>The usual approach followed in modular applications is that modules register only their own views into regions. This is done to avoid breaking the decoupling between modules, as for example if <strong>ModuleOne</strong> knows about <strong>TreeModule&rsquo;s</strong> views they become dependent on each other (if <strong>TreeModule</strong> isn&rsquo;t there, then <strong>ModuleOne</strong> cannot work).</p>\r\n<p>As you said, you would get an error if you tried to add the <strong>TreeView</strong> to the application&rsquo;s <strong>RegionManager</strong>, as the region you want to register it in is in another <strong>RegionManager</strong>. The approach you suggested about registering the scoped <strong>RegionManager</strong> instances is the one I would follow. <a href=\"http://blogs.southworks.net/gmaliandi/\">Guido Maliandi</a> talks about how to achieve that in <a href=\"http://compositewpf.codeplex.com/Thread/View.aspx?ThreadId=205211\">this forum thread</a>.</p>\r\n<p>You can then resolve the <strong>RegionManager </strong>instance required and use <a href=\"http://msdn.microsoft.com/en-us/library/dd458899.aspx\">View Injection</a> to add the <strong>TreeView</strong> to the necessary region.</p>\r\n<p style=\"margin-top:1em;margin-bottom:1em\">Please let me know if this helps.</p>\r\n<p style=\"margin-top:1em;margin-bottom:1em\">Damian Schenkelman<br><a style=\"text-decoration:underline;color:#3e62a6\" href=\"http://blogs.southworks.net/dschenkelman\">http://blogs.southworks.net/dschenkelman</a></p>",
    "PostedDate": "2010-03-24T16:30:38.333-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "423744",
    "ThreadId": "206954",
    "Html": "<p>Damian</p>\r\n<p>Thank you for helping me out with these concepts! The information definitely helps, but I am left with an additional question; please allow me to explain...</p>\r\n<p>In both ModuleOne and ModuleTwo's Initialize, I will go ahead and register named, scoped Region Managers with Unity:</p>\r\n<p>(ModuleOne - Initialize)</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>IRegionManager modOneScopedRegionManager =\r\n    _regionManager.Regions[<span style=\"color:#A31515\">&quot;MainRegion&quot;</span>].Add(mainView, <span style=\"color:Blue\">null</span>, <span style=\"color:Blue\">true</span>);\r\n\r\n<span style=\"color:Blue\">this</span>._container.RegisterInstance&lt;IRegionManager&gt;(<span style=\"color:#A31515\">&quot;ModOneRegionManager&quot;</span>, modOneScopedRegionManager);\r\n</pre>\r\n</div>\r\n<p>(ModuleTwo - Initialize)</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>IRegionManager modTwoScopedRegionManager =<br>    _regionManager.Regions[<span style=\"color:#A31515\">&quot;MainRegion&quot;</span>].Add(mainView, <span style=\"color:Blue\">null</span>, <span style=\"color:Blue\">true</span>);<br><br><span style=\"color:Blue\">this</span>._container.RegisterInstance&lt;IRegionManager&gt;(<span style=\"color:#A31515\">&quot;ModTwoRegionManager&quot;</span>, modTwoScopedRegionManager);<br><br></pre>\r\n</div>\r\n<p>However, I am confused as to where in the hierarchy I could resolve the named RegionManager instance(s) and get those injected into something from the TreeModule that would provide me a view instance. Currently, my TreeModule is being loaded &quot;WhenAvailable&quot; by Prism and the TreeModule's Initialize method is receiving the app's main region manager.</p>\r\n<p>I guess one possible approach could be to publish an event (using EventAggregator) in ModuleOne/Two's Initialize. The event would have a payload consisting of the scoped RegionManager. If the TreeModule were subscribed to this event, it could do the view injection in the handler.</p>\r\n<p>Would this be a good approach and thanks again Damian for your time!</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-03-25T12:58:52.197-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "424662",
    "ThreadId": "206954",
    "Html": "<p>For anyone else who has encountered this issue, I found another thread that seemed to validate the method I discuss above regarding the EventAggregator: <a href=\"http://compositewpf.codeplex.com/Thread/View.aspx?ThreadId=62400\"></a></p>\r\n<p><a href=\"http://compositewpf.codeplex.com/Thread/View.aspx?ThreadId=62400\">http://compositewpf.codeplex.com/Thread/View.aspx?ThreadId=62400</a></p>\r\n<p>&nbsp;</p>\r\n<p>The answer I was looking for was provided by <a id=\"ctl00_ctl00_MasterContent_Content_PostRepeater_ctl02_UserNameLink\" href=\"http://www.codeplex.com/site/users/view/dschenkelman\">dschenkelman:</a></p>\r\n<p><em>When two modules reference each other, they are very tight coupled  which goes against the modularity guidance. Think of it as if you were  to completely remove a module from your application, it should still  work. It would not have full functionality, but no changes would be  required (except modules to be loaded, of course). </em></p>\r\n<p><em>Take into account that the <strong>Quickstart</strong> application&rsquo;s  objective is showing a particular feature or capability of the guidance,  in the simplest way possible. A good approach for this situation could  be firing an event using <a href=\"http://msdn.microsoft.com/en-us/library/dd458915.aspx\">EventAggregator</a> (to communicate between modules), so when the new view has to be  injected the module that has it can be notified by the module where the  action is initiated. As you can see, this approach would have mixed  EventAggregation with UIComposition, thus missing the important point of  the <strong>Quickstart</strong>.</em></p>\r\n<p>So, thanks again Damian!!</p>\r\n<p>Rob</p>",
    "PostedDate": "2010-03-28T11:42:39.437-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]