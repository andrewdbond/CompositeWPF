[
  {
    "Id": "114090",
    "ThreadId": "34368",
    "Html": "Hi there,<br>\r\nCurrently, i'm using <strong>DirectoryLookupModuleEnumerator</strong> for asm loading. The problem arise when I duplicate a dll in my plugin directory.<br>\r\n<strong>The error is:</strong> &quot;File load exception: API restriction: The assembly 'file:///D:\\Visual Studio 2008\\Projects\\WestSoft7\\WestSoft7\\bin\\Debug\\Plugin\\testComposeUIModule.dll' has already loaded from a different location. It cannot be loaded from a new location within the same appdomain.&quot;<br>\r\n<br>\r\n<strong>Stack trace:</strong><br>\r\n&quot;&nbsp;&nbsp; at System.Reflection.Assembly._nLoad(AssemblyName fileName, String codeBase, Evidence assemblySecurity, Assembly locationHint, StackCrawlMark&amp; stackMark, Boolean throwOnFileNotFound, Boolean forIntrospection)\\r\\n&nbsp;&nbsp; at System.Reflection.Assembly.nLoad(AssemblyName fileName, String codeBase, Evidence assemblySecurity, Assembly locationHint, StackCrawlMark&amp; stackMark, Boolean throwOnFileNotFound, Boolean forIntrospection)\\r\\n&nbsp;&nbsp; at System.Reflection.Assembly.InternalLoad(AssemblyName assemblyRef, Evidence assemblySecurity, StackCrawlMark&amp; stackMark, Boolean forIntrospection)\\r\\n&nbsp;&nbsp; at System.Reflection.Assembly.InternalLoadFrom(String assemblyFile, Evidence securityEvidence, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm, Boolean forIntrospection, StackCrawlMark&amp; stackMark)\\r\\n&nbsp;&nbsp; at System.Reflection.Assembly.ReflectionOnlyLoadFrom(String assemblyFile)\\r\\n&nbsp;&nbsp; at Microsoft.Practices.Composite.Modularity.DirectoryLookupModuleEnumerator.InnerModuleInfoLoader.&lt;&gt;c__DisplayClass12.&lt;GetModuleInfos&gt;b__e(FileInfo file) in C:\\\\ComposeUI\\\\Source\\\\CAL\\\\Composite\\\\Modularity\\\\DirectoryLookupModuleEnumerator.cs:line 180\\r\\n&nbsp;&nbsp; at System.Linq.Enumerable.&lt;SelectManyIterator&gt;d__14`2.MoveNext()\\r\\n&nbsp;&nbsp; at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\\r\\n&nbsp;&nbsp; at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\\r\\n&nbsp;&nbsp; at Microsoft.Practices.Composite.Modularity.DirectoryLookupModuleEnumerator.InnerModuleInfoLoader.GetModuleInfos(String path) in C:\\\\ComposeUI\\\\Source\\\\CAL\\\\Composite\\\\Modularity\\\\DirectoryLookupModuleEnumerator.cs:line 186\\r\\n&nbsp;&nbsp; at Microsoft.Practices.Composite.Modularity.DirectoryLookupModuleEnumerator.InnerModuleInfoLoader.GetModuleInfos(String path)\\r\\n&nbsp;&nbsp; at Microsoft.Practices.Composite.Modularity.DirectoryLookupModuleEnumerator.EnsureModulesDiscovered() in C:\\\\ComposeUI\\\\Source\\\\CAL\\\\Composite\\\\Modularity\\\\DirectoryLookupModuleEnumerator.cs:line 113\\r\\n&nbsp;&nbsp; at Microsoft.Practices.Composite.Modularity.DirectoryLookupModuleEnumerator.GetStartupLoadedModules() in C:\\\\ComposeUI\\\\Source\\\\CAL\\\\Composite\\\\Modularity\\\\DirectoryLookupModuleEnumerator.cs:line 71\\r\\n&nbsp;&nbsp; at Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.InitializeModules() in C:\\\\ComposeUI\\\\Source\\\\CAL\\\\Composite.UnityExtensions\\\\UnityBootstrapper.cs:line 174\\r\\n&nbsp;&nbsp; at Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.Run(Boolean useDefaultConfiguration) in C:\\\\ComposeUI\\\\Source\\\\CAL\\\\Composite.UnityExtensions\\\\UnityBootstrapper.cs:line 106\\r\\n&nbsp;&nbsp; at Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.Run() in C:\\\\ComposeUI\\\\Source\\\\CAL\\\\Composite.UnityExtensions\\\\UnityBootstrapper.cs:line 66\\r\\n&nbsp;&nbsp; at TinLong.Application..ctor() in D:\\\\Visual Studio 2008\\\\Projects\\\\WestSoft7\\\\WestSoft7\\\\Application.xaml.vb:line 8\\r\\n&nbsp;&nbsp; at TinLong.Application.Main() in D:\\\\Visual Studio 2008\\\\Projects\\\\WestSoft7\\\\WestSoft7\\\\obj\\\\Debug\\\\Application.g.vb:line 67\\r\\n&nbsp;&nbsp; at System.AppDomain._nExecuteAssembly(Assembly assembly, String[] args)\\r\\n&nbsp;&nbsp; at System.AppDomain.ExecuteAssembly(String assemblyFile, Evidence assemblySecurity, String[] args)\\r\\n&nbsp;&nbsp; at Microsoft.VisualStudio.HostingProcess.HostProc.RunUsersAssembly()\\r\\n&nbsp;&nbsp; at System.Threading.ThreadHelper.ThreadStart_Context(Object state)\\r\\n&nbsp;&nbsp; at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)\\r\\n&nbsp;&nbsp; at System.Threading.ThreadHelper.ThreadStart()&quot;<br>\r\n<br>\r\nAny suggestion? I want to detect if there is any error, this module loader just skip it, so my program could continue.<br>\r\n",
    "PostedDate": "2008-08-27T05:10:41.133-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "114100",
    "ThreadId": "34368",
    "Html": "<span style=\"text-decoration:underline\">More information on this error: when trying to debug, i've found where the error come from:</span><br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class InnerModuleInfoLoader : MarshalByRefObject<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [System.Diagnostics.CodeAnalysis.SuppressMessage(&quot;Microsoft.Performance&quot;, &quot;CA1822:MarkMembersAsStatic&quot;)]<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal ModuleInfo[] GetModuleInfos(string path)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DirectoryInfo directory = new DirectoryInfo(path);<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResolveEventHandler resolveEventHandler =<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delegate(object sender, ResolveEventArgs args)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Assembly loadedAssembly = AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies().FirstOrDefault(<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asm =&gt; string.Equals(asm.FullName, args.Name, StringComparison.InvariantCultureIgnoreCase));<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loadedAssembly != null)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return loadedAssembly;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AssemblyName assemblyName = new AssemblyName(args.Name);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string dependentAssemblyFilename = Path.Combine(directory.FullName, assemblyName.Name + &quot;.dll&quot;);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (File.Exists(dependentAssemblyFilename))<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Assembly.ReflectionOnlyLoadFrom(dependentAssemblyFilename);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Assembly.ReflectionOnlyLoad(args.Name);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve += resolveEventHandler;<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Assembly moduleReflectionOnlyAssembly =<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies().First(<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asm =&gt; asm.FullName == typeof(IModule).Assembly.FullName);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type IModuleType = moduleReflectionOnlyAssembly.GetType(typeof(IModule).FullName);<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Assembly[] alreadyLoadedAssemblies = AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>var modules = directory.GetFiles(&quot;*.dll&quot;)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Where(file =&gt; alreadyLoadedAssemblies<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .FirstOrDefault(assembly =&gt; String.Compare(Path.GetFileName(assembly.Location), file.Name, StringComparison.OrdinalIgnoreCase) == 0) == null)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .SelectMany(file =&gt; Assembly.ReflectionOnlyLoadFrom(file.FullName)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .GetExportedTypes()<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Where(IModuleType.IsAssignableFrom)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Where(t =&gt; t != IModuleType)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Select(type =&gt; CreateModuleInfo(type)));</strong> <span style=\"text-decoration:underline\">&lt;-- using dedug mode, this line of code make error</span><br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var array = modules.ToArray();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve -= resolveEventHandler;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return array;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\r\n",
    "PostedDate": "2008-08-27T05:29:27.26-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "114339",
    "ThreadId": "34368",
    "Html": "Hi,<br>\r\n<br>\r\nThe only option that works for solving these kind of conflicts is by implementing your own module enumerator that only prints a warning in the log and skips loading the module.<br>\r\nAlthough you could argue that the behavior of the directory module enumerator is a bit strange, it is correct because you normally don't want to load duplicate modules. <br>\r\n<br>\r\nCheckout the <a href=\"http://www.codeplex.com/compositewpfcontrib\">CompositeWPFContrib </a>project for a sample on how to build your own module enumerator, or check this weblog post on the <a href=\"http://blogs.infosupport.com/blogs/willemm/archive/2008/07/08/Combining-module-enumerators-in-CompositeWPF.aspx\">composite module enumerator.</a><br>\r\nIt contains a more elaborate description of how you can approach the problem.<br>\r\n<br>\r\nI hope this helps.<br>\r\n",
    "PostedDate": "2008-08-27T22:23:40.923-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "114576",
    "ThreadId": "34368",
    "Html": "Thanks for your replay, i'll check it out ;)<br>\r\n",
    "PostedDate": "2008-08-28T17:29:01.373-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]