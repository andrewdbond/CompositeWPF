[
  {
    "Id": "1068723",
    "ThreadId": "450108",
    "Html": "Hi,<br />\n<br />\nCan you create multiple <strong>NonShared</strong> <em>ViewModels</em> with a different name?  My problems is I have a composite view:<br />\n<pre><code>&lt;UserControl x:Class=&quot;Natsar.ODS.Documents.Spoken.SpokenView&quot;\n.\n..\n...\n&lt;Grid x:Name=&quot;LayoutContent&quot; HorizontalAlignment=&quot;Stretch&quot; VerticalAlignment=&quot;Stretch&quot;&gt;\n    &lt;Border Padding=&quot;5,5,5,5&quot; BorderBrush=&quot;#77000000&quot; BorderThickness=&quot;1,1,1,1&quot; Margin=&quot;0,0,0,5&quot; CornerRadius=&quot;12,12,12,12&quot; Width=&quot;Auto&quot;&gt;\n        &lt;ContentControl x:Name=&quot;FlowDocumentDetails&quot; Content=&quot;{Binding FlowDocumentDetails}&quot;&gt;\n            &lt;ContentControl.ContentTemplate&gt;\n                &lt;DataTemplate&gt;\n                    &lt;flowdoc:FlowDocumentView/&gt;\n                &lt;/DataTemplate&gt;\n            &lt;/ContentControl.ContentTemplate&gt;\n        &lt;/ContentControl&gt;\n    &lt;/Border&gt;\n&lt;/Grid&gt;\n&lt;/UserControl&gt;</code></pre>\n\n..the <strong>SpokenView</strong> gets created and added manually when the user clicks a <strong>Button</strong> on the <em>Custom</em> <strong>TabControl</strong>.  The <strong>Button</strong> click event is added to the <strong>TabControl</strong> during initialization of the template:<br />\n<pre><code>public override void OnApplyTemplate()\n{\n    base.OnApplyTemplate();\n\n    .\n    ..\n    ...\n    \n    // set up the event handler for the 'New Tab' Button Click event\n    _addNewButton = this.Template.FindName(&quot;PART_NewTabButton&quot;, this) as ButtonBase;\n    if (_addNewButton != null)\n        _addNewButton.Command = this.VerseTabCommand;\n}</code></pre>\n\n..and here is when the <strong>SpokenView</strong> is manually created.  During this initialization the <strong>flowdoc:FlowDocumentView</strong> created automatically:<br />\n<pre><code>public void AddTabItem(SelectedReferenceState selectedReferenceState, /*SpokenTabType spokenTabType, */string parameter)\n{\n    .\n    ..\n    ...\n    \n        SpokenTabItem tabItem;\n\n        // Using Items Property\n        ISpokenViewModel spokenViewModel = ServiceLocator.Current.GetInstance&lt;ISpokenViewModel&gt;();\n        SpokenView view = new SpokenView(selectedReferenceState);\n        view.ViewModel = spokenViewModel;\n        spokenViewModel.SelectedReferenceState = selectedReferenceState;\n        tabItem = new SpokenTabItem { Header = parameter, Content = view, SpokenTabKey = parameter };\n\n        int v = 0;\n        if (selectedReferenceState.spokenTabType == SpokenTabType.Verse)\n            v = this.Items.Add(tabItem);\n        else\n            if (selectedReferenceState.spokenTabType == SpokenTabType.Chapter)\n                this.Items.Insert(0, tabItem);\n            else\n                if (i == -1 || i == this.Items.Count - 1 || AddNewTabToEnd)\n                    v = this.Items.Add(tabItem);\n                else\n                {\n                    v = i;\n                    this.Items.Insert(++i, tabItem);\n                }\n    ...\n    ..\n    .\n}</code></pre>\n\n..but, I'm unable to get the <strong>FlowDocumentViewModel</strong> of the <strong>FlowDocumentView</strong> from the <strong>SpokenViewModel</strong> when its being automatically created when the <strong>SpokenView</strong> has completed its initialization.<br />\n<br />\nI hope I can get you to understand this.  Each <strong>TabItem</strong> needs its own <strong>NonShared</strong> <em>objects</em> of <strong>SpokenView</strong> and <strong>FlowDocumentViewModel</strong>, but at the same time <strong>SpokenView</strong> needs access to the <strong>FlowDocumentViewModel</strong>.<br />\n<br />\nSo is there a way I can create an object instance with a unique name like Unity.  Is this available in <strong>MEF</strong> <em>OR</em> I how can accomplish this?  This looked interesting <a href=\"http://stackoverflow.com/questions/7981504/c-sharp-mef-exporting-multiple-objects-of-one-type-and-importing-specific-ones\" rel=\"nofollow\">C# MEF: Exporting multiple objects of one type, and Importing specific ones</a>, but still trying to visually construct this to work for my situation.<br />\n<br />\nEach <strong>TabItem</strong> has to be unique because each <strong>TabItem</strong> will have different content which could go well over 1,000 Tabs.<br />\n",
    "PostedDate": "2013-07-15T16:13:12.39-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1069042",
    "ThreadId": "450108",
    "Html": "I figured out a solution to get the current <strong>FlowDocumentViewModel</strong> for the corresponding <strong>SpokenViewModel</strong> for a <strong>NonShared</strong> <em>object</em>.  After the TabItem is added to the Collection it causes a <strong>OnItemsChanged(NotifyCollectionChangedEventArgs e)</strong> <em>event</em>.  And here is where I search for the <em>Composite View</em> to obtain the the <em>Model</em>:<br />\n<pre><code>protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e)\n{\n    base.OnItemsChanged(e);\n\n    .\n    ..\n    ...\n    \n        if (e.Action == NotifyCollectionChangedAction.Add &amp;&amp; SelectNewTabOnCreate)\n        {\n            SpokenTabItem tabItem = (SpokenTabItem)this.ItemContainerGenerator.ContainerFromItem(e.NewItems[e.NewItems.Count - 1]);\n            SelectedItem = tabItem;\n\n            SpokenTabPanel itemsHost = Helper.FindVirtualizingTabPanel(this);\n            if (itemsHost != null)\n            {\n                itemsHost.MakeVisible(tabItem, Rect.Empty);\n                SelectedReferenceState selectedReferenceState = tabItem.SelectedReferenceState;\n                selectedReferenceState.contentControl = LogicalTreeHelper.FindLogicalNode(tabItem, &quot;FlowDocumentDetails&quot;) as ContentControl;\n                if (selectedReferenceState.contentControl != null)\n                {\n                    selectedReferenceState.flowDocumentReader = FindVisualChild&lt;FlowDocumentReader&gt;(selectedReferenceState.contentControl);\n                    selectedReferenceState.flowDocumentFilter = Parameters.FlowDocumentChangedEvent;\n\n                    IEventAggregator eventAggregator = ServiceLocator.Current.GetInstance&lt;IEventAggregator&gt;();\n                    eventAggregator.GetEvent&lt;FlowDocumentChangedEvent&gt;().Publish(selectedReferenceState);\n                }\n            }\n\n            tabItem.Focus();\n        }\n    ...\n    ..\n    .\n}</code></pre>\n\nThe <strong>FindVisualChild</strong> code:<br />\n<pre><code>private childItem FindVisualChild&lt;childItem&gt;(DependencyObject obj) where childItem : DependencyObject\n{\n    for (int i = 0; i &lt; VisualTreeHelper.GetChildrenCount(obj); i++)\n    {\n        DependencyObject child = VisualTreeHelper.GetChild(obj, i);\n        if (child != null &amp;&amp; child is childItem)\n            return (childItem)child;\n        else\n        {\n            childItem childOfChild = FindVisualChild&lt;childItem&gt;(child);\n            if (childOfChild != null)\n                return childOfChild;\n        }\n    }\n    return null;\n}</code></pre>\n\n..then I execute an Event for the <strong>SpokenViewModel</strong> and update the reference to the <strong>FlowDocumentViewModel</strong>:<br />\n<pre><code>private void OnFlowDocumentChangedEvent(SelectedReferenceState parameter)\n{\n    .\n    ..\n    ...\n    \n        FlowDocumentView myFlowDocumentView = TreeHelper.FindVisualChild&lt;FlowDocumentView&gt;(parameter.contentControl);\n        this.flowDocumentViewModel = myFlowDocumentView.ViewModel;\n        this.SelectedReferenceState = parameter;\n        this.flowDocumentViewModel.ReadReference(selectedReferenceState);\n\n    ...\n    ..\n    .\n}</code></pre>\n\n:) Any suggestion?<br />\n",
    "PostedDate": "2013-07-16T08:19:15.077-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1069173",
    "ThreadId": "450108",
    "Html": "Hi,\r<br />\n<br />\nIn my opinion the approach you describe in the second post is better than registering each <strong>FlowDocumentViewModel</strong> with different names. In the first approach you will still have the problem of passing the name of the corresponding <strong>FlowDocumentViewModel</strong> to obtain it from the container, plus a possible memory leak as the container will kept alive all the <strong>FlowDocumentViewModel</strong> you created in your application, due to they lifetime being managed by the container (non-shared).\r<br />\n<br />\nRegards,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-07-16T13:01:02.59-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1069192",
    "ThreadId": "450108",
    "Html": "Thanks Damian for the reply! :)<br />\n<br />\nYes, I agree, because this was the objective and now I don't need multiple unique <em>objects</em>.<br />\n",
    "PostedDate": "2013-07-16T13:37:01.8-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]