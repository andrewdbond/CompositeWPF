[
  {
    "Id": "746286",
    "ThreadId": "298092",
    "Html": "\r\n<p>We have a WPF Prism (using Unity, DI &amp; MVVM) application that we are developing as a POC. We do not want to be forced into defining regions on the Shell.xaml because we want/need the flexibility to load views in different configurations. What we are\r\n doing is defining a single ContentControl on the Shell and then loading a View from a separate Class Library that defines a particular configuration of ContentControls / Regions. This allows us to then load a different View on the Shell that has a yet another\r\n configuration of ContentControls.</p>\r\n<p>I have seen a number of tracked issues/bugs with the use of named Regions using the RegionManager/IRegion in which to inject (direct) or register (passive) Views.</p>\r\n<p>Not to mention the following considerations:</p>\r\n<p><span style=\"white-space:pre\"></span>- Maintaining static/const string definitions for all regions</p>\r\n<p><span style=\"white-space:pre\"></span>- Keeping clean separation of scope/visibility, I dont want other developers attempting to reference a region that does not exist.</p>\r\n<p><strong>Method</strong></p>\r\n<p>I actually have started using a pure binding method that does not require me to manage const string names for all of possible Region Names.</p>\r\n<p>Consider the following:</p>\r\n<p>Assume Unity and the use of DI to join all Views/ViewModels</p>\r\n<p>For code to follow assume UC = IUnityContainer &amp; EA = IEventAggregator</p>\r\n<p>Assume that when the container (UC) is used to Resolve&lt;MyView&gt; in the following code, the Code Behind constructor using Dependency Injection to set it's own DataContext to a ViewModel registered with Unity.</p>\r\n<p>Assume a shared CompositeWPF event named ShowMainView&lt;UIElement&gt;, The payload is of Type UIElement (Unity will be used to resolve this payload)</p>\r\n<p>The Shell Project's Bootstrapper Loads a Module defined in a separate Class Library, which has Views/ViewModels defined. This Module publishes a Prism Event as follows:</p>\r\n<p>Separate Class Library (Module Project)</p>\r\n<p>EA.GetEvent&lt;ShowMainView&gt;().Publish(UC.Resolve&lt;MyView&gt;());</p>\r\n<p>&nbsp;</p>\r\n<p>Shell Project&gt; Shell.xaml</p>\r\n<p><span style=\"white-space:pre\"></span>&lt;ContentControl Content=&quot;{Binding MainContentArea}&quot; /&gt;</p>\r\n<p><span style=\"white-space:pre\"></span>ShellViewModel.cs</p>\r\n<p><span style=\"white-space:pre\"></span>Has a public property:&nbsp;public UIElement&nbsp;MainContentArea {get;set;}</p>\r\n<p><span style=\"white-space:pre\"></span>Subscribes to&nbsp;ShowMainView event: EA.GetEvent&lt;ShowMainView&gt;().Subscribe((V)=&gt;{ MainContentArea = V&nbsp;});</p>\r\n<p><span style=\"white-space:pre\"></span></p>\r\n<p>I am trying to keep this short &amp; I hope that you all can infer the code that I left out as I am trying to focus on the point which is Binding the Content of a ContentControl to its parent View's DataContext which is a ViewModel that has a defined public\r\n property of type UIElement that is set to a View object that is Resolved using Unity &amp; Dependency Injection. The Prism Event is a way to loosely communicate from an external Class Library that publishes a Prism event with a payload of a View resolved by\r\n Unity, where this View is then shown by a subscribing ViewModel, such as the ShellViewModel in this example ...</p>\r\n<p>EA.GetEvent&lt;ShowMainView&gt;().Subscribe((V)=&gt;{ MainContentArea = V&nbsp;});.&nbsp;</p>\r\n<p>This works great and I am wondering what comments, objections you all might have, thanks.</p>\r\n<p><span style=\"white-space:pre\"></span></p>\r\n<p><span style=\"white-space:pre\"></span></p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2012-02-07T19:06:48.607-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "747735",
    "ThreadId": "298092",
    "Html": "<p>Hi,<br /><br />Prism by design can be used in a granular way depending on your personal preferences and the requirements of your scenario. Hence, I believe the approach you mentioned seems to be a valid one.</p>\r\n<p>On the other hand, take into account that, when using Prism Regions, you can benefit of the features that Prism provides out of the box, such as the Navigation API, region behaviors, etc.</p>\r\n<p>If you are interested, more information about this features can be found in the following resources:</p>\r\n<ul>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/ff921098(v=pandp.40).aspx\">Chapter 7: Composing the User Interface</a></li>\r\n<li><a href=\"http://msdn.microsoft.com/en-us/library/gg430861(v=pandp.40).aspx\">Chapter 8: Navigation</a></li>\r\n<li><a href=\"http://blogs.msdn.com/b/kashiffl/archive/2010/10/04/prism-v4-region-navigation-pipeline.aspx\">Prism v4 Region Navigation Pipeline</a></li>\r\n</ul>\r\n<p>Thanks,</p>\r\n<p>Agustin Adami<a href=\"http://blogs.southworks.net/aadami\"><br /> http://blogs.southworks.net/aadami</a></p>",
    "PostedDate": "2012-02-08T12:13:00.907-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "757926",
    "ThreadId": "298092",
    "Html": "<p>Please understand that I am looking to talk this through for the sake of learning and comparing/contrasting these somewhat subjective techniques. My goal is not to say that what I am proposing is better, but rather to verify that it is valid along with your  objective feedback on the pros/cons.</p>\n<p>Regarding the documentation on Region Navigation and the passing of parameters during navigation I want to compare what I am describing above (in the original post) in parity with what is documented in Chapter 8.</p>\n<p>The ability of any module to use the RequestNavigate requires passing in a named string (and named region as a string if called from the region manager). Hard coded strings always feel 'bad', especially when loaded Views themselves contain regions. I have  yet to see a scoped const/static region name definition pattern that suites all cases as your application grows and changes in ways that you cannot foresee. Passing parameters via query string construct that again are retrieved via \"string\" as key/value pairs  feels like limitations of the asp.net world. In my constructive opinion, using 100% complex objects and xaml binding you can perform all of the tasks of the Region Manager without the overhead of maintaining const/static Region names &amp; class decorators in  order to enable certain behaviors - While enabling (possibly) more power in terms of typed objects with what can done within the Prism event payload. By allowing the ViewModel of any View that has named content areas such as ContentControls to define a UIElement  Binding and a Prism event subscription it appears that you can solve all of the UI scenarios that could also be solved using Regions. I am depending on readers of this post to infer the implementation pattern of what I am implying, as once this convention  is defined there is really no limit to the number of content areas and Views/Sub Views that can be added. Furthermore, by documenting each Prism event you are building a typed library to which future Views/ViewModels could tap into in a disconnected/abstracted  way. For example, I create a new View/ViewModel that has 3 brand new ContentControls. This view can show some of the Views that my existing Views show within their ContentControls. Using the proposed technique there would be zero maintenance outside of the  new objects (View/ViewModel) b/c the ViewModel would just subscribe to the existing Prism event and pull the UIElement out of the payload (via defined interface that all payload objects would implement). Using the region manager would require the Region names  to be tracked and therefore updated somewhere. If additional parameters are needed, then using the proposed technique a typed complex payload object can be passed/received. Whereas with the Region Manager we again have to maintain more string values (somewhere)  for the Key/Value pairs. A final point to make in favor of the proposed technique is that since the publication of the Prism event contains the View, other living objects can also listen (perform a type check if needed) and take action (as just an added technique  to solve problems) in a very loosely coupled way due to the event driven nature of this technique (I do not believe&nbsp;INavigationAware provides as much flexibility as Prism events).</p>\n<p><strong>Questions/Cons</strong></p>\n<p>Are there any Prism event performance limitations or considerations that I should be aware of when publishing events where the payload is a View that has been Resolved via Unity in comparison to use with the Region Manager.... Consider the following:</p>\n<p><strong>XAML</strong></p>\n<p>&lt;ContentControl RegionManger.RegionName=\"MainRegion\" /&gt;</p>\n<p><strong>From any given Module level code:&nbsp;</strong>RegionManager.RequestNavigate(\"MainRegion\", UC.Resolve&lt;MyView&gt;(), NavigationCompleted);</p>\n<p><strong>From the same code:&nbsp;</strong></p>\n<p>private void NavigationCompleted(NavigationResult result){</p>\n<p>// Interaction/event code could go here...</p>\n<p>}</p>\n<p>&nbsp;</p>\n<p>...versus...</p>\n<p>&nbsp;</p>\n<p><strong>XAML</strong></p>\n<p>&lt;ContentControl Content=\"{Binding UIElementProperty}\" /&gt;</p>\n<p><strong>From any given Module level code: </strong>EA.GetEvent&lt;ShowMainView&gt;().Publish(UC.Resolve&lt;MyView&gt;());</p>\n<p><strong>From subscribing ViewModel code:&nbsp;</strong></p>\n<p>EA.GetEvent&lt;ShowMainView&gt;().Subscribe((f)=&gt;{</p>\n<p>UIElementProperty = f;</p>\n<p>// Interaction/event code could go here...</p>\n<p>});</p>",
    "PostedDate": "2012-02-11T18:53:49.243-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "761268",
    "ThreadId": "298092",
    "Html": "<p>Hi,</p>\r\n<p>So far, beside the aforementioned comments, I couldn't find a major limitation to follow this approach.</p>\r\n<p>On the other hand, one thing that must be considered, is that when the content property is changed in the corresponding view model you must ensure that the <strong>UI</strong> gets properly notified of these changes, otherwise they won't be reflected to the <strong>UI</strong>. For example this can be done by calling the <strong>RaisePropertyChanged </strong>method if your view model derives from the <strong>NotificationObject </strong>class provided by Prism.</p>\r\n<p>For those interested, I created a simple <strong>HelloWorld </strong>application, following <a class=\"UserProfileLink\" href=\"http://www.codeplex.com/site/users/view/jesjones\">jesjones</a> proposed approach. You can find it, in my <a href=\"https://skydrive.live.com/#cid=7890102B5B8BC928&amp;id=7890102B5B8BC928!103\">Skydrive account</a> under the name \"<strong>ContentControlDirectViewBindingSample</strong>\"</p>\r\n<p>Thanks,</p>\r\n<p>Agustin Adami<a href=\"http://blogs.southworks.net/aadami\"><br /> http://blogs.southworks.net/aadami</a></p>",
    "PostedDate": "2012-02-13T12:51:40.683-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]