[
  {
    "Id": "243817",
    "ThreadId": "71479",
    "Html": "<p>Background:</p>\r\n<p>So I've tried and tried to get my head around CAL as I can see the benefits and really want to take advantage of them.<br>However, there's a lot to learn, so I thought I'd start by breaking down the proverbial elephant into smaller more manageable pieces.</p>\r\n<p>I think I understand Unity.<br>I'm also pretty sure I've got the MVVM pattern figured out.<br>I'm comfortable with the basic concepts of CAL, but implementing them is sometimes a bit confusing.</p>\r\n<p>So now I have some kind of foundation to build on I'm trying to put the pieces together using CAL.</p>\r\n<p>Questions:</p>\r\n<p>In my approach to MVVM I've always tried to have the purest implementation possible.<br>(You may well question my definition of pure but here goes).</p>\r\n<p>The view knows absolutely nothing about the view model and the view model knows absolutely nothing about the view.<br>My view model implements INotifyPropertyChanged and exposes properties that the view can bind to.<br>Now I don't know if I'm doing this right, but I then have another class (which I don't have a name for) which instantiates a view, instantiates a viewmodel and wires the two together (view.datacontext = viewmodel).</p>\r\n<p>Question 1; Am I doing this right? or is my interpretation of the MVVM pattern not the norm?</p>\r\n<p>Question 2; CAL View Discovery.<br>The quickstarts all suggest that the viewmodel exposes a view property and that's what they use for registering the view in the viewregistry.<br>My viewmodels don't do this however, which leaves me confused.<br>Obviously I can use the Unity to resolve my view class when calling RegisterViewWithRegion, which works in terms of it successfully shows the view, but how do I then wire that up to a viewmodel to make all the good stuff happen?</p>\r\n<p>I'm thinking along the lines of....</p>\r\n<p>In my module.initialise use the unity container to resolve both the view and the viewmodel as ContainerControlledLifetimeManaged objects (ie. single instance).<br>Then grab a reference to each of those objects and wire them together.<br>Finally, register the view with the view registry, again, using unity to resolve the view.</p>\r\n<p>I think that would work, to be honest I haven't tried it, but in truth I'm not completely convinced that this is the way it was supposed to work.</p>\r\n<p>Comments, advice and feedback would be appreciated.</p>\r\n<p><br>Many thanks,</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-10-09T03:35:08.577-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "243895",
    "ThreadId": "71479",
    "Html": "<p>A bit weird replying to my own post... but I've made further progress.</p>\r\n<p>Once again, I couldn't say whether this is best practice or not but my module initalize code now looks like....</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>ViewModel myViewModel = <span style=\"color:Blue\">new</span> ViewModel;\r\nView myView = <span style=\"color:Blue\">new</span> View;\r\n\r\nmyView.DataContext = myViewModel;\r\n\r\n<span style=\"color:Blue\">this</span>.regionViewRegistry.RegisterViewWithRegion(<span style=\"color:#A31515\">&quot;LeftRegion&quot;</span>, () =&gt; myView);\r\n\r\n</pre>\r\n</div>\r\n<p>I now have a view model and a view that know nothing about each other but are wired up through the power of XAML/WPF databinding.</p>\r\n<p>As before, comments/advice/feedback would be appreciated.</p>\r\n<p>I'm just a little concerned that if this isn't the recommended way to use this framework I may have started a timebomb ticking which may go bang in my face at a later date?</p>\r\n<p>&nbsp;</p>\r\n<p>Many thanks,</p>\r\n<p>&nbsp;</p>\r\n<p>CA.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-10-09T07:13:08.05-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "243906",
    "ThreadId": "71479",
    "Html": "<p>Hi mqca,<br><br><br>I'm not sure if this is at all helpful...<br><br>Not going into too much detail but my interpretation of MVVM is to have minimal codebehind for the view and no logic residing there. Thats not to say there is ABSOLUTELY NO codebehind. When it makes sense put code there. To that end the codebehind of each of my views consists of the following:<br><br>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">partial</span> <span style=\"color:Blue\">class</span> SearchControl : UserControl\r\n    {\r\n        <span style=\"color:Blue\">public</span> SearchControl(SearchViewModel viewModel)\r\n        {\r\n            <span style=\"color:Blue\">this</span>.DataContext = viewModel;\r\n            InitializeComponent();\r\n        }\r\n    }\r\n</pre>\r\n</div>\r\n<br>As far as registering with the view, a VM having reference to a V, etc. In my implementation the viewmodel doesnt have a reference to the view. This has made for some tricky spots: a lot of custom control development and command implementations were necessary. But it kept the two fairly decoupled.<br><br>As far as the view registering, I did that in the initialize method of my module like you had mentioned.<br><br>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">void</span> Initialize()\r\n        {\r\n            _Container.RegisterType&lt;ISearchModel, SearchModel&gt;();\r\n            ISearchModel _Framework = _Container.Resolve&lt;ISearchModel&gt;();\r\n            <span style=\"color:Blue\">this</span>._RegionManager.RegisterViewWithRegion(_Framework.CurrentRegion, <span style=\"color:Blue\">typeof</span>(SearchControl));\r\n        }\r\n</pre>\r\n</div>\r\n<br>The only reason I (me personally in my project) would not use the approach you used is because your approach doesnt put the view and view model through the DI pipeline. Because I use an abstraction for the model I'd want to have the view model created in this way so that it gets a proper reference to the ISearchModel implementation.<br><br>I think the purpose of MVVM is testability (am I incorrect here?) So as long as your implementation make the individual units as testable as you need then you are golden. As I mentioned above I have an interface to my model. This is because I mock up a lot of model data. Also I am currently in the process of moving from SQL to AmazonSimpleDB and this pattern has made that move particularly easy :)</p>",
    "PostedDate": "2009-10-09T07:32:43.703-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "243913",
    "ThreadId": "71479",
    "Html": "<p>Hi Idoolitt, and thanks for your reply.</p>\r\n<p>Like you, to me MVVM is all about testability and in that sense my approach works for me so that's good enough (for now).</p>\r\n<p>I'm curious though, the one thing I haven't commented on in my questions is the use of Interfaces.</p>\r\n<p>You mention using Interfaces on your model? could you give me an insight into that? it's not something I'm familiar with (or maybe I just don't recognise it).</p>\r\n<p>I'm also curious as to why so much of CAL is built around interfaces - IView, IViewModel?</p>\r\n<p>If you've built a project out of modules and you want to swap out 1 module for another there's fairly obvious/straight forward way to achieve it.</p>\r\n<p>I guess that comes from the fact modules are built around IModule, but fundamentally, this is what CAL is for, so no issues there.</p>\r\n<p>If you've built your modules using the MVVM pattern then your presentation and business logic aren't coupled together.</p>\r\n<p>MVVM gives you the power to swap out your view for a different view (be that a unit test/mock view whatever). &nbsp;So why would you interface your view when you don't need to?</p>\r\n<p>The relevance of this is that most of the quickstarts use unit to resolve a view based on an interface and in my solution, those interfaces don't exist?</p>\r\n<p>&nbsp;</p>\r\n<p>I'm sure that one day the someone will switch on the light at the end of the tunnel, but for now I'll keep feeling my way along the edge! :o)</p>\r\n<p>&nbsp;</p>\r\n<p>CA.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-10-09T07:58:20.92-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "243931",
    "ThreadId": "71479",
    "Html": "<p>mqc,</p>\r\n<p>What you wrote was...</p>\r\n<p>ViewModel myViewModel = <span style=\"color:blue\">new</span> ViewModel;<br>View myView = <span style=\"color:blue\">new</span> View;<br><br>myView.DataContext = myViewModel;<br><br><span style=\"color:blue\">this</span>.regionViewRegistry.RegisterViewWithRegion(<span style=\"color:#a31515\">&quot;LeftRegion&quot;</span>, () =&gt; myView);</p>\r\n<p>Which, in my opinion, is not &quot;pure&quot; MVVM because you are explicity setting the DataContext on the View, which means the View must &quot;know&quot; about the ViewModel.</p>\r\n<p>To do MVVM with CAL, you would need to actually add myViewModel to &quot;LeftRegion&quot; and create a DataTemplate for the ViewModel which is set as myView.</p>\r\n<p>Get an IUnityContainer and IRegionManager&nbsp;through dependency injection in the constructor of your ViewModel:</p>\r\n<p>In your initialize event, resolve a ViewModel and add it to a Region.</p>\r\n<p>Also add a dictionary&nbsp;in the initialize event of the Module:</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uri uri = new Uri(&quot;/MyModule;component/Resources/ViewModelResources.xaml&quot;, UriKind.Relative);</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResourceDictionary dict = new ResourceDictionary();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dict.Source = uri;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application.Current.Resources.MergedDictionaries.Add(dict);</p>\r\n<p>...and in the dictionary you would put:</p>\r\n<p>&lt;ResourceDictionary <br>&nbsp;&nbsp;&nbsp; xmlns=&quot;<a href=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\">http://schemas.microsoft.com/winfx/2006/xaml/presentation</a>&quot;<br>&nbsp;&nbsp;&nbsp; xmlns:x=&quot;<a href=\"http://schemas.microsoft.com/winfx/2006/xaml\">http://schemas.microsoft.com/winfx/2006/xaml</a>&quot;<br>&nbsp;&nbsp;&nbsp; xmlns:local=&quot;clr-namespace:MyModule;assembly=MyModule&quot;<br>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &lt;DataTemplate DataType=&quot;{x:Type local:MyViewModel}&quot;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;local:MyView /&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/DataTemplate&gt;<br>&lt;/ResourceDictionary&gt;</p>\r\n<p>This is &quot;pure&quot; MVVM&quot; that completely decouples the ViewModel from the View.&nbsp; View does not need to know about the ViewModel.</p>\r\n<p>The problem with CAL is that it expects anything that is added to a region to be a DependencyObject.&nbsp; Since ViewModel classes are rarely DependencyObjects, the ViewModel does not get a RegionManager attached to it and does not display.</p>\r\n<p>A &quot;pure&quot; MVVM implementation in CAL is not presently possible.&nbsp; You have to use the&nbsp; [this.View = view; this.View.Model = this] technique in CAL.&nbsp; You can call it MVVM, if you want, but it's not really.</p>\r\n<p>&nbsp;</p>\r\n<p>Note: There is a similar post going on at <a href=\"http://compositewpf.codeplex.com/Thread/View.aspx?ThreadId=71430\">http://compositewpf.codeplex.com/Thread/View.aspx?ThreadId=71430</a></p>",
    "PostedDate": "2009-10-09T08:46:23.907-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "243941",
    "ThreadId": "71479",
    "Html": "<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>mqca wrote:</strong><br>\r\n<p>Hi Idoolitt, and thanks for your reply.</p>\r\n<p>Like you, to me MVVM is all about testability and in that sense my approach works for me so that's good enough (for now).</p>\r\n<p>I'm curious though, the one thing I haven't commented on in my questions is the use of Interfaces.</p>\r\n<p>You mention using Interfaces on your model? could you give me an insight into that? it's not something I'm familiar with (or maybe I just don't recognise it).</p>\r\n<p>I'm also curious as to why so much of CAL is built around interfaces - IView, IViewModel?</p>\r\n<p>If you've built a project out of modules and you want to swap out 1 module for another there's fairly obvious/straight forward way to achieve it.</p>\r\n<p>I guess that comes from the fact modules are built around IModule, but fundamentally, this is what CAL is for, so no issues there.</p>\r\n<p>If you've built your modules using the MVVM pattern then your presentation and business logic aren't coupled together.</p>\r\n<p>MVVM gives you the power to swap out your view for a different view (be that a unit test/mock view whatever). &nbsp;So why would you interface your view when you don't need to?</p>\r\n<p>The relevance of this is that most of the quickstarts use unit to resolve a view based on an interface and in my solution, those interfaces don't exist?</p>\r\n<p>&nbsp;</p>\r\n<p>I'm sure that one day the someone will switch on the light at the end of the tunnel, but for now I'll keep feeling my way along the edge! :o)</p>\r\n<p>&nbsp;</p>\r\n<p>CA.</p>\r\n<p>&nbsp;</p>\r\n</blockquote>\r\n<p>For interfaces I don't go overboard.</p>\r\n<p>For me there really is no reason to have an IView because I don't ever reference the view anywhere. But I could see where you would in a pattern as mentioned above, where the view model has a reference to the view. Also I dont have an IViewModel for the same reason; I dont reference the view model anywhere else but in the constructor of the codebehind. Since there are no constraints on the object type (view.datacontext takes an object) I dont see the need to make a IViewModel for myself.</p>\r\n<p>I use an IModel because the view model makes heavy reference to the model (obviously.) Right now I'm using .NET RIA services to provide model data to each module but that will likely change in the future so I keep that interface decoupled.</p>\r\n<p>As far as the views go I actually haven't done a lot of view swapping or anything like that. However it would be easy to do; just ensure that the view you swapped in uses the same commanding interface as the view it replaced.</p>",
    "PostedDate": "2009-10-09T09:30:27.763-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]