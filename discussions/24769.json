[
  {
    "Id": "83019",
    "ThreadId": "24769",
    "Html": "\r\nHi,<br /><br />The implementation of AddWatchCommand seems non-standard and flawed to me. If multiple callers invoke <span class=\"codeInline\" style=\"font-family:Consolas, Courier New, Courier, Monospace;\">SetFiredCallback</span> then the last caller wins. Wouldn't it make more sense to just define an <span class=\"codeInline\" style=\"font-family:Consolas, Courier New, Courier, Monospace;\">Executed</span> event? I tried this out and here's the resultant code:<br /><br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\n//TickerSymbolEventArgs.cs\r\npublic sealed class TickerSymbolEventArgs : EventArgs\r\n{\r\n\tpublic string TickerSymbol { get; private set; }\r\n \r\n\tpublic TickerSymbolEventArgs(string tickerSymbol)\r\n\t{\r\n\t\tTickerSymbol = tickerSymbol;\r\n\t}\r\n}\r\n \r\n//AddWatchCommand.cs\r\npublic class AddWatchCommand : ICommand\r\n{\r\n\tprivate EventHandler&lt;TickerSymbolEventArgs&gt; _executedHandler;\r\n \r\n\tpublic event EventHandler&lt;TickerSymbolEventArgs&gt; Executed\r\n\t{\r\n\t\tadd\r\n\t\t{\r\n\t\t\t_executedHandler = Delegate.Combine(_executedHandler, value) as EventHandler&lt;TickerSymbolEventArgs&gt;;\r\n\t\t\tOnCanExecuteChanged();\r\n\t\t}\r\n\t\tremove\r\n\t\t{\r\n\t\t\t_executedHandler = Delegate.Remove(_executedHandler, value) as EventHandler&lt;TickerSymbolEventArgs&gt;;\r\n\t\t\tOnCanExecuteChanged();\r\n\t\t}\r\n\t}\r\n \r\n\tprivate void OnCanExecuteChanged()\r\n\t{\r\n\t\tif (CanExecuteChanged != null)\r\n\t\t{\r\n\t\t\tCanExecuteChanged(this, EventArgs.Empty);\r\n\t\t}\r\n\t}\r\n \r\n    public bool CanExecute(object parameter)\r\n    {\r\n        return _executedHandler != null;\r\n    }\r\n \r\n    public event EventHandler CanExecuteChanged;\r\n \r\n    public void Execute(object parameter)\r\n    {\r\n        if (_executedHandler != null)\r\n        {\r\n\t\t\t_executedHandler(this, new TickerSymbolEventArgs(parameter as string));\r\n        }\r\n    }\r\n}\r\n \r\n//WatchListService.cs\r\nWatchListModuleCommands.AddWatchCommand.Executed += AddWatchCommand_Executed;\r\n \r\n...\r\n \r\nprivate void AddWatchCommand_Executed(object sender, TickerSymbolEventArgs e)\r\n{\r\n\tif (!String.IsNullOrEmpty(e.TickerSymbol))\r\n\t{\r\n\t\tstring upperCasedTrimmedSymbol = e.TickerSymbol.ToUpperInvariant().Trim();\r\n \r\n\t\tif (!WatchItems.Contains(upperCasedTrimmedSymbol))\r\n\t\t{\r\n\t\t\tif (marketFeedService.SymbolExists(upperCasedTrimmedSymbol))\r\n\t\t\t{\r\n\t\t\t\tWatchItems.Add(upperCasedTrimmedSymbol);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n</pre><br />Think I'll have more comments when I dig deeper, but this one just jumped out at me.<br /><br />Cheers,<br />Kent<br />",
    "PostedDate": "2008-03-26T10:26:00.817-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]