[
  {
    "Id": "1058574",
    "ThreadId": "447514",
    "Html": "Hello everyone,\r<br />\nI started with Prism and I'm stuck for several days with a problem.\r<br />\nI have two modules, A and B. I want to navigate between these two modules on a single Mainregion by clicking on my menu.\r<br />\n<br />\nHere is my <strong>TheBootstrapper class</strong><br />\n<pre><code>public class TheBootstrapper : MefBootstrapper\n    {\n        protected override void InitializeShell()\n        {\n            base.InitializeShell();\n\n            Application.Current.RootVisual = (UIElement)Shell;\n        }\n\n        protected override DependencyObject CreateShell()\n        {\n            return Container.GetExportedValue&lt;Shell&gt;();\n        }\n\n        protected override void ConfigureAggregateCatalog()\n        {\n            base.ConfigureAggregateCatalog();\n\n            // Prism's AggregateCatalog is a catalog of all MEF composable parts\n            // within the application.\n            // We add the parts corresponding to the current assembly to it\n            AggregateCatalog.Catalogs.Add(new AssemblyCatalog(this.GetType().Assembly));\n        }\n\n        protected override IModuleCatalog CreateModuleCatalog()\n        {\n            ModuleCatalog moduleCatalog = new ModuleCatalog();\n\n            // this is the code responsible \n            // for adding Module1 to the application\n            moduleCatalog.AddModule\n            (\n                new ModuleInfo\n                {\n                    // we make Module1 to be &quot;OnDemand&quot; module\n                    // meaning it is not going to load at the app intialization\n                    // time\n                    InitializationMode = InitializationMode.OnDemand,\n                    Ref = &quot;ModuleA.xap&quot;,\n                    ModuleName = &quot;ModuleAImpl&quot;,\n                    ModuleType = &quot;ModuleA.ModuleAImpl, ModuleA, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot;\n                }\n            );\n            moduleCatalog.AddModule\n            (\n                new ModuleInfo\n                {\n                    // we make Module1 to be &quot;OnDemand&quot; module\n                    // meaning it is not going to load at the app intialization\n                    // time\n                    InitializationMode = InitializationMode.OnDemand,\n                    Ref = &quot;ModuleB.xap&quot;,\n                    ModuleName = &quot;ModuleBImpl&quot;,\n                    ModuleType = &quot;ModuleB.ModuleBImpl, ModuleB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot;\n                }\n            );\n            return moduleCatalog;\n        }\n    }</code></pre>\n\n<strong>Shell.Xaml.cs</strong><br />\n<pre><code>    public partial class Shell : UserControl\n    {\n        IModuleManager _moduleManager;\n        [ImportingConstructor]\n        public Shell([Import]IModuleManager moduleManager)\n        {\n            InitializeComponent();\n            _moduleManager = moduleManager;\n            _moduleManager.LoadModuleCompleted += _moduleManager_LoadModuleCompleted; \n        }\n        void _moduleManager_LoadModuleCompleted(object sender, LoadModuleCompletedEventArgs e)\n        {\n            \n        }\n\n        private void Menu_ItemClick(object sender, Telerik.Windows.RadRoutedEventArgs e)\n        {            \n            switch ((e.OriginalSource as ExtendedMenuItem).AdditionalInfo.ToString())\n            {\n                case &quot;ModuleB&quot;:\n                    _moduleManager.LoadModule(&quot;ModuleBImpl&quot;);\n                    break;\n                case &quot;ModuleA&quot;:\n                    _moduleManager.LoadModule(&quot;ModuleAdministrationImpl&quot;);\n                    break;\n                default:\n                    MessageBox.Show(&quot;Module indisponible&quot;);\n                    break;\n            }\n        }\n    }</code></pre>\n\nAND <strong>ModuleA class</strong> (same thing for ModuleB)<br />\n<pre><code>[ModuleExport(typeof(ModuleAImpl))]\n    public class ModuleAImpl : IModule\n    {\n        // import IRegionManager singlton from Prism\n        [Import]\n        public IRegionManager TheRegionManager { private get; set; }\n\n        #region IModule Members\n\n        public void Initialize()\n        {\n            var _region = TheRegionManager.Regions[&quot;Mainregion&quot;];\n            if (_region != null)\n            {\n                foreach (object view in _region.Views)\n                {\n                    _region.Remove(view);\n                }\n            }\n            TheRegionManager.RegisterViewWithRegion(&quot;Mainregion&quot;, typeof(HostPageA));\n\n        }\n\n        #endregion\n    }</code></pre>\n\n<strong>My problem</strong>:\r<br />\nMy problem is that I can not navigate between modules, I can display the ModuleA then ModuleB, but it's still frozen on ModuleB... How can I reactivate the module A or reload it.\r<br />\n<br />\nPlease, I need an easy solution Compatible with my code.\r<br />\n<br />\nThank you.<br />\n",
    "PostedDate": "2013-06-19T03:01:11.227-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1058755",
    "ThreadId": "447514",
    "Html": "Hi,\r<br />\n<br />\nBased on my understanding, <strong>LoadModule</strong> method from your module manager loads the specified module and runs its <strong>Initialize</strong> method only if that module hadn't been loaded before, since the <strong>module manager keeps track of the modules already loaded</strong> (if you run the method twice, nothing will happen). Therefore, in order to solve your problem, you will need to verify if the module was loaded before to avoid calling the <strong>LoadModule</strong> method twice. The following code shows how your switch cases should look like for your modules:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n...\n<span style=\"color:Blue;\">case</span> <span style=\"color:#A31515;\">&quot;ModuleB&quot;</span>:\n    <span style=\"color:Blue;\">if</span> ( <span style=\"color:Green;\">/*module not loaded*/</span> )\n        _moduleManager.LoadModule(<span style=\"color:#A31515;\">&quot;ModuleBImpl&quot;</span>);\n    <span style=\"color:Blue;\">else</span>\n        _regionManager.RequestNavigate(<span style=\"color:#A31515;\">&quot;MainRegion&quot;</span>, <span style=\"color:#A31515;\">&quot;HostPageB&quot;</span>);\n    <span style=\"color:Blue;\">break</span>;\n...\n\r\n</pre></div>Hope this helps,\r<br />\n<br />\nFederico Martinez \r<br />\n<a href=\"http://blogs.southworks.net/fmartinez\" rel=\"nofollow\">http://blogs.southworks.net/fmartinez</a> <br />\n",
    "PostedDate": "2013-06-19T09:48:05.563-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1058844",
    "ThreadId": "447514",
    "Html": "Thank you very much for your answer. it's very clear. But how can I get the list of modules from my Shell?<br />\n",
    "PostedDate": "2013-06-19T13:19:47.17-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1060480",
    "ThreadId": "447514",
    "Html": "Hi,\r<br />\n<br />\nBased on my understanding, you can retrieve the <strong>IModuleCatalog</strong> (from dependency injection or through service locator), which holds information about the modules that can be used by the application, and also exposes a <strong>Modules</strong> property which contains a collection of <strong>ModuleInfo</strong> with each of the modules information. In the <strong>ModuleInfo</strong>, you can check the <strong>State</strong> property to verify if that module was loaded or not.\r<br />\n<br />\nHope this helps,\r<br />\n<br />\nFederico Martinez \r<br />\n<a href=\"http://blogs.southworks.net/fmartinez\" rel=\"nofollow\">http://blogs.southworks.net/fmartinez</a> <br />\n",
    "PostedDate": "2013-06-24T09:56:07.103-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]