[
  {
    "Id": "165856",
    "ThreadId": "49559",
    "Html": "<p>The PresentationModel classes (e.g. WatchListPresentationModel) in the StockTrader RI collaborate with services to retrieve the data that is shown to the user. Some of these services (e.g. WatchListService) provide events so that the PresentationModel gets informed when the data changes.<br>\r\n<br>\r\nWhen the PresentationModel adds an event handler to the service event then it couples its lifecycle to the one of the service. Services are often implemented as singletons whereas the View and its associated PresentationModel just lives as long the user edits the data in the View.</p>\r\n<p><em>Example:</em> WatchListPresentationModel</p>\r\n<p style=\"margin:0in 0in 0pt;line-height:normal\"><span style=\"font-size:10pt;color:blue;font-family:'courier new'\">this</span><span style=\"font-size:10pt;font-family:'courier new'\">.watchList = watchListService.RetrieveWatchList();</span></p>\r\n<p style=\"margin:0in 0in 10pt\"><span style=\"font-size:10pt;color:blue;line-height:115%;font-family:'courier new'\">this</span><span style=\"font-size:10pt;line-height:115%;font-family:'courier new'\">.watchList.CollectionChanged += <span style=\"color:blue\">delegate</span> <br>\r\n{ <br>\r\n    <span style=\"color:blue\">this</span>.PopulateWatchItemsList(<span style=\"color:blue\">this</span>.watchList); <br>\r\n};</span></p>\r\n<p>Because the PresentationModel adds an event handler, the internal event implementation of the service keeps a reference back to the PresentationModel. The garbage collector will never be able to collect the PresentationModel or the View object as long the service is alive.</p>\r\n<p><em>Solutions: <br>\r\n</em>1. Use the EventAggregator of the CAL libraries<br>\r\n2. Use the WeakEvent  Pattern (see <a href=\"http://msdn.microsoft.com/en-us/library/aa970850.aspx\">http://msdn.microsoft.com/en-us/library/aa970850.aspx</a>)</p>\r\n<p>The first one cannot be used in all scenarios. Thus, I prefer the second solution.<br>\r\n<br>\r\nI believe this concept is very important and so I provide a PresentationModel base class that supports this pattern in my project: <a href=\"http://www.codeplex.com/CompositeExtensions\">http://www.codeplex.com/CompositeExtensions</a> </p>\r\n<p>Do you have other ideas to solve this memory issue?<br>\r\njbe</p>\r\n",
    "PostedDate": "2009-03-08T14:30:44.207-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "166206",
    "ThreadId": "49559",
    "Html": "<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\">Hi</span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\">While the <b>WeakEvent</b> pattern is a good solution for this problem for communication <b>within</b> modules , it might not be the best approach for communication <b>between</b> modules. This is because to subscribe to an object, you need a direct reference to that object. This is where the <b>EventAggregator</b> provided by CAL comes into play, since the publisher and the handler can be in different modules and the expected behavior will still be obtained, thus avoiding having hard references.</span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\">                     </span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\">Could you share the particular scenario where the <b>EventAggregator</b> is not usable?</span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\">For more information about the EventAggregator service and communication in Composite Applications you can check the following topics:</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 36pt\"><span style=\"font-family:symbol\">·<span style=\"font:7pt 'times new roman'\">         </span><a href=\"http://msdn.microsoft.com/en-us/library/dd458878.aspx\"><span style=\"color:#0000ff;font-family:calibri\">Communication</span></a>\r\n<p style=\"margin:0cm 0cm 0pt 36pt\"><span style=\"font-family:symbol\">·<span style=\"font:7pt 'times new roman'\">         </span><a href=\"http://msdn.microsoft.com/en-us/library/dd458915.aspx\"><span style=\"color:#0000ff;font-family:calibri\">Event Aggregator</span></a>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\">Please let me know if this helps.</span></p>\r\n<p style=\"margin:0cm 0cm 0pt -0.6pt\"><span style=\"font-family:calibri\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt -0.6pt\"><span style=\"font-family:calibri\">Damian Schenkelman</span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span><a href=\"http://blogs.southworks.net/dschenkelman\"><span style=\"color:#0000ff;font-family:calibri\">http://blogs.southworks.net/dschenkelman</span></a></span></p>\r\n</span></p>\r\n</span></p>\r\n",
    "PostedDate": "2009-03-09T11:56:04.237-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "168296",
    "ThreadId": "49559",
    "Html": "Hi Damian!<br>\r\n<br>\r\nYou are absolute right that the <strong>EventArggregator</strong> solves the problem of loose coupling of publisher and subscriber.<br>\r\n<br>\r\n<strong>My scenario:</strong><br>\r\n<br>\r\nIn my case I have to wire business objects with the UI together. Both layers are implemented within the same module. The business objects implement the <strong>INotifyPropertyChanged</strong> interface so that the WPF binding gets notified when the associated business object has changed. The WPF binding implementation uses the <strong>WeakEvent</strong> pattern to prevent memory leaks. <br>\r\n<br>\r\nWhen I’m using the <strong>PresentationModel</strong> pattern then the UI binds to the PresentationModel class which itself “binds” to the business object class. The PresentationModel might need to listen to property change notifications of the business object. In such a case the PresentationModel should use the <strong>WeakEvent</strong> pattern in the same way as the WPF binding implementation does to prevent memory leaks.<br>\r\n<br>\r\njbe<br>\r\n",
    "PostedDate": "2009-03-15T10:04:53.867-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "171308",
    "ThreadId": "49559",
    "Html": "I have found another solution in the MSDN Magazine, February 2009: “WPF Apps With The Model-View-ViewModel Design Pattern, Josh Smith” (<a href=\"http://msdn.microsoft.com/en-us/magazine/dd419663.aspx\">http://msdn.microsoft.com/en-us/magazine/dd419663.aspx</a>)<br>\r\n <br>\r\nIn his sample project he provides a base class for the Model-View-ViewModel pattern. This base class “ViewModelBase” implements the IDisposable interface. He uses the Disposable pattern to unwire the ViewModel implementation from the consumed events so that the garbage collector is able to collect the ViewModel object.<br>\r\n <br>\r\nI prefer the WeakEvent pattern over the Disposable pattern because it’s more the WPF way to consume events. However, both solutions prevent memory leaks in our M-V-VM or PresentationModel implementations.<br>\r\n <br>\r\njbe\r\n",
    "PostedDate": "2009-03-24T06:47:07.55-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]