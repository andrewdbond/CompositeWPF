[
  {
    "Id": "1082314",
    "ThreadId": "453859",
    "Html": "I've got a pretty good idea how DI works in Prism when you have an IModule.  However, many of my classes where I want DI are not modules, they are plain old classes.  If I use the <strong>[Import]</strong> statement, I never see any injection occur.  If I use the <strong>[Export]</strong> attribute and provide an implementation of the <strong>IModule</strong> interface, I get injection.  I can't imagine I need to provide an <strong>IModule</strong> implementation on every class so what am I missing?\r<br />\n<br />\nTo illustrate the problem, I've added a simple class to the Prism 4.1 Quickstarter solution called 'ModularityWithMef.Desktop'.  This class is added to the 'ModuleA' project:\r<br />\n<br />\nClass1.cs:<br />\n<pre><code>    namespace ModularityWithMef.Desktop\n    {\n        using System;\n        using System.ComponentModel.Composition;\n        using ModuleTracking;\n\n        public class Class1\n        {\n            private IModuleTracker moduleTrackerField;\n\n            [Import(typeof(IModuleTracker))]\n            public IModuleTracker ModuleTracker\n            {\n                get\n                {\n                    return this.moduleTrackerField;\n                }\n                set\n                {\n                    this.moduleTrackerField = value;\n                }\n            }\n        }\n    }</code></pre>\n\nThe setter is never hit.  If I decorate it with an [Export] statement, I can hit the setter, but then I get a message that I need to provide an 'Initialization()' method for any class decorated with an [Export] attribute.  What am I missing here?  I see the advantage of using attribute based DI, but I can't imagine that I have to implement <strong>IModule</strong> on every class that uses DI.<br />\n",
    "PostedDate": "2013-08-19T11:55:48.287-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1082414",
    "ThreadId": "453859",
    "Html": "OK, I answered my own question.  It has everything to do with the decorator and how you instantiate 'Class1'.  That is, you need to decorate <strong>Class1</strong> above with the <strong>[Export]</strong> attribute, then when you create the object using the CompositionContainer, you'll get the injection to work:<br />\n<pre><code>            Class1 instance = compositionContainer.GetExportedValue&lt;Class1&gt;();\n</code></pre>\n\nThe most difficult part was getting a CompositionContainer in the loaded module.  For this, I used DI to insert the ServiceLocator in the class when it was built.  I have to say that my instincts agree with the article I read calling the static Service Locators the 'Anti-Pattern'.  That method of doing things swaps several baked-in dependencies for a single baked-in dependency, but that's another thread.  Anyway, the module is initialized with a service locator like so:<br />\n<pre><code>        [ImportingConstructor]\n        public ModuleA(ILoggerFacade logger, IServiceLocator serviceProvider)\n        {\n            if (logger == null)\n            {\n                throw new ArgumentNullException(&quot;logger&quot;);\n            }\n            if (serviceProvider == null)\n            {\n                throw new ArgumentNullException(&quot;serviceProvider&quot;);\n            }\n\n            this.serviceLocator = serviceProvider as MefServiceLocatorAdapter;\n            this.logger = logger;\n        }\n</code></pre>\n\nThen I was able to use it when the module was initialized:<br />\n<pre><code>        public void Initialize()\n        {\n            var compositionContainer = this.serviceLocator.GetInstance&lt;CompositionContainer&gt;();\n            var class1 = compositionContainer.GetExportedValue&lt;Class1&gt;();\n        }\n</code></pre>\n\n",
    "PostedDate": "2013-08-19T17:13:19.777-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]