[
  {
    "Id": "936595",
    "ThreadId": "401913",
    "Html": "\r\n<p>Hi there,</p>\r\n<p>I am working on a WPF Prism application. In certain secondary windows, I need to create a different menu (not the one of the Shell).</p>\r\n<p>The menu of the dependent window should compose according to the modules that are found and dynamically loaded.</p>\r\n<p>The dependent menu views are singletons (CreationPolicy.Shared). Differently, the part creation policy of the dependent window has been set to NonShared, however an instance of the viewModel of this dependent window is kept alive as it is also used by another\r\n feature of the application (in other words, two views share the same viewModel)</p>\r\n<p>The first time, in order to create the dependent window I do something like:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>IRegionManager windowRegionManager = <span style=\"color:blue\">new</span> RegionManager();\nIWindow window = <span style=\"color:blue\">this</span>.ServiceLocator.GetInstance&lt;IWindow&gt;();\nRegionManager.SetRegionManager(window <span style=\"color:blue\">as</span> DependencyObject, windowRegionManager);\nviewModel viewModel = <span style=\"color:blue\">new</span> viewModel(windowRegionManager, _serviceLocator)\n                      {\n                         Title = <span style=\"color:#a31515\">&quot;Hello World!&quot;</span>\n                      };\n<span style=\"color:blue\">this</span>._shellWindowViewModel.DependentViewModels.Add(viewModel);\nwindow.ViewModel = viewModel;\nwindow.Show();\n</pre>\r\n</div>\r\n<p>After closing it, when I want to display again the same window, I simply create a new View (window) instance and I set the same ViewModel. Something like:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>IWindow window = <span style=\"color:blue\">this</span>.ServiceLocator.GetInstance&lt;IWindow&gt;();\n<span style=\"color:blue\">var</span> windowRegionManager = viewModel.LocalRegionManager;\nRegionManager.SetRegionManager(window <span style=\"color:blue\">as</span> DependencyObject, windowRegionManager);\nwindow.ViewModel = viewModel;\nwindow.Show();\n</pre>\r\n</div>\r\n<p>Unfortunately, the result is not as expected. I guess something is wrong and not working at all, as I don't see the view that was previously registered in the dedicated and composable menu Region, though I use the same RegionManager for the new window instance.</p>\r\n<p>Do you have any idea of what can cause the issue that I am facing?&nbsp;</p>\r\n<p>Thanks in advance,</p>\r\n<p>Gianluca.</p>\r\n<p>PS: Some further info: If I check the content of the LocalRegionManager, the one that I attach to the dependent window, I can see it hosts the dependent MenuView.&nbsp;</p>\r\n",
    "PostedDate": "2012-11-05T01:50:01.25-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "936884",
    "ThreadId": "401913",
    "Html": "<p>Hi,</p>\r\n<p>Based on my understanding, the problem you are experiencing could be related to the fact that each <strong>Window </strong>instance has its own different regions.</p>\r\n<p>Basically, when you create the <strong>Window </strong>for the first time, its regions will be registered in the <strong>RegionManager </strong>you set for that <strong>Window</strong>. For example, if the <strong>Window </strong>has a <em><strong>\"</strong>WindowRegion</em>,\" it will be registered in that <strong>RegionManager</strong>. However, the second time you create a <strong>Window </strong>you will have the previous <strong>RegionManager </strong>with its regions and the new <strong>Window </strong>with its own regions. That is, the \"<em>WindowRegion</em>\" of the second <strong>Window </strong>will <strong>NOT </strong>be \"<em>WindowRegion</em>\" of the <strong>RegionManager</strong>. Therefore, although the <strong>RegionManager </strong>is keeping its regions (and the regions are keeping their views), those are not the regions of the new <strong>Window</strong>, and the views are not being shown in them.</p>\r\n<p>A possible approach to achieve the functionality you are mentioning could be to work with the content element of the <strong>Window</strong>. For example, instead of setting the <strong>RegionManager </strong>in the <strong>Window</strong>, you could set it in the <strong>Content </strong>element of the <strong>Window</strong>. Then, you could store the content of the first <strong>Window</strong>, and when creating the second <strong>Window </strong>you can change its <strong>Content </strong>property to hold the contents of the original <strong>Window</strong>. Like this, each <strong>Window </strong>you create will use the same <strong>UIElements</strong>, <strong>RegionManager </strong>and regions:</p>\r\n<p>The first time:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>IRegionManager windowRegionManager = <span style=\"color: blue;\">new</span> RegionManager();\r\nIWindow window = <span style=\"color: blue;\">this</span>.ServiceLocator.GetInstance&lt;IWindow&gt;();\r\n\r\n<span style=\"color: green;\">// We save the content of the window and set the RegionManager in it.</span>\r\n<span style=\"color: blue;\">this</span>.windowContent = window.Content <span style=\"color: blue;\">as</span> DependencyObject;\r\nRegionManager.SetRegionManager(windowContent, windowRegionManager);\r\n\r\nviewModel viewModel = <span style=\"color: blue;\">new</span> viewModel(windowRegionManager, _serviceLocator)\r\n{\r\n    Title = <span style=\"color: #a31515;\">\"Hello World!\"</span>\r\n};\r\n<span style=\"color: blue;\">this</span>._shellWindowViewModel.DependentViewModels.Add(viewModel);\r\nwindow.ViewModel = viewModel;\r\nwindow.Show();\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>And after the first time:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>IWindow window = <span style=\"color: blue;\">this</span>.ServiceLocator.GetInstance&lt;IWindow&gt;();\r\n            \r\n<span style=\"color: green;\">// We no longer need to set the RegionManager again, as the content already has it.</span>\r\n<span style=\"color: green;\">//var windowRegionManager = viewModel.LocalRegionManager;</span>\r\n<span style=\"color: green;\">//RegionManager.SetRegionManager(window as DependencyObject, windowRegionManager);</span>\r\n\r\nwindow.Content = <span style=\"color: blue;\">this</span>.windowContent;\r\n\r\nwindow.ViewModel = viewModel;\r\nwindow.Show();\r\n</pre>\r\n</div>\r\n<p>Take into account that you will need to remove the content from the previous <strong>Window </strong>before being able to set it as the content of the next <strong>Window</strong>. A simple method to do this could be to set the <strong>Content </strong>property of the <strong>Window </strong>to <em><strong>null </strong></em>in its <strong>Closed </strong>event.</p>\r\n<p>I hope you find this useful,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2012-11-05T11:26:47.857-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]