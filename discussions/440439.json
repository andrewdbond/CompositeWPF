[
  {
    "Id": "1031067",
    "ThreadId": "440439",
    "Html": "What is the best practice, where the region manager should be located in views module or in view models module?<br />\n<br />\nOn the one hand, it seems that navigation should be controlled by view model, since the view model contains all UI logic.<br />\n<br />\nOn the other hand, the regions it is something that belongs to visual representation, and if we will control navigation from the view model, our view model will be coupled to region names defined in views.<br />\n<br />\nMoreover, with view first approach we will need to get the view from IoC container and use this view for navigation. This means that we will need some naming conventions, to get views from IoC in view model methods, i.e. again our view model will be depend on views...<br />\n<br />\nAlso, I am not sure, will be view model classes unit testable if it will call the RegionManager methods?<br />\n",
    "PostedDate": "2013-04-16T04:34:12.873-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1031297",
    "ThreadId": "440439",
    "Html": "Hi,\r<br />\n<br />\nFirst, I believe we should make a distinction between &quot;visual logic&quot; and &quot;presentation logic.&quot; Based on my understanding of the <strong>MVP</strong> pattern, the &quot;visual logic&quot; refers to the logic in charge of <strong><em>how to</em></strong> show the information to the user, while the &quot;presentation logic&quot; refers to the logic in charge of <strong><em>what to</em></strong> show to the user. Those are defined in the <strong><em>view</em></strong> and the <strong><em>presenter</em></strong> respectively. In the <strong>MVVM</strong> pattern the <strong><em>view model</em></strong> has similar responsibilities that of a <strong><em>presenter</em></strong>.\r<br />\n<br />\nSince when injecting / navigating to a view you are deciding &quot;what to show&quot;, I believe it's part of the &quot;presentation&quot; logic. So in my opinion, the <strong>RegionManager</strong> should be used in the <strong><em>view model</em></strong>.\r<br />\n<br />\nAlthough regions are used to change the UI composition of the application, when you use the <strong>RegionManager</strong> in the view model you are simply adding an element to a collection or container (the region). The logic to map those elements and manipulate the UI accordingly is encapsulated in the region and is unknown by the view model. Regarding the names of the region, in <strong>WPF</strong> you can define those names in static properties of a common class that can be used in both the view model and the view (thought the <a href=\"http://msdn.microsoft.com/en-us/library/ms742135.aspx\" rel=\"nofollow\">x:static markup extension</a>.) This can also be done in <strong>Silverlight 5</strong> creating your own markup extension.\r<br />\n<br />\nRegarding the resolution of views through the container in the view model, I believe this will depend mostly on how you use the container. First, the view model does not create or configure those views directly (the creation is performed by the container,) hence the only relation between the view model and views will be the view type. However, this can also be worked around by exporting the views through an interface or using a string to identify the view instead of the type. Once again, the view model can be completely decoupled from the views: you ask the container for an <strong><em>object</em></strong> (the view) and add that object to a <strong><em>collection</em></strong> (the region.) What's more, when using the navigation approach, the view model do not even need to obtain the instances of the views.\r<br />\n<br />\nFinally, regarding the testability of the view model, the <strong>RegionManager</strong> implements an <strong>IRegionManager</strong> interface. By default the <strong>RegionManager</strong> is mapped to this interface in the container, so when you ask the container for an <strong>IRegionManager</strong> it returns the corresponding instance. However, during a test, you can map a different object to the <strong>IRegionManager</strong> interface (e.g. a mock region manager), allowing you to decouple the view model from the real <strong>RegionManager</strong> and test it without problems.\r<br />\n<br />\nI hope this answer your concerns,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-04-16T10:47:27.617-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]