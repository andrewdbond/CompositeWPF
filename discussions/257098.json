[
  {
    "Id": "610459",
    "ThreadId": "257098",
    "Html": "\r\n<p>Hi,</p>\r\n<p><br>\r\nI'm pretty new with Prism and after playing a bit around, there a few questions that arise. I'm trying to create a modular application that basically contains a map control in a shell window. The plugin modules offer different tools for interacting with the\r\n map. Some of the modules are pretty independent and simply display pins on the map.</p>\r\n<p><br>\r\n- 1st question: How would RegionManager come into play for the module-specific classes (presenters) that must interact with the main map control? Usually in a RegionManager you register a specific view which is linked to a ViewModel, but in my case there is\r\n one single view (the map view) with multiple presenters acting on it.</p>\r\n<p><br>\r\n- 2nd question: I need to be able to open several windows (shells) -- a bit like an MS Word document -- that should all be extended by the plugin modules. In a single-shell environment, when the module specific classes were instantiated, they could use the\r\n Dependency Injection Container to get a reference to the RegionManager or the Shell itself in order to get access to the map control. However with multiple shells, I don't see how to get access to the map control of the right shell. The dependency container\r\n has references to object global to the application, not specific for the shell I'm currently working in. Same is true for the EventAggregator.</p>\r\n<p><br>\r\nAny input would be very welcome,<br>\r\nEd</p>\r\n",
    "PostedDate": "2011-05-10T12:08:19.757-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "610618",
    "ThreadId": "257098",
    "Html": "<p>To make my 2nd question a bit more clear:&nbsp;Chrome &amp; Firefox can have plugins that add new visual elements to the toolbars, etc. Each time you open a new browser window, they all contain the extensions applied by the plugins. So that's pretty much what I'm trying to achieve when I say open several windows.</p>",
    "PostedDate": "2011-05-10T15:43:24.487-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "611172",
    "ThreadId": "257098",
    "Html": "<p>After hours of reading Prism-related articles and forums I've come across the article \"How to build an outlook style application\" on Erwin van der Valk's Blog (http://blogs.msdn.com/b/erwinvandervalk/archive/2009/03/02/how-to-build-an-outlook-style-application.aspx).&nbsp;</p>\n<p>In one part of the architecture, a Unity Child Container was used to resolve type instances. That's exactly what I needed for the answer to my 2nd question: I needed to have \"scoped\" (by window) dependency injection (ex: window scoped EventAggregator, Map  control, etc.).</p>\n<p>Here's how I create a new window:</p>\n<p>&nbsp;</p>\n<div style=\"color: black; background-color: white;\">\n<pre>    <span style=\"color: blue;\">private</span> IShellWindow CreateNewShell(IRegionManager regionManager)\n    {\n      IUnityContainer childContainer = <span style=\"color: blue;\">this</span>.Container.CreateChildContainer();\n\n      ... register types <span style=\"color: blue;\">in</span> child container ...      \n\n      <span style=\"color: blue;\">var</span> window = <span style=\"color: blue;\">new</span> ShellWindow();\n      RegionManager.SetRegionManager(window, regionManager);\n      window.Content = childContainer.Resolve&lt;MapDocumentView&gt;();\n      <span style=\"color: blue;\">return</span> window;\n    }\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>So MapDocumentView and all its components will be injected (if needed) window-scoped instances.<br /> Now that I can have scoped injected objects, I can get the window-scoped map in my module-based MapPresenter. To answer my 1st question, I defined an interface IHostApplication which is implemented by the Bootstrapper which has a MapPresenterRegistry property.  This interface is added to the main container. &nbsp;Upon initialization, the modules will register their presenters and upon the window creation, they will be instantiated.</p>\n<p>So for the module initialization:</p>\n<div style=\"color: black; background-color: white;\">\n<pre>    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> Initialize() \n    {\n      ...\n      <span style=\"color: blue;\">this</span>.hostApplication.MapPresenterRegistry.Add(<span style=\"color: blue;\">typeof</span>(ModuleSpecificMapPresenter));\n      ...\n    }\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>The code that initializes the map window:</p>\n<div style=\"color: black; background-color: white;\">\n<pre>    <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">void</span> View_Loaded(<span style=\"color: blue;\">object</span> sender, RoutedEventArgs e)\n    {\n      <span style=\"color: green;\">// Register map in the == scoped container ==</span>\n      container.RegisterInstance&lt;IMap&gt;(<span style=\"color: blue;\">this</span>.View.Map);\n      \n      <span style=\"color: green;\">// Create map presenters</span>\n      <span style=\"color: blue;\">var</span> hostApplication = <span style=\"color: blue;\">this</span>.container.Resolve&lt;IHostApplication&gt;();\n      <span style=\"color: blue;\">foreach</span> (<span style=\"color: blue;\">var</span> mapPresenterType <span style=\"color: blue;\">in</span> hostApplication.MapPresenterRegistry)\n      {\n        <span style=\"color: blue;\">var</span> mapPresenter = <span style=\"color: blue;\">this</span>.container.Resolve(mapPresenterType) <span style=\"color: blue;\">as</span> IMapPresenter;\n        <span style=\"color: blue;\">if</span> (mapPresenter != <span style=\"color: blue;\">null</span>)\n        {\n          <span style=\"color: blue;\">this</span>.mapPresenters.Add(mapPresenter);\n        }\n      }\n    }\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>The module-specific MapPresenter:</p>\n<div style=\"color: black; background-color: white;\">\n<pre>    <span style=\"color: blue;\">public</span> ModuleSpecificMapPresenter(IEventAggregator eventAggregator, IMap map)\n    {\n      <span style=\"color: blue;\">this</span>.eventAggregator = eventAggregator;\n      <span style=\"color: blue;\">this</span>.map = map;\n      <span style=\"color: blue;\">this</span>.eventAggregator.GetEvent&lt;AWindowSpecificEvent&gt;().Subscribe(<span style=\"color: blue;\">this</span>.WindowSpecificEventFired);\n      \n      <span style=\"color: green;\">// Do stuff on with the map</span>\n    }\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>So those are the big lines of my solution. What I don't really like is that I don't take advantage of region management this way. I pretty much have custom code to do the work.<br /> If you have any further thoughts, I would be happy to hear them out.</p>\n<p>Ed</p>",
    "PostedDate": "2011-05-11T12:28:22.793-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]