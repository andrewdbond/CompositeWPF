[
  {
    "Id": "822895",
    "ThreadId": "352043",
    "Html": "\r\n<p>A quote from Chapter 4: Modular Application Development</p>\r\n<p>&nbsp;(<a href=\"http://msdn.microsoft.com/en-us/library/gg405479%28PandP.40%29.aspx#sec24\">http://msdn.microsoft.com/en-us/library/gg405479%28PandP.40%29.aspx#sec24</a>)</p>\r\n<p><em>&quot;It may also ask the container to resolve an instance of a type it needs.&quot;</em><br>\r\n<strong>What is the best way to achive this?</strong></p>\r\n<p>I have a concrete example of this worked out.<br>\r\nIt is a small&nbsp;extension&nbsp;on top of the Modularity with MEF Quickstart.<br>\r\nIt can be found here:</p>\r\n<p>https://skydrive.live.com/redir.aspx?cid=fd27ecf1a68dc889&amp;resid=FD27ECF1A68DC889!134&amp;parid=FD27ECF1A68DC889!131</p>\r\n<p>Summary of the changes:&nbsp;<br>\r\n- new assembly&nbsp;LibforModuleE with Class1.cs, has [Export] attribute<br>\r\n- ModuleE references Class1 in LibforModuleE.dll&nbsp;(LibForModuleE.dll is copied along ModuleE in it's post-build step)<br>\r\n- Class1 logs and therefore [Import]s the ILoggerFacade<br>\r\n- During the initialisation of ModuleE, a call is made into Class1 (ModuleE.cs line 54)<br>\r\n- Since the ILoggerFacade&nbsp;never got imported in Class1, the application crashes during the initialization of ModuleE<br>\r\n(Class1.cs line 15)</p>\r\n<p>Given:</p>\r\n<p>- I cannot add a hard reference from the main&nbsp;ModularityWithMef.Desktop assembly to the LibForModuleE assembly<br>\r\n(then I could - in ConfigureAggregateCatalog -&nbsp;add that assembly to the AggregateCatalog )&nbsp;<br>\r\n- the LibforModuleE.dll is not in the&nbsp;<em>DirectoryModules</em>&nbsp;sub folder<br>\r\n(then the DirectoryCatalog would have picked it up)&nbsp;</p>\r\n<p>These 2 solutions would&nbsp;void&nbsp;the&nbsp;<em>on-demand</em>&nbsp;aspect of ModuleE (and its dependencies)</p>\r\n<p>What is the canonical way of getting the ILoggerInterface imported into Class1,<br>\r\nin other words: how to ask the container to resolve the ILoggerFacade?&nbsp;</p>\r\n<p>Bonus question: next to importing the necessary ILoggerFacade into Class1, <br>\r\nit there a way to <em>add&nbsp;Class1 itself</em> into the container during the initialisation of ModuleE,<br>\r\nso that some other class (e.g. Class2) can then&nbsp;<em>import</em> an instance of the exported Class1?</p>\r\n<p>Thanks in advance!</p>\r\n<p>Jan Verley</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2012-04-12T06:59:41.703-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "823085",
    "ThreadId": "352043",
    "Html": "<p>Hi,</p>\n<p>We checked the sample you provided, and we found that the cause of this problem is that the parts of the <strong>LibforModuleE.dll</strong> are not being discovered by <strong>MEF</strong>, and therefore you won't be able to resolve an instance of <strong>Class1 </strong>from the container.</p>\n<p>Hence, you might have to discover the parts in your <strong>LibforModuleE.dll</strong> assembly explicitly.</p>\n<p>As you mentioned, this could be achieved using the <strong>AggregateCatalog </strong> class provided by <strong>MEF</strong>. In my opinion, to avoid loosing the <em>on-demand</em> aspect of <strong>ModuleE </strong>(not overriding the <strong>ConfigureAggregateCatalog</strong>), you could retrieve the <strong>AggregateCatalog </strong>instance as a dependency in your <strong>ModuleE</strong>'s constructor. This way you could register the missing parts from the <strong>LibforModuleE.dll</strong> when the module is loaded. An example of this could be like in the following code snippet:</p>\n<p>&nbsp;</p>\n<div style=\"color: black; background-color: white;\">\n<pre>[ModuleExport(<span style=\"color: blue;\">typeof</span>(ModuleE))]\n    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">class</span> ModuleE : IModule\n    {\n    (...)\n\n        <span style=\"color: blue;\">private</span> <span style=\"color: blue;\">readonly</span> AggregateCatalog catalog;\n\n    (...)\n\n[ImportingConstructor]\n        <span style=\"color: blue;\">public</span> ModuleE(IModuleTracker moduleTracker,<strong>AggregateCatalog </strong>catalog)\n        {\n            <span style=\"color: blue;\">this</span>.catalog = catalog;\n            <span style=\"color: blue;\">this</span>.catalog.Catalogs.Add(<span style=\"color: blue;\">new</span> AssemblyCatalog(<span style=\"color: blue;\">typeof</span>(Class1).Assembly));\n    (...)\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>Once the part is added to the catalog you will be able to retrieve the exported types from the container. For example in <strong>ModuleE</strong>, <strong>Initialize </strong>method or&nbsp; from other class that requires it.</p>\n<p>To retrieve the desired exported class you could access the container via the <strong> ServiceLocator</strong>. For example like this:</p>\n<p>&nbsp;</p>\n<div style=\"color: black; background-color: white;\">\n<pre><span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> Initialize()\n        {\n            <span style=\"color: blue;\">var</span> testInstance = ServiceLocator.Current.GetInstance&lt;Class1&gt;();\n            testInstance.Test();\n    (...)\n</pre>\n</div>\n<p>&nbsp;</p>\n<p><em>Note that if you don't retrieve the class from the container, the imports will not be satisfied.</em></p>\n<p>Additionally for more information you could check the <a href=\"http://mef.codeplex.com/wikipage?title=Guide&amp;referringTitle=Home\"> MEF Programming Guide</a>.</p>\n<p>I hope you find this useful,</p>\n<p>Agustin Adami<a href=\"http://blogs.southworks.net/aadami\"><br /> http://blogs.southworks.net/aadami</a></p>",
    "PostedDate": "2012-04-12T12:59:26.933-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "823465",
    "ThreadId": "352043",
    "Html": "<p>Hi,</p>\r\n<p>I was aware of the root of the problem: the non-discovery by MEF of Class1.<br /><br />Your proposed solution works indeed! <br />I was <em>not</em> aware that<br />- the AggregateCatalog was available as a part in the Container (it feels a bit circular/recursive)<br />- adding types to the AggregateCatalog was possible/made sense at this moment, long after the bootstrapper had finished.</p>\r\n<p>1 final question:&nbsp;<br />Is it possible to avoid the dependency on the ServiceLocator to <em>retrieve the class from the container </em>and use a more <em>pure MEF</em>&nbsp;method?<br />And if not, is the use of the static ServiceLocator.Current not an issue when writing unit tests?<br />As far as I understand, this makes it impossible to <em>inject&nbsp;the dependency</em>?</p>\r\n<p>Thanks!</p>\r\n<p>Jan</p>",
    "PostedDate": "2012-04-13T07:20:05.323-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "823558",
    "ThreadId": "352043",
    "Html": "<p>Hi Jan,</p>\r\n<p>Based on my understanding you will be able to retrieve the <strong>Class1 </strong>from the container using <strong>MEF </strong>conventional methods from any class in the module's project as long as it is resolved after the library assembly is discovered (i.e. when the module's constructor completes). For example any view or view model classes which have a dependency to <strong>Class1 </strong>should be able to resolve it without problems.</p>\r\n<p>Although, this will not be possible if you need to resolve a class which contains a dependency to the exported <strong>Class1 </strong>in your <strong>IModule</strong>'s class; as far as I now, for this case you will have to do it through the <strong>ServiceLocator</strong>. Also, if you wish to test the aforementioned module class using the <strong>ServiceLocator </strong>will involve having an additional dependency to mock (i.e. the service locator).</p>\r\n<p>Regards,</p>\r\n<p>Agustin Adami<a href=\"http://blogs.southworks.net/aadami\"><br /> http://blogs.southworks.net/aadami</a></p>",
    "PostedDate": "2012-04-13T10:40:13.843-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]