[
  {
    "Id": "179247",
    "ThreadId": "53284",
    "Html": "I am using on demand loading to load a module that has services not view composition. For example:<div><br></div><div><div>modManager.LoadModule(&quot;EMailService&quot;);</div><div>IEmailService emailer = boot.Container.Resolve&lt;IEmailService&gt;();</div><div><br></div><div>The problem is that the LoadModule isn't synchronous so the resolution fails (this code is called before the Initialize of the module is called to register the type). Is there any way to do this? I want to load the module and wait on the loading of the module so I can resolve a type.  Right now its hit and miss...I could enter a wait state but I don't have anything to wait on.  </div><div><br></div><div>Ideas?</div></div>",
    "PostedDate": "2009-04-14T15:15:05.267-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "179799",
    "ThreadId": "53284",
    "Html": "<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\">Hi, </span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\">You are absolutely right, in Silverlight prism applications modules that are loaded on demand are downloaded a<span style=\"color:#30332d\">synchronously. Unfortunately the <b>ModuleLoader</b> class does not provide any event to signal that a module has been loaded. Moreover the <b>ModuleLoader</b> class has no virtual method</span><span style=\"color:#1f497d\">s </span>that be can overridden to add this functionality. Implementing a custom <b>IModuleManager</b> and <b>IModuleTypeLoader</b> could be another solution. A more straightforward approach would be coding it in the modules<span style=\"color:#30332d\"> as follows:</span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"color:#30332d;font-family:calibri\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\"><span style=\"color:#30332d\">I believe the best way to keep modules decoupled is using the <b>EventAggregator</b> to publish and subscribe to an event when the module is loaded. So you should do 2 things: Publish a <b>ModuleLoadedEvent</b> when the module is loaded and subscribe it to execute code that depends on that module. One way of doing this could be</span><span style=\"color:#1f497d\">:</span> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"color:#30332d\"><span style=\"font-family:calibri\">1.</span><span style=\"font:7pt 'times new roman'\">       </span><span style=\"font-family:calibri\"><span style=\"color:#30332d\">Define a </span><b>ModuleLoadedEvent </b>as explained in the <a href=\"http://msdn.microsoft.com/en-us/library/dd458942.aspx\">How to: Create and Publish Events</a>. </span>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span><span style=\"font-family:calibri\">2.</span><span style=\"font:7pt 'times new roman'\">       </span></span><span style=\"font-family:calibri\">Publish a <b>ModuleLoadedEvent</b> in the Initialize method of your <b>EMailServiceModule:</b></span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;color:blue;font-family:'courier new'\">public</span><span style=\"font-size:10pt;font-family:'courier new'\"> <span style=\"color:blue\">void</span> Initialize()</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">{</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">    container.RegisterInstance&lt;IEmailService&gt;(<span style=\"color:blue\">new</span> EmailService());</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">    ModuleLoadedEvent moduleLoadedEvent = eventAggregator.GetEvent&lt;ModuleLoadedEvent&gt;();</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">    </span><span style=\"font-size:10pt;font-family:'courier new'\">moduleLoadedEvent.Publish(<span style=\"color:#a31515\">&quot;EMailService&quot;</span>);</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">}</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span><span style=\"font-family:calibri\">3.</span><span style=\"font:7pt 'times new roman'\">       </span></span><span style=\"font-family:calibri\">Handle to the ModuleLoadedEvent </span></p>\r\n<p style=\"margin:0cm 0cm 0pt 36pt\"><span style=\"font-family:calibri\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;color:blue;font-family:'courier new'\">this</span><span style=\"font-size:10pt;font-family:'courier new'\">.moduleManager.LoadModule(<span style=\"color:#a31515\">&quot;</span><span style=\"font-size:10pt;color:#a31515;font-family:'courier new'\">EMailService</span><span style=\"font-size:10pt;color:#a31515;font-family:'courier new'\">&quot;</span><span style=\"font-size:10pt;font-family:'courier new'\">);</span>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">ModuleLoadedEvent moduleLoadedEvent = eventAggregator.GetEvent&lt;ModuleLoadedEvent&gt;();</span></p>\r\n<p style=\"margin:0cm 0cm 12pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">moduleLoadedEvent.Subscribe(ModuleLoadedEventHandler, ThreadOption.PublisherThread, <span style=\"color:blue\">false</span>, FilterModule);</span> </p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span><span style=\"font-family:calibri\">4.</span><span style=\"font:7pt 'times new roman'\">       </span></span><span style=\"font-family:calibri\">Define the Handlers of the event. I have used a Filter to get only the event of the specific module but that is optional.</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;color:blue;font-family:'courier new'\">public</span><span style=\"font-size:10pt;font-family:'courier new'\"> <span style=\"color:blue\">bool</span> FilterModule(String moduleName)</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">{</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 89.4pt\"><span style=\"font-size:10pt;color:blue;font-family:'courier new'\">return</span><span style=\"font-size:10pt;font-family:'courier new'\"> moduleName.Equals(<span style=\"color:#a31515\">&quot;EMailService&quot;</span>);</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">}</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 18.6pt\"><span style=\"font-size:10pt;font-family:'courier new'\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;color:blue;font-family:'courier new'\">public</span><span style=\"font-size:10pt;font-family:'courier new'\"> <span style=\"color:blue\">void</span> ModuleLoadedEventHandler(String moduleName) </span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">{</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 89.4pt\"><span style=\"font-size:10pt;font-family:'courier new'\">var service = <span style=\"color:blue\">this</span>.container.Resolve&lt;IMyService&gt;();</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 89.4pt\"><span style=\"font-size:10pt;color:green;font-family:'courier new'\">// ...</span></p>\r\n<p style=\"margin:0cm 0cm 0pt 54pt\"><span style=\"font-size:10pt;font-family:'courier new'\">}</span> </p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span><span style=\"font-family:calibri\">                You can find a detailed explanation on how to use the </span><a href=\"http://msdn.microsoft.com/en-us/library/dd458915.aspx\"><span style=\"font-family:calibri\">EventAggragator</span></a><span style=\"font-family:calibri\"> in the </span><a href=\"http://msdn.microsoft.com/en-us/library/dd458942.aspx\"><span style=\"font-family:calibri\">How to: Create and Publish Events</span></a><span style=\"font-family:calibri\"> and </span><a href=\"http://msdn.microsoft.com/en-us/library/dd458904.aspx\"><span style=\"font-family:calibri\">How to: Subscribe and Unsubscribe to Events</span></a><span style=\"font-family:calibri\">.</span></span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\">Hope it helps!</span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\"> </span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><span style=\"font-family:calibri\">Matias Bonaventura</span></p>\r\n<p style=\"margin:0cm 0cm 0pt\"><a href=\"http://blogs.southworks.net/\"><span style=\"font-family:calibri\">http://blogs.southworks.net/matiasb</span></a> </p>\r\n</span></p>\r\n</span></p>\r\n",
    "PostedDate": "2009-04-15T13:10:42.493-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "179808",
    "ThreadId": "53284",
    "Html": "Thanks, that makes sense...but....<div><br></div><div>I'd really like to push for a new feature in the next drop to address this. This seems like a common strategy and to have to build all this pumping isn't very friendly.  I'd be happy to submit a patch.</div>",
    "PostedDate": "2009-04-15T13:19:25.473-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "180085",
    "ThreadId": "53284",
    "Html": "Hi,<br>\r\n<br>\r\nI raised an issue about this a while ago [url:3427|http://compositewpf.codeplex.com/WorkItem/View.aspx?WorkItemId=3427]<br>\r\n<br>\r\nI overcame this by altering the ModuleManager.LoadModule method to take a callback. <br>\r\nThis seems to work with the limited testing I've done&nbsp; - I haven't tested modules with dependencies either...<br>\r\n<br>\r\n<br>\r\nie<br>\r\n<br>\r\n{<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private readonly object _lockCallbacks = new object();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private readonly Dictionary&lt;string, Action&gt; _callbacks = new Dictionary&lt;string, Action&gt;();<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;public void LoadModule(string moduleName, Action callback)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IEnumerable&lt;ModuleInfo&gt; module = this.moduleCatalog.Modules.Where(m =&gt; m.ModuleName == moduleName);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (module == null || module.Count() != 1)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ModuleNotFoundException(moduleName, string.Format(CultureInfo.CurrentCulture, Resources.ModuleNotFound, moduleName));<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if module is already loaded just invoke callback <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //otherwise add callback to dictionary to invoke once<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //module is initiallized<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (module.First().State == ModuleState.Initialized)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (callback != null)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callback.Invoke();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (_lockCallbacks)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _callbacks.Add(moduleName, callback);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IEnumerable&lt;ModuleInfo&gt; modulesToLoad = this.moduleCatalog.CompleteListWithDependencies(module);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.LoadModuleTypes(modulesToLoad);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n}<br>\r\n<br>\r\nand altering LoadModulesThatAreReadyForLoad to invoke the callback once loaded<br>\r\n<br>\r\n{<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;private void LoadModulesThatAreReadyForLoad()<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool keepLoading = true;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (keepLoading)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keepLoading = false;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IEnumerable&lt;ModuleInfo&gt; availableModules = this.moduleCatalog.Modules.Where(m =&gt; m.State == ModuleState.ReadyForInitialization);<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (ModuleInfo moduleInfo in availableModules)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this.AreDependenciesLoaded(moduleInfo))<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moduleInfo.State = ModuleState.Initializing;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.InitializeModule(moduleInfo);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keepLoading = true;<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (_lockCallbacks)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Action callback;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var callbackName = moduleInfo.ModuleName;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _callbacks.TryGetValue(callbackName, out callback);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(callback!=null)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callback.Invoke();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _callbacks.Remove(callbackName);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n}\r\n",
    "PostedDate": "2009-04-16T04:49:21.68-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "216721",
    "ThreadId": "53284",
    "Html": "<p>It seems the main problem is how to block the method which calls LoadModule until the module has completed initialisation. &nbsp;Whether we use the event aggregator or callbacks, there needs to be something blocking the UI thread preventing the call to Container.Resolve until this event/callback occurs.</p>\r\n<p>Mark</p>",
    "PostedDate": "2009-07-28T03:56:47.977-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "217145",
    "ThreadId": "53284",
    "Html": "<p>Hi Mark,</p>\r\n<p>Since asych operations are more &quot;queued&quot; then mutli-threaded (everything runs on the UI thread) I found this to be a complex issue for a requirement where I had to have multiple files finish uploading before operations on them started; if I put the thread to sleep - the entire application slept.&nbsp;&nbsp; My work-around was to call a web service (providing the number of files expected) and it contained the loop (where I could put the thread to sleep) that would check for the existence all files before returning.&nbsp; The web service's callback method was responsible for initiating/resuming the file processing.&nbsp;&nbsp; Note: the delay was insignificant in regards to timing out but critical to being there before processing could resume.</p>\r\n<p>One work-around, would be interested in hearing others...</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-07-29T05:23:44.82-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]