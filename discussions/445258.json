[
  {
    "Id": "1049865",
    "ThreadId": "445258",
    "Html": "Hi,<br />\n<br />\nI download this source code &quot;<a href=\"http://www.codeproject.com/Articles/20860/An-Extended-WPF-TabControl\" rel=\"nofollow\"><strong>An Extended WPF TabControl</strong></a>&quot; from the <strong>Code Project</strong> website and I was hoping to use it for the feature of having a single scrowing row.  After studying the logic I found it wouldn't work with <strong>Prism Region Logic</strong>.  So, there's need to be some coding changes to get it to work.<br />\n<br />\nI believe this would be an added enhancement when adding Views to a <strong>TabControl</strong>.  I do have the Prism 4.1 Source but, I'm not knowledgeable of the code and don't know where to start to implement this behavior.<br />\n<br />\nCould this be added to one of your projects for future releases and/or could you direct me in the right direction to implement this myself?   And, after successfully getting it work I could or some else could share it with the <strong>Prism Development Team</strong>?<br />\n<br />\nThe source is located in an assembly called <strong>Wpf.TabControl</strong>; you add it to your project and pretty much do the same thing as the <strong>AnimatedTabControl</strong> except the extended feature.  The logic here is where <strong>TabItems</strong> are being added, but is done manually with its own featured add button:<br />\n<pre><code>        /// &lt;summary&gt;\n        ///     Add a new Header\n        /// &lt;/summary&gt;\n        public void AddTabItem()\n        {\n            if (IsFixedSize)\n                throw new InvalidOperationException(&quot;ItemsSource is Fixed Size&quot;);\n\n            int i = this.SelectedIndex;\n\n            // give an opertunity to cancel the adding of the tabitem\n            CancelEventArgs c = new CancelEventArgs();\n            if (TabItemAdding != null)\n                TabItemAdding(this, c);\n\n            if (c.Cancel)\n                return;\n\n            TabItem tabItem;\n\n            // Using ItemsSource property\n            if (ItemsSource != null)\n            {\n                IList list = (IList)ItemsSource;\n                NewTabItemEventArgs n = new NewTabItemEventArgs();\n                if (NewTabItem == null)\n                    throw new InvalidOperationException(&quot;You must implement the NewTabItem event to supply the item to be added to the tab control.&quot;);\n\n                NewTabItem(this, n);\n                if (n.Content == null)\n                    return;\n\n                if (i == -1 || i == list.Count - 1 || AddNewTabToEnd)\n                    list.Add(n.Content);\n                else\n                    list.Insert(++i, n.Content);\n\n                tabItem = (TabItem)this.ItemContainerGenerator.ContainerFromItem(n.Content);\n            }\n            else\n            {\n                // Using Items Property\n                tabItem = new TabItem { Header = &quot;New Tab&quot; };\n\n                if (i == -1 || i == this.Items.Count - 1 || AddNewTabToEnd)\n                    this.Items.Add(tabItem);\n                else\n                    this.Items.Insert(++i, tabItem);\n            }\n\n            if (TabItemAdded != null)\n                TabItemAdded(this, new TabItemEventArgs(tabItem));\n        }</code></pre>\n\nHere's is the logic for creating the Button for the AddTabItem:<br />\n<pre><code>...\n..\n.\n       [TemplatePart(Name = &quot;PART_NewTabButton&quot;, Type = typeof(ButtonBase))]\n        public override void OnApplyTemplate()\n        {\n            base.OnApplyTemplate();\n\n...\n..\n.\n        private void SetAddNewButtonVisibility()\n        {\n            if (this.Template == null)\n                return;\n\n            ButtonBase button = this.Template.FindName(&quot;PART_NewTabButton&quot;, this) as ButtonBase;\n            if (button == null) return;\n\n            if (IsFixedSize)\n                button.Visibility = Visibility.Collapsed;\n            else\n                button.Visibility = AllowAddNew\n                                        ? Visibility.Visible\n                                        : Visibility.Collapsed;\n        }\n\n....\n...\n.\n            // set up the event handler for the 'New Tab' Button Click event\n            _addNewButton = this.Template.FindName(&quot;PART_NewTabButton&quot;, this) as ButtonBase;\n            if (_addNewButton != null)\n                _addNewButton.Click += ((sender, routedEventArgs) =&gt; AddTabItem());\n        }\n</code></pre>\n\nI need an event that would trigger this logic to add the TabItem to its internal list in order to create the Scroll button.  I will be removing the logic to create the tabs manually.  So I need to understand how <strong>Prism</strong> creates tabs when adding a <strong>View</strong> to a <strong>Region</strong>.<br />\n<br />\nGetting this to work with <strong>Prism</strong> would be a awesome feature to the <strong>TabControl</strong> and for the community.<br />\n",
    "PostedDate": "2013-05-28T18:09:33.24-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1050242",
    "ThreadId": "445258",
    "Html": "Hi,\r<br />\n<br />\nBased on my understanding, the default implementation of <strong>TabControl</strong> in WPF inherits from <strong>Selector</strong> type. Therefore, Prism provides a specific region adapter for selectors, called <strong>SelectorRegionAdapter</strong>.<br />\n<h1></h1>\n<ul>\n<li>\nThe <strong>SelectorRegionAdapter</strong> is in charge of creating the region, wiring up to the selector (in this case, your TabControl), and attach the <strong>SelectorItemsSourceSyncBehavior</strong> behavior.<br />\n</li>\n<li>\nThe <strong>SelectorItemsSourceSyncBehavior</strong> is in charge of subscribing to the region events in order to react upon them and synchronize the <strong>Selector</strong> items with the region <strong>Views</strong>. The following code describes how this behavior add items to your <strong>Selector</strong> when <strong>Views</strong> are added to the region.<br />\n</li>\n</ul>\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">void</span> Views_CollectionChanged(<span style=\"color:Blue;\">object</span> sender, NotifyCollectionChangedEventArgs e)\n{\n    <span style=\"color:Blue;\">if</span> (e.Action == NotifyCollectionChangedAction.Add)\n    {\n        <span style=\"color:Blue;\">int</span> startIndex = e.NewStartingIndex;\n        <span style=\"color:Blue;\">foreach</span> (<span style=\"color:Blue;\">object</span> newItem <span style=\"color:Blue;\">in</span> e.NewItems)\n        {\n            <span style=\"color:Blue;\">this</span>.hostControl.Items.Insert(startIndex++, newItem);\n        }\n    }\n...\n}\r\n</pre></div>As you can see, when a <strong>View</strong> is added to the region, and that region is a <strong>Selector</strong>, a new item is added to the selector corresponding to that <strong>View</strong>.\r<br />\n<br />\nYou can find those classes in the <strong>Prism Library</strong>, under the namespaces <strong>Microsoft.Practices.Prism.Regions</strong> and <strong>Microsoft.Practices.Prism.Regions.Behaviors</strong>.\r<br />\n<br />\nHope this helps,\r<br />\n<br />\nFederico Martinez \r<br />\n<a href=\"http://blogs.southworks.net/fmartinez\" rel=\"nofollow\">http://blogs.southworks.net/fmartinez</a> <br />\n",
    "PostedDate": "2013-05-29T11:24:43.52-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1050460",
    "ThreadId": "445258",
    "Html": "Thanks for the reply!\r<br />\n<br />\nI will dive into it and see if I can get this to work.<br />\n",
    "PostedDate": "2013-05-29T23:37:27.247-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]