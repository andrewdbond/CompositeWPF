[
  {
    "Id": "1037799",
    "ThreadId": "442129",
    "Html": "My application requires &quot;popup&quot; windows on two distinct occassions:<br />\n<ol>\n<li>User clicks on an item in a vew to display more details.</li>\n<li>\nAn event is caught and displays a details view immediately to the user.<br />\n</li>\n</ol>\nI have used this article (<a href=\"http://blogs.southworks.net/aadami/2012/05/09/prism-interactionrequest-and-popupmodalwindowaction-for-wpf-applications\" rel=\"nofollow\">PopupModalWindowAction</a>) to be able to display a single popup in either case. However, in the second case (event displays view), I need the ability to display multiple non-modal dialogs, as these events often come in several at a time.<br />\n<br />\nI'm using the same View and ViewModel for both popups, but one is modal (when you click on an item) and the other is non-modal. The ViewModel that raises the request passes in an object as part of the request to be displayed by the popup. I previously set this in the context so the ViewModel had a parameterless constructor, but once I added the second type of popup, I realized that this would probably cause an issue, as the requests are raised in different views/ViewModels depending on their initiator.<br />\n<br />\nFirst off, is this the correct approach for this type of popup or should I use the popup behavior?<br />\n<br />\nIn the article, it is mentioned that this could be achieved:<br />\n<blockquote>\n<em>Currently this could be achieved by creating a new custom window in the PopupModalWindowAction each time the InteractionRequest is raised, this is why the default windows implementation can be re open without problems.</em> <br />\n</blockquote>\nHowever, I'm uncertain exactly where to implement this. How should the PopupWindowAction class change to implement this?<br />\n<br />\nThanks<br />\n-g<br />\n",
    "PostedDate": "2013-04-30T13:17:36.743-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1038729",
    "ThreadId": "442129",
    "Html": "Hi,\r<br />\n<br />\nBased on my understanding, the author of the article was referring to a limitation of the <strong><em>popup action</em></strong> when defining a custom <strong>Window</strong> in it, where the <strong>Window</strong> could be used only once during the lifetime of the application. The default implementations of the <strong><em>popup action</em></strong> for <strong>Notifications</strong> and <strong>Confirmations</strong> do not have this problem, as they can be reused multiple times (but not at the same time.)\r<br />\nHowever, as long as you only need to show a message in the from of a <strong>Notification</strong>, I believe you could find the following blog post interesting, where an improved version of this behavior is described:<br />\n<ul>\n<li>\n<a href=\"http://blogs.southworks.net/dcherubini/2012/05/24/popupwindowaction-using-custom-views-instead-of-windows-in-wpf-and-prism/\" rel=\"nofollow\">PopupWindowAction: using custom views instead of windows in WPF and Prism</a><br />\n</li>\n</ul>\nIn the sample included in the aforementioned blog post, you should see that when clicking the <strong>Raise Default Notification</strong> button you are able to show several non-modal notifications as popups at the same time. Also, this popup includes the feature of defining if the popup should be modal or not through a XAML property.\r<br />\n<br />\nI hope this helps,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-05-02T12:23:06.743-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1042968",
    "ThreadId": "442129",
    "Html": "Thanks for your feedback, DCherubini. I had previously followed the link in the original article to the article you mentioned. I am using the implementation described in that article, but still unable to display multiple instances of the popup. To provide more context, I have the following:<br />\n<h1>Parent class that displays the modal popup when a listbox item is clicked</h1>\n<pre><code>&lt;UserControl&gt;\n      &lt;i:Interaction.Triggers&gt;\n        &lt;prism:InteractionRequestTrigger SourceObject=&quot;{Binding DetailsRequest, Mode=OneWay}&quot;&gt;\n            &lt;modal:PopupWindowAction IsModal=&quot;False&quot; CenterOverAssociatedObject=&quot;False&quot; InitialHeight=&quot;300&quot; InitialWidth=&quot;500&quot;&gt;\n                &lt;modal:PopupWindowAction.WindowContent&gt;\n                    &lt;views:ResponseDetailsView /&gt;\n                &lt;/modal:PopupWindowAction.WindowContent&gt;\n            &lt;/modal:PopupWindowAction&gt;\n        &lt;/prism:InteractionRequestTrigger&gt;\n    &lt;/i:Interaction.Triggers&gt;\n    \n    &lt;Grid&gt;&lt;ListBox x:Name=&quot;responses&quot; SelectedItem=&quot;{Binding Selected}&quot; ItemsSource=&quot;{Binding Responses}&quot; ItemContainerStyle=&quot;{StaticResource ResponseListBoxItemStyle}&quot; ScrollViewer.HorizontalScrollBarVisibility=&quot;Disabled&quot;&gt;\n                  &lt;ItemsControl prism:RegionManager.RegionName=&quot;{x:Static inf:RegionNames.ResponseDetailRegion}&quot;\n                      prism:RegionManager.RegionContext=&quot;{Binding Selected}&quot; /&gt;\n    &lt;/Grid&gt;\n&lt;/UserControl&gt;\n</code></pre>\n\n<h1>Corresponding ViewModel for the above View</h1>\n<pre><code>public class ResponsesViewModel : ViewModelBase, IActiveAware\n    {\n        public ResponsesViewModel() { // Init commands and InteractionRequests }\n        public ObservableCollection&lt;ResponseItem&gt; Responses { get; private set; }\n\n        public ResponseItem Selected { // getter and setter with RaisePropertyChange on setter }\n        public bool IsActive { ... }\n        public InteractionRequest&lt;ResponseDetailViewModel&gt; DetailsRequest { get; private set; }\n        public ICommand DisplayDetailsCommand { get; private set; }\n        private void DisplayDetails(ResponseItem item)\n        {\n            // Here is where I raise the Notification Request. The second one does not show up\n            this.DetailsRequest.Raise(new ResponseDetailViewModel(item)\n            { \n                Title = string.Format(&quot;{0}: {1}&quot;, item.ResponseType.GetDescription(), item.TCN)\n            });\n\n            this.DetailsRequest.Raise(new ResponseDetailViewModel(item)\n            {\n                Title = string.Format(&quot;{0}: {1}&quot;, &quot;DUPE&quot;, item.TCN)\n            });\n        }\n\n        private void Activate() { // Do first time setup for UI }\n        private void LoadResponsesFromRepository() { ... }\n        private void Initialize() { .... }\n        private void OnResponseReceived(ResponseEventArgs e) { ... }\n        public event EventHandler IsActiveChanged;\n        private bool _isActive = false;\n        private ResponseItem _selected;\n    }</code></pre>\n\n<h1>Custom View for popup</h1>\n<pre><code>&lt;UserControl&gt; \n    &lt;i:Interaction.Triggers&gt;\n        &lt;i:EventTrigger EventName=&quot;Loaded&quot;&gt;\n            &lt;i:InvokeCommandAction Command=&quot;{Binding OnLoadedCommand}&quot; /&gt;\n        &lt;/i:EventTrigger&gt;\n    &lt;/i:Interaction.Triggers&gt;\n        &lt;Grid&gt;\n                     &lt;Image Source=&quot;{Binding Image, Converter={c:PathToBitmapImageThumbnailConverter}}&quot; /&gt;\n            &lt;/Grid&gt;\n&lt;!-- Other data display --&gt;\n&lt;/UserControl&gt;\n</code></pre>\n\n<h1>Notification ViewModel</h1>\n<pre><code>    public class ResponseDetailViewModel : Notification, IPopupWindowActionAware, INotifyPropertyChanged\n    {\n        public ResponseDetailViewModel(ResponseItem response) { // Init Commands }\n        public ResponseItem Response { get; set; } // NotificationPropertyChanged event\n        public string OriImage { get; set; } // NotificationPropertyChanged event\n        public ICommand OnLoadedCommand { get; private set; }\n        public ObservableCollection&lt;TransactionInfo&gt; ResponseInfo { get; set; }\n        public System.Windows.Window HostWindow { get; set; }\n        public Notification HostNotification { get; set; }\n        public event PropertyChangedEventHandler PropertyChanged;\n        private void OnLoaded() { // Load Data }\n        private void RaisePropertyChanged(string property) { // General property change raising code }\n}</code></pre>\n\nIn the above scenario, I only have the double event InteractionRequest in there for testing. However, I have another view that handles the other scenario where multiple requests would need to be raised. This is what it looks like:<br />\n<h1>Parent UserControl that needs to display multiple instances of popup</h1>\n<pre><code>&lt;UserControl&gt;\n    &lt;i:Interaction.Triggers&gt;\n        &lt;prism:InteractionRequestTrigger SourceObject=&quot;{Binding NotificationRequest, Mode=OneWay}&quot;&gt;\n            &lt;modal:PopupWindowAction IsModal=&quot;False&quot; CenterOverAssociatedObject=&quot;False&quot; InitialHeight=&quot;300&quot; InitialWidth=&quot;500&quot;&gt;\n                &lt;modal:PopupWindowAction.WindowContent&gt;\n                    &lt;views:ResponseDetailsView /&gt;\n                &lt;/modal:PopupWindowAction.WindowContent&gt;\n            &lt;/modal:PopupWindowAction&gt;\n        &lt;/prism:InteractionRequestTrigger&gt;\n    &lt;/i:Interaction.Triggers&gt;\n    &lt;Grid&gt; &lt;!-- Controls to show other stuff --&gt;    &lt;/Grid&gt;\n&lt;/UserControl&gt;\n</code></pre>\n\n<h1>ViewModel for above View</h1>\n<pre><code>    public class TmRootViewModel : NotificationObject    {\n        public TmRootViewModel() {\n        {\n           // This event is caught here every time a new Response is received.\n           // This requires multiple popups to display each new response object\n            CompositeEventHelper.Subscribe&lt;ResponseReceivedEvent, ResponseEventArgs&gt;(OnResponseReceived);\n\n            NotificationRequest = new InteractionRequest&lt;ResponseDetailViewModel&gt;();\n        }\n\n        // This is the method that gets called each time the above event is caught\n       // I put the code below to test for multiple popups\n        private void OnResponseReceived(ResponseEventArgs e)\n        {            \n            Application.Current.Dispatch(() =&gt;\n                {\n                    this.NotificationRequest.Raise(new ResponseDetailViewModel(response)\n                    {\n                        Title = string.Format(&quot;{0}: {1}&quot;, e.ResponseType.GetDescription(), response.Data)\n                    });\n\n                    this.NotificationRequest.Raise(new ResponseDetailViewModel(response)\n                    {\n                        Title = string.Format(&quot;{0}: {1}&quot;, &quot;DUPE&quot;, response.Data)\n                    });\n                });\n        }\n\n        public InteractionRequest&lt;ResponseDetailViewModel&gt; NotificationRequest { get; private set; }\n    }\n}</code></pre>\n\nSo...as you can see from the above code and comments, I need to be able to display multiple non-modal dialogs in once scenario. Is there a way to do this using InteractionRequests, or would I need to look at a different way of doing this altogether? I understand from your comments on your article, that the popup view are created before the interaction request is raised, and that is why only a single instance can be displayed utilizing this code. I'm not well versed in WPF, so I'm unsure of a fix for this. Can you possible recommend a work around, or a different approach?<br />\n<br />\n&lt;Edit&gt;<br />\nAfter looking at the StockTrader RI again, I don't think the popup behavior it uses would be able to meet my requirements either. It appears that it would only be able to display one view at a time as well.<br />\n&lt;/Edit&gt;<br />\nThanks<br />\n-G<br />\n",
    "PostedDate": "2013-05-13T10:40:02.97-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1043491",
    "ThreadId": "442129",
    "Html": "I did some more coding and poking around this morning. I had previously thought that it was an issue with a new Window not being created, but I found that is not the case. I found that the WindowContent.Parent changes during the second call to the PopupWindowAction.Invoke, so I guess that the parent change simply moves that object into the new parent and removes it from the old parent.\r<br />\n<br />\nI found a hack to make it do what I need it to do, for now. However, it breaks the MVVM pattern.\r<br />\n<br />\nIn my ViewModel that needs to display multiple controls at once, I changed the code that raises the request to expliciently create new content.<br />\n<pre><code> this.NotificationRequest.Raise(new ResponseDetailViewModel(response)\n                    {\n                        Title = string.Format(&quot;{0}: {1}&quot;, e.ResponseType.GetDescription(), response.Data),\n                        Content = new CustomView()\n                    });\n</code></pre>\n\nI also had to change the XAML for the parent control to just use a Notification.<br />\n<pre><code>&lt;i:Interaction.Triggers&gt;\n        &lt;prism:InteractionRequestTrigger SourceObject=&quot;{Binding NotificationRequest, Mode=OneWay}&quot;&gt;\n            &lt;modal:PopupWindowAction IsModal=&quot;False&quot; CenterOverAssociatedObject=&quot;True&quot; InitialHeight=&quot;300&quot; InitialWidth=&quot;500&quot; /&gt;\n        &lt;/prism:InteractionRequestTrigger&gt;\n    &lt;/i:Interaction.Triggers&gt;</code></pre>\n\nAs you can see from the above code, I also added initial height and width dependency properties so that the window would display at a reasonable size, even with content that might stretch the UI beyond the screen.\r<br />\n<br />\nTo take care of loading the info in the control when it is loaded, I already had an interaction trigger for the Loaded event that calls a command on the ViewModel. I had added that on the DefaultNotificationWindow in my test code, but since I already had that in my code, I was able to remove it from the DefaultNotificationWindow and rely soley on the Loaded command of the CustomView.<br />\n<pre><code>    &lt;i:Interaction.Triggers&gt;\n        &lt;i:EventTrigger EventName=&quot;Loaded&quot;&gt;\n            &lt;i:InvokeCommandAction Command=&quot;{Binding OnLoadedCommand}&quot; /&gt;\n        &lt;/i:EventTrigger&gt;\n    &lt;/i:Interaction.Triggers&gt;</code></pre>\n\nI'm sure there is a better and cleaner way to do this, but for not this will have to do, as deadlines approach. :)\r<br />\n<br />\n-g<br />\n",
    "PostedDate": "2013-05-14T11:10:33.47-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1043492",
    "ThreadId": "442129",
    "Html": "Hi,\r<br />\n<br />\nThat is right, when defining a view to be used in the <strong>PopupWindowAction</strong>, you are passing an instance of that view in <strong>XAML</strong>, and that instance is reused each time the <strong>InteractionRequest</strong> is raised. Hence, as you cannot show the same instance of a view more than once at the same time, you can show only one popup at a time. This is not the case when using the default window for <strong>Notification</strong> as the <strong>PopupWindowAction</strong> creates a new popup for each notification it receives.\r<br />\n<br />\nAlso, as you said, it doesn't seem the <strong>StockTrader</strong>'s popup region will work for this scenario either, as all of its views will be showed in a single window.\r<br />\n<br />\nAs a possible approach, you could modify the <strong>PopupWindowAction</strong> to change how it uses the views so that it could be able to show more than one popup. For example, if the <strong>ResponseDetailsView</strong> is a common view that you will use in several parts of your application, you could modify the <strong>PopupWindowAction</strong> to instantiate create it manually (as it does with the default <strong>Notification</strong> window) according to the view model. Other approach could be to modify the <strong>PopupWindowAction</strong> to receive the view type (using the <a href=\"http://msdn.microsoft.com/en-us/library/ms753322.aspx\" rel=\"nofollow\">x:Type Markup Extension</a>) instead of the view instance. Then, each time the <strong>InteractionRequest</strong> is raised, the action could re-create the view using the <strong>ServiceLocator</strong>, obtaining a different instance for each interaction.\r<br />\n<br />\nRegards,\r<br />\n<br />\nDamian Cherubini\r<br />\n<a href=\"http://blogs.southworks.net/dcherubini\" rel=\"nofollow\">http://blogs.southworks.net/dcherubini</a><br />\n",
    "PostedDate": "2013-05-14T11:14:22.473-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1043504",
    "ThreadId": "442129",
    "Html": "Thanks for the response. I had thought about a way to use service location to instantiate the view, but I was unsure where to implement it. \r<br />\n<br />\nI will have to look into the Markup Extension a little more. I've used it only to make ValueConverters a little easier to deal with in XAML.\r<br />\n<br />\nI'll post back when I've had time to play around.\r<br />\n<br />\nThanks\r<br />\n-g<br />\n",
    "PostedDate": "2013-05-14T11:54:15.92-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]