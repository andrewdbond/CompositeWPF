[
  {
    "Id": "1207869",
    "ThreadId": "531707",
    "Html": "Hi,\r<br />\n<br />\nI develop a MEF application with Prism 4.5.1 and I have a problem with the initialization of modules. I use a DirectoryCatalog to load my modules. All works fine, but if I import IModuleManager to my ShellViewModel constructor, all modules were loaded before my bootstrapper call the InitializeModules method. So it isn't possible for me to subscribe a event in the shell before the modules raise the event.\r<br />\n<br />\nWorkflow without module manager:<br />\n<ol>\n<li>Bootstrapper.CreateShell</li>\n<li>Load ShellViewModel</li>\n<li>Subscribe event in ShellViewModel constructor</li>\n<li>Bootstrapper.InitializeModules</li>\n<li>Load modules.</li>\n<li>\nRaise event in Initialize method of module.<br />\n</li>\n</ol>\nWorkflow with module manager:<br />\n<ol>\n<li>Bootstrapper.CreateShell</li>\n<li>Load modules.</li>\n<li>Raise event in Initialize method of module.</li>\n<li>Load ShellViewModel</li>\n<li>Subscribe event in ShellViewModel constructor</li>\n<li>\nBootstrapper.InitializeModules<br />\n</li>\n</ol>\nSample module code<br />\n<pre><code>[ModuleExport(typeof(SampleModuleA))]\npublic class SampleModuleA : IModule\n{\n    [ImportingConstructor]\n    public SampleModuleA(IEventAggregator eventAggregator)\n    {\n        _eventAggregator = eventAggregator;\n    }\n\n    public void Initialize()\n    {\n        _eventAggregator.GetEvent&lt;NewComponentAvailableEvent&gt;().Publish(&quot;ComponentA&quot;);\n    }\n\n    private readonly IEventAggregator _eventAggregator;\n}</code></pre>\n\nSample shell view model code<br />\n<pre><code>[Export]\npublic class ShellViewModel\n{\n    [ImportingConstructor]\n    public MainViewModel(IEventAggregator eventAggregator, IModuleManager manager) // with ModuleManager\n    {\n        _eventAggregator = eventAggregator;\n\n        _eventAggregator.GetEvent&lt;NewModuleAvailableEvent&gt;().Subscribe(args =&gt; {}, ThreadOption.UIThread);\n    }\n\n    private readonly IEventAggregator _eventAggregator;\n}</code></pre>\n\nSample bootstrapper code<br />\n<pre><code>public class Bootstrapper : MefBootstrapper\n{\n    protected override void ConfigureAggregateCatalog()\n    {\n        base.ConfigureAggregateCatalog();\n\n        this.AggregateCatalog.Catalogs.Add(new AssemblyCatalog(typeof(Bootstrapper).Assembly));\n        this.AggregateCatalog.Catalogs.Add(new DirectoryCatalog(&quot;Modules&quot;));\n    }\n\n    protected override IModuleCatalog CreateModuleCatalog()\n    {\n        return new ConfigurationModuleCatalog();\n    }\n\n    protected override void InitializeModules()\n    {\n        base.InitializeModules();\n    }\n\n    protected override DependencyObject CreateShell()\n    {\n        return this.Container.GetExportedValue&lt;Shell&gt;();\n    }\n\n    protected override void InitializeShell()\n    {\n        base.InitializeShell();\n        Application.Current.MainWindow = (Window)this.Shell;\n        Application.Current.MainWindow.Show();\n    }\n}</code></pre>\n\n",
    "PostedDate": "2014-02-13T05:08:18.37-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1208029",
    "ThreadId": "531707",
    "Html": "Hi,<br />\n<br />\nBased on my understanding you would like a possible workaround in order to import the <strong>IModuleManager</strong> into the <strong>ShellViewModel</strong> and properly handle every published event from modules initialization.<br />\n<br />\nOne simple way you could achieve this is to remove the publish statements from the <strong><em>initialize()</em></strong> methods, and wait instead until the <strong>BootStrapper</strong> initialization process finishes. Therefore, you could override the <strong><em>Run()</em></strong> method and publish a <strong>BootStrapperInitializationCompletedEvent</strong> event when it finishes running base method.<br />\n<br />\nBasically, you would need to perform the following updates from the <strong>Modules</strong> side:<br />\n<h1></h1>\n<ul>\n<li>Remove publish statement from each <strong>Module</strong> <strong><em>initialize()</em></strong> method;</li>\n<li>Add a suscription on each <strong>Module <em>initialize()</em></strong> method for the <strong><em>BootStrapperInitializationCompletedEvent</em></strong> event;</li>\n<li>\nHandle the <strong><em>BootStrapperInitializationCompletedEvent</em></strong> event and publish the corresponding <strong>Module</strong> event that was previously removed from the <strong><em>initialize()</em></strong> method.<br />\n</li>\n</ul>\nAnd then, from the <strong>BootStrapper</strong> side you should perform the following:<br />\n<h1></h1>\n<ul>\n<li>\nOverride <strong><em>Run()</em></strong> method by implementing the <strong><em>base.Run();</em></strong> statement and publishing the <strong><em>BootStrapperInitializationCompletedEvent</em></strong> event.<br />\n</li>\n</ul>\nThe <strong>ShellViewModel</strong> would remain as you described, with no changes. This way, the <strong>BootStrapper</strong> would publish an event after everything got initialized, giving the green light to every <strong>Module</strong> to publish their events, knowing that the <strong>ShellViewModel</strong> is already suscribed to them.<br />\n<br />\nI hope this helped,<br />\nRegards.<br />\n<br />\nGabriel Ostrowsky<br />\n<a href=\"https://blogs.southworks.net/gostrowsky\" rel=\"nofollow\">https://blogs.southworks.net/gostrowsky</a><br />\n",
    "PostedDate": "2014-02-13T10:22:00.403-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1208244",
    "ThreadId": "531707",
    "Html": "This helps me a lot! It works well!\r<br />\n<br />\nThank you!<br />\n",
    "PostedDate": "2014-02-13T23:58:31.76-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]