[
  {
    "Id": "685240",
    "ThreadId": "276165",
    "Html": "\r\n<p>Hi all,</p>\r\n<p>I really have 2 questions.&nbsp; Both are about loading modules, and seem like they should be simple questions.</p>\r\n<p>I have a fairly mature WPF application using Prism and Unity where, to date, we were loading the modules from a particular directory, which requires references to the&nbsp;dependent DLLs in the shell application.&nbsp; I would like to get rid of this dependency\r\n for a few reasons:</p>\r\n<p>1.&nbsp; I hate having the app build every time I press F5.</p>\r\n<p>2.&nbsp; We are creating a shell to be owned by another group, and therefore having references to our particular modules/dlls in a shell no longer owned by us is incorrect.</p>\r\n<p>To this end, I have placed the module catalog loading in a .config file and loaded it from there (per prism config file loading approach).&nbsp; But, this appears to still require the module dlls to live in the application directory, or at least have a copy\r\n there.&nbsp; if not it bombs at startup with DLLs it can't find.</p>\r\n<p>In addition, I want the shell to load up and then load the modules up after, to give the user the experience of rapid response of the shell popping up.&nbsp; I tried to do this by loading the modules on demand by having a module controller listening for\r\n an event launched from the end of the shell startup.&nbsp; Unfortunately, it sends the event and carries on, but the shell still doesn't come up completely until all the modules are loaded.&nbsp; I suspect this is some assumption about event execution I have\r\n made which is wrong.</p>\r\n<p>So, My 2 questions are:</p>\r\n<p>1.&nbsp; Can I load modules without having the dependent DLLs in the .EXE directory, and if so, how?</p>\r\n<p>2.&nbsp; Regardless of whether I can, what is the best way to&nbsp;get the shell to pop up and then have the modules load up directly after?</p>\r\n<p>Any help is greatly appreciated.</p>\r\n<p>Thanks,</p>\r\n<p>Anthony.</p>\r\n",
    "PostedDate": "2011-10-17T09:02:24.327-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "685322",
    "ThreadId": "276165",
    "Html": "<p>Hi Anthony,</p>\r\n<p>There are several approaches that you can use to discover and initialize your modules without needing to have an explicit reference to them in the shell project. Based on my understanding of your scenario, <strong>discovering modules in a directory</strong> might be a useful approach to accomplish the requirements you describe. Using this approach the shell project does not need to reference the modules. Instead, your shell should only have a reference to the infrastructure project, which contains the required interfaces used by your shell and your modules. Then, in the bootstrapper, you will only need to create a <strong>DirectoryModuleCatalog </strong>specifying the directory in which your modules will be stored. This directory doesn't need to be the same directory of the shell project, however, you need to know where the modules will be stored or make your application obtain this location before creating the <strong>DirectoryModuleCatalog.</strong></p>\r\n<p>You can find more information about the different approaches regarding the loading and initialization of modules in the <a href=\"http://msdn.microsoft.com/en-us/library/gg405479%28v=PandP.40%29.aspx\">Chapter 4: Modular Application Development</a> of the Prism documentation. Also, you can check the <a href=\"http://msdn.microsoft.com/en-us/library/ff921068%28v=PandP.40%29.aspx\">Modularity Quickstart for WPF</a> included with the Prism guidance, which includes an example of the aforementioned approach among others.</p>\r\n<p>Regarding the loading time of your shell project this could be happening, based on my understanding of your scenario, if the shell has a reference to your modules because the shell will need to load all the assemblies of each module before starting. You can try using an approach that does need to reference the modules in the shell (like for example the \"discovering modules in directory\" approach) and that load the modules on demand, so you could load the modules after your shell project is loaded.</p>\r\n<p>I hope you find it useful,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\" target=\"_blank\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2011-10-17T11:08:21.073-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "685358",
    "ThreadId": "276165",
    "Html": "<p>Thanks for the response.&nbsp; I think you are saying exactly what I am doing.&nbsp; I am sorry, maybe I didn't explain very well.</p>\r\n<p>Having a directory approach is exactly what causes the need to have a reference in the application exe (the shell).&nbsp; As soon as it tries to load up the modules in the bootstrapper it will not work without explicit reference in the shell to the dlls.&nbsp; I have gotten around this by doing the .config method of loading the modules.&nbsp; This means I don't need a reference in the exe.&nbsp; But, I still need the DLLs in the exe directory.&nbsp; Are you saying this is not true?&nbsp; I have found no example to this effect, including the ones you referenced (which I have been through).&nbsp; Maybe you are saying that it requires interfaces?</p>\r\n<p>As for the loading time, it currently has not reference, and I am loading them on demand. I just think that I am having a bit of trouble figuring out the correct&nbsp;pattern to get the modules to load up after the shell is showing.&nbsp; To be clear, I am doing the config method with them not being loaded at startup.</p>\r\n<p>From the modular application development link you posted above:</p>\r\n<p>\"The registration and discovery mechanism you should use depends on what your application needs. <strong>Using a configuration file or XAML file allows your application to not require references to the modules</strong>. Using a directory can allow an application to discover modules without having to specify them in a file.\"</p>\r\n<p>This is true, and it is why I am changing to the config file approach.&nbsp; But, even without the references, when it tries to load the modules&nbsp;it gives me an errror running (can't find the DLL), unless at least a copy of it lives in the exe directory.&nbsp; This is what I am trying to avoid.</p>\r\n<p>As for loading the modules on demand, it can be quite easily done on a button click. I get that and have done that. I am looking for a decent pattern for getting the shell to load up the modules dynamically after it has rendered. I am just having trouble taking the buttton out of the equation, if that makes sense.</p>\r\n<p>Thanks for any additional input.</p>\r\n<p>Anthony.</p>",
    "PostedDate": "2011-10-17T12:03:45.723-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "686050",
    "ThreadId": "276165",
    "Html": "<p>Hi Anthony,</p>\r\n<p>The <strong>\"discovering modules in a directory\"</strong> approach <span style=\"text-decoration: underline;\">does not require to have a reference</span> to the modules and <span style=\"text-decoration: underline;\">neither requires the dlls of the modules to be in the same directory that your shell application</span>, your modules can be in any directory of your preference. I believe this makes this approach (based on my understanding of your scenario) useful to meet your requirements.</p>\r\n<p>You can check the following sample application that uses the aforementioned approach:</p>\r\n<ul>\r\n<li><a href=\"https://skydrive.live.com/#!/?cid=e607cef85d62e176&amp;sc=documents&amp;uc=1&amp;id=E607CEF85D62E176%21195\">LoadingModulesFromDirectoryWhenAvailableAndOnDemand in SkyDrive</a>.</li>\r\n</ul>\r\n<p>In this sample application the bootstrapper loads two modules, one when the application starts and the other on demand, through the inspection of a directory. Note that the shell project <span style=\"text-decoration: underline;\">does not have a reference</span> to the aforementioned modules. To ensure that the dlls of the modules will be available in the specified directory, the projects have a build-post event (which is the same one used in the modularity quickstart) specified in its properties that copies the dlls to the specified directory (in this case, the \"Modules\" directory).</p>\r\n<p>Also note that in this sample the shell windows loads before the modules and shows a small legend showing that the \"when available\" module is being loaded. The module that is loaded when available has a timer which sleeps the thread for 2 seconds to simulate that a heavy module is being loaded. As this is not specifically related to the directory discovery approach, the <strong>shell should appear before the initialization on any module</strong> regarding the approach used to locate the modules, so <strong>the modules should be initialized after the shell is rendered</strong>. Also, you can improve this by adding your custom logic to load the modules in a background thread.</p>\r\n<p>As a side note, if you wish to use more that one approach to locate and load modules, you might find the class <strong>AggregateModuleCatalog </strong>provided with the modularity quickstart which seems to allow to combine multiple types of modules catalogs, including multiple <strong>DirectoryModuleCatalogs</strong> using different directories.</p>\r\n<p>I hope you find it useful,</p>\r\n<p>Damian Cherubini<br /> <a href=\"http://blogs.southworks.net/dcherubini\" target=\"_blank\">http://blogs.southworks.net/dcherubini</a></p>",
    "PostedDate": "2011-10-18T15:06:11.52-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "686070",
    "ThreadId": "276165",
    "Html": "<p>Well, that all seems very concise.&nbsp; Thank you very much for taking the time to stick with me.&nbsp;</p>\r\n<p>I have built and run the application, and it is very clear.&nbsp; It is essentially exactly the same as what we are doing with some (obviously) distinct differences.&nbsp; The catalog, the bootstrapper,&nbsp;the Module directory, and the on demand loading (which&nbsp;we are doing for one module IF the user has access) are nearly identical.&nbsp; I think the one difference was that we were trying to keep the knowledge of where the module would load in the&nbsp;shell application&nbsp;and therefore had, in some round about way a reference to the modules.&nbsp; From there, I found a few people&nbsp;(including the link you sent me to)&nbsp;that stated that you needed a reference in the shell application.&nbsp; So, I sort of believed it.&nbsp; In the end, I think that I need to remove some smarts from my shell.&nbsp; It seems obvious that it needs to be dumber to be better.&nbsp; I will attempt the changes when I am out of my meeting, but I have high hopes.</p>\r\n<p>&nbsp;</p>\r\n<p>Again, Thank you very much for taking the time to help me out.&nbsp;</p>\r\n<p>Anthony.</p>",
    "PostedDate": "2011-10-18T16:11:12.457-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1315832",
    "ThreadId": "276165",
    "Html": "I know it's late, but I just fixed this in our project and want to clarify on this.\r<br />\n<br />\nThe reason you end up thinking that you need module DLLs in the Shell folder is that you haven't copied <em>all</em> module dependencies to the module folder (and by <em>all</em> I mean dependencies of dependencies, which are easy to miss). When the runtime wants to resolve these dependencies, it looks in the module folder but fails, so it then looks in the app's execution directory (the Shell's directory), fails as well, and then, in a somewhat misleading way, reports this last location in the error that it throws. This is why you end up thinking that you need the DLLs in the Shell's directory.\r<br />\n<br />\nAgain, in reality, all you need is to make sure all module DLLs are in the module folder. The only exception is: if you have a DLL that both the module and the Shell are using (the Microsoft.Practices DLLs are good examples of this), then you only need the one in the Shell directory; there's no need to have it in the module's folder as well. This is because, as I explained above, the runtime will also look for DLLs in the executing directory.<br />\n",
    "PostedDate": "2014-10-22T15:58:31.753-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]