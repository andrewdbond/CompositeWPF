[
  {
    "Id": "279467",
    "ThreadId": "81434",
    "Html": "<p>I have run into an issue here at work where we have the following scenario:</p>\r\n<p>* We'll be porting numerous (30+) applications to C#/WPF/CAG</p>\r\n<p>* There will be relatively few &quot;Common&quot; (widely-used) dll's</p>\r\n<p>We have been discussing deployment as well as architecture and we keep running into the same issue: if we keep the build system the same, where all the forms are built at the same time and deployed all at once, forms that link to different versions of the Common dll's will break. In addition, I would like to make a case for CAG.</p>\r\n<p>My questions are:</p>\r\n<p>* How do we go about creating a build system that will ensure that our forms (some of which may not be updated once initially deployed) share the same latest Common dll's? Does ensuring we do not change the API work in this case? Or will a different version of the dll break the build for those older forms?</p>\r\n<p>* Is it possible to reuse View/ViewModel code with CAG Modules? Bootstrap instances? In theory I was thinking of creating View/ViewModel classes which you would simply provide a custom repository (that implements an interface). Does this work in practice?</p>\r\n<p>Thank you for your help,</p>\r\n<p>Alex</p>",
    "PostedDate": "2010-01-20T06:34:26.22-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "280545",
    "ThreadId": "81434",
    "Html": "<p id=2a6787a0-e8bc-012c-3d07-12313b049c51>Hi Alex,</p>\r\n<p id=2a679dc0-e8bc-012c-3d08-12313b049c51>I will try to answer both questions separately.</p>\r\n<p id=2a67bbf0-e8bc-012c-3d09-12313b049c51><strong><span style=\"text-decoration:underline\">About common shared DLLs</span></strong></p>\r\n<p id=9d950510-e8c8-012c-3dca-12313b049c51>If I understand correctly you want to have multiple applications use the same common assembly, and have them continue working even if the common assembly is modified. I tested this by creating a common service project and referencing it from two <strong>Prism Quickstarts</strong>. To get the new assembly to work without building, all you have to do is replace (in my case copy/paste) in the required path. Take into account that the application has to be restarted when the new assembly is deployed.</p>\r\n<p id=2a67fd50-e8bc-012c-3d0b-12313b049c51><span style=\"text-decoration:underline\"><strong>About reusing View/ViewModel code</strong></span></p>\r\n<p id=2a682770-e8bc-012c-3d0c-12313b049c51>One of the benefits of having modular, decoupled applications, like those created following the guidelines of the Composite Application Guidance, is reusability.</p>\r\n<p id=9d95b280-e8c8-012c-3dcd-12313b049c51>If your goal is to create base implementations of Views/View Models to be&nbsp; shared across the application, you should place them in an infrastructure project and reference to it from each of your modules.</p>\r\n<p id=2a685580-e8bc-012c-3d0d-12313b049c51>If you want to have a single place (perhaps one or multiple assemblies) which would hold the different views of various applications, you should try to avoid having views from different modules in the same assembly, as this would reduce the decoupling between different modules. A better and more decoupled approach could be reusing modules between the applications (if possible). As each module is decoupled from other modules, there is no concern about using it in multiple applications and get the functionality you require.</p>\r\n<p id=2a688ca0-e8bc-012c-3d0e-12313b049c51>Damian Schenkelman <br><a href=\"http://blogs.southworks.net/dschenkelman\">http://blogs.southworks.net/dschenkelman</a></p>",
    "PostedDate": "2010-01-22T05:03:58.833-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]