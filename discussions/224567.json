[
  {
    "Id": "483803",
    "ThreadId": "224567",
    "Html": "<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div id=\"ctl00_ctl00_MasterContent_Content_PostRepeater_ctl00_BodyDiv\">\r\n<p>Hello,</p>\r\n<p>I found it interesting that the MVVM RI (along with the MVVM quickstarts)&nbsp;doesn't use the Prism library at all: no modules, service locator, region management or event aggregator, and thus no bootstrapper. It uses its own solution for region management of a single region. It also doesn't make use of the Silverlight-specific CompositionInitializer pattern in Silverlight MEF.</p>\r\n<p>Is this the result of a deliberate decision?</p>\r\n<p>Also, out of curiousity - StateManager and ViewFactory in the MVVM RI are app-wide services that use the MEF container. ViewFactory specifically calls out that one of the primary reasons it exists is to avoid composing the container in itself. Is composing an MEF container inside itself considered something of an MEF anti-pattern?</p>\r\n<p>NW</p>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>",
    "PostedDate": "2010-08-23T14:06:40.04-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "485392",
    "ThreadId": "224567",
    "Html": "This discussion has been copied to a work item. Click <a href=\"http://compositewpf.codeplex.com/workitem/7183\">here</a> to go to the work item and continue the discussion.",
    "PostedDate": "2010-08-26T14:05:53.917-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "485393",
    "ThreadId": "224567",
    "Html": "<p id=d56bb410-91d4-012d-6a65-1231391803ac>Hi NW,</p>\r\n<p>Thanks for your feedback, this is really valuable for the product team (I copied this as a workitem). The MVVM RI reference implementation does not make use of the CAL, since it is more focused on providing guidance of the MVVM pattern. But take into account that the prism team has not updated yet the Stock Trader RI. So, this will be probably the application where all the guidance pieces come together.</p>\r\n<p>Regarding to the StateHandler and the ViewFactory are helpers that are useful for managing objects registered in the container. They are registered in the container, so it makes them available to be imported. The following piece code of the Application_Startup method in App.xaml.cs shows how&nbsp;they&nbsp;are registered:</p>\r\n<pre><span style=\"color:green\">// Register services needing container explicitly\r\n</span><span style=\"color:blue\">this</span>.container.ComposeExportedValue&lt;ViewFactory&gt;(<span style=\"color:blue\">new </span>ViewFactory(<span style=\"color:blue\">this</span>.container));\r\n<span style=\"color:blue\">this</span>.container.ComposeExportedValue&lt;StateHandler&gt;(<span style=\"color:blue\">new </span>StateHandler(<span style=\"color:blue\">this</span>.container));</pre>\r\n<p>This way, when&nbsp;any of them are imported, it&nbsp;is not necessary to resolve the container.</p>\r\n<p>Please let me know if this helps.&nbsp;</p>\r\n<p id=d56bdc10-91d4-012d-6a67-1231391803ac>Fernando Antivero <br><a href=\"http://blogs.southworks.net/fantivero\">http://blogs.southworks.net/fantivero</a></p>",
    "PostedDate": "2010-08-26T14:06:57.123-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "485753",
    "ThreadId": "224567",
    "Html": "<p>Hi Fernando,</p>\r\n<p>Thanks for the reply. Really looking forward to seeing what shows up in the coming months.</p>\r\n<p>I don't want to get too far off track from the topic of this thread, but to continue the sidebar conversation regarding ViewFactory: part of your answer is &quot;this way... it is not necessary to resolve the container.&quot; The core of my question was &quot;why <em>not</em> just resolve the container?&quot;</p>\r\n<p>I did some reading (specifically <a href=\"http://blogs.msdn.com/b/nblumhardt/archive/2009/08/28/dynamic-part-instantiation-in-mef.aspx\">this</a> and <a href=\"http://blogs.msdn.com/b/nblumhardt/archive/2008/12/27/container-managed-application-design-prelude-where-does-the-container-belong.aspx\">this</a>, which I found via&nbsp;the link from the bottom of the <a href=\"http://mef.codeplex.com/wikipage?title=PartCreator&referringTitle=Guide\">MEF documentation about ExportFactory</a>), and I think I have a better understanding of why it makes sense not to access the container directly, but moving it off into the ViewFactory service seems like it just moves the problem. It seems like ExportFactory or Lazy can be used to solve this in a cleaner way. By using ExportFactory or Lazy, the <em>entire </em>application can live &quot;in the container&quot;, as the second article puts it, as opposed to having services like ViewFactory have to carry around a reference to it. The metadata functionality gives the added bonus of not having to register contract names that correspond to the view name - it can go in the metadata instead. If you use ExportFactory, you can also maintain control over lifetimes and destroy views when you're done with them.</p>\r\n<p>In SingleViewUIService.cs, instead of this:</p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre>[Import]\r\n<span style=\"color:blue\">public</span> ViewFactory ViewFactory { <span style=\"color:blue\">get</span>; <span style=\"color:blue\">set</span>; }\r\n\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> ShowView(<span style=\"color:blue\">string</span> viewName)\r\n{\r\n    <span style=\"color:blue\">var</span> view = <span style=\"color:blue\">this</span>.ViewFactory.GetView(viewName);\r\n    <span style=\"color:blue\">this</span>.MainWindow.CurrentView = view;\r\n}\r\n\r\n</pre>\r\n</div>\r\n<p>You can have something like this:</p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre>[ImportMany]\r\n<span style=\"color:blue\">public</span> IEnumerable&lt;ExportFactory&lt;UserControl, IDictionary&lt;<span style=\"color:blue\">string</span>, <span style=\"color:blue\">object</span>&gt;&gt;&gt; Views;\r\n\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> ShowView(<span style=\"color:blue\">string</span> viewName)\r\n{\r\n    <span style=\"color:blue\">var</span> view = Views.Single(v =&gt; ((<span style=\"color:blue\">string</span>)v.Metadata[<span style=\"color:#a31515\">&quot;ViewName&quot;</span>]) == viewName).CreateExport();\r\n    <span style=\"color:blue\">this</span>.MainWindow.CurrentView = view.Value;\r\n}\r\n\r\n</pre>\r\n</div>\r\n<p>Here, I'm just using weakly-typed metadata and I'm not taking advantage of the fact that I can dispose of views (I could have just used Lazy), but ViewFactory and it's container reference is no longer needed, and instead of registering views using the friendly view name as the contract, I can put that information in the metadata, which is probably better suited for it.</p>\r\n<p>Let me know if this is off base, as I'm just now getting my head around these concepts, but this seems like a good opportunity to insert this pattern into a quickstart/RI.</p>",
    "PostedDate": "2010-08-27T10:11:47.17-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]