{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": null,
    "CommentCount": 6,
    "Custom": "",
    "Description": "Hello,we are using Prism in our application and I might have found a bug in the CAL.We are using a view with a scoped region which is added to the MainRegion of the shell. The view is pretty simple:<UserControl x:Class=\"PatientManagement.Views.PatientManagementView\"             xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"             xmlns:cal=\"http://www.codeplex.com/CompositeWPF\">    <TabControl cal:RegionManager.RegionName=\"Exam\" /></UserControl>\n \nDepending on the user input the view is added and removed from the MainRegion multiple times. I created a simplemodule wich does add and remove the view multiple times. After the second Remove you always get a  UpdateRegionsException informing you that the Region with the name Exam already exists. (See stacktrache below)\n \n \npublic class PatientManagementModule : IModule\n{\n    private readonly IRegionManager _regionManager;\n    private PatientManagementView _view;\n \n    public PatientManagementModule(IRegionManager regionManager)\n    {\n        _regionManager = regionManager; \n    }\n \n    public void Initialize()\n    {\n        // Create view\n        _view = new PatientManagementView();\n            \n        AddView();\n        RemoveView();\n        AddView();\n        RemoveView();   // Exception!   \n    }\n \n    public void AddView()\n    {\n        IRegion region = _regionManager.Regions[\"MainRegion\"];\n \n        // Add the view to the region and create a scoped region manager\n        region.Add(_view, \"dummy\", true);\n        region.Activate(_view);\n    }\n \n    public void RemoveView()\n    {\n        IRegion region = _regionManager.Regions[\"MainRegion\"];\n \n        // Remove the view from the region\n        region.Remove(_view);\n    }\n}\n \n \nI used the debugger to step into the CAL code and found one problem. Whenever a view is added to a region, the Region.AddMethod will add the RegionManager as an attached property to the view. In the example the ScopedRegionManager is addedto the view as a attached property. Once you remove the view from the region, the Region.Remove will remove the attached property only if it is the default RegionManager. So in the example the attached property is not removed becauseit is the scoped RegionManager not the default one.Once I added some code to remove the left over attached property from the view I can add and remove itas often as I want without getting any exceptions.\nSincerely,\n \nMichael\n \n \nStacktraceMicrosoft.Practices.Composite.Presentation.Regions.UpdateRegionsException: An exception occurred while trying to create region objects.     - The most likely causing exception was: 'System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---> System.ArgumentException: Region with the given name is already registered: Exam   at Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionCollection.Add(IRegion region) in C:\\CSharp\\PrismScopedRegions\\CAL\\Composite.Presentation\\Regions\\RegionManager.cs:line 315   at Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior.TryRegisterRegion() in C:\\CSharp\\PrismScopedRegions\\CAL\\Composite.Presentation\\Regions\\Behaviors\\RegionManagerRegistrationBehavior.cs:line 127   at Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior.OnUpdatingRegions(Object sender, EventArgs e) in C:\\CSharp\\PrismScopedRegions\\CAL\\Composite.Presentation\\Regions\\Behaviors\\RegionManagerRegistrationBehavior.cs:line 142   --- End of inner exception stack trace ---   at System.RuntimeMethodHandle._InvokeMethodFast(IRuntimeMethodInfo method, Object target, Object[] arguments, SignatureStruct& sig, MethodAttributes methodAttributes, RuntimeType typeOwner)   at System.RuntimeMethodHandle.InvokeMethodFast(IRuntimeMethodInfo method, Object target, Object[] arguments, Signature sig, MethodAttributes methodAttributes, RuntimeType typeOwner)   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture, Boolean skipVisibilityChecks)   at System.Delegate.DynamicInvokeImpl(Object[] args)   at System.Delegate.DynamicInvoke(Object[] args)   at Microsoft.Practices.Composite.Presentation.Events.WeakDelegatesManager.Raise(Object[] args) in C:\\CSharp\\PrismScopedRegions\\CAL\\Composite.Presentation\\Events\\WeakDelegatesManager.cs:line 49   at Microsoft.Practices.Composite.Presentation.Regions.RegionManager.UpdateRegions() in C:\\CSharp\\PrismScopedRegions\\CAL\\Composite.Presentation\\Regions\\RegionManager.cs:line 217'.    But also check the InnerExceptions for more detail or call .GetRootException().  ---> System.ArgumentException: Region with the given name is already registered: Exam   at Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionCollection.Add(IRegion region) in C:\\CSharp\\PrismScopedRegions\\CAL\\Composite.Presentation\\Regions\\RegionManager.cs:line 315   at Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior.TryRegisterRegion() in C:\\CSharp\\PrismScopedRegions\\CAL\\Composite.Presentation\\Regions\\Behaviors\\RegionManagerRegistrationBehavior.cs:line 127   at Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior.OnUpdatingRegions(Object sender, EventArgs e) in C:\\CSharp\\PrismScopedRegions\\CAL\\Composite.Presentation\\Regions\\Behaviors\\RegionManagerRegistrationBehavior.cs:line 142   --- End of inner exception stack trace ---   at Microsoft.Practices.Composite.Presentation.Regions.RegionManager.UpdateRegions() in C:\\CSharp\\PrismScopedRegions\\CAL\\Composite.Presentation\\Regions\\RegionManager.cs:line 223   at Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionCollection.get_Item(String regionName) in C:\\CSharp\\PrismScopedRegions\\CAL\\Composite.Presentation\\Regions\\RegionManager.cs:line 292   at PatientManagement.PatientManagementModule.RemoveView() in C:\\CSharp\\PrismScopedRegions\\PatientManagement\\PatientManagementModule.cs:line 51   at PatientManagement.PatientManagementModule.Initialize() in C:\\CSharp\\PrismScopedRegions\\PatientManagement\\PatientManagementModule.cs:line 30",
    "LastUpdatedDate": "2014-02-03T04:56:50.457-08:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "High",
      "Severity": 150,
      "Id": 3
    },
    "ProjectName": "CompositeWPF",
    "ReportedDate": "2010-10-15T11:53:41.213-07:00",
    "Status": {
      "Name": "Proposed",
      "Id": 1
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "UpdateRegionsException when adding/removing a view with a scoped region manager",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 10,
    "Id": 7381
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "Please, for more information see the following forum thread: http://compositewpf.codeplex.com/Thread/View.aspx?ThreadId=213889",
      "PostedDate": "2010-10-15T11:54:26.3-07:00",
      "Id": 156332
    },
    {
      "Message": "Hi,\r\n\r\nBased on our understanding, we believe that the reason why the region manager is removed only if it’s the same that the hosting region (that is, the view being removed doesn’t have an scoped region manager) is that there might be an intention to support the scenario of being able to “move” an already created view, with its corresponding region manager, scoped regions and views, to a different region.\r\n\r\nIt seems that the workaround of modifying the Prism library to remove the region manager from the view prevents this exception for appearing. However, this approach would prevent the aforementioned scenario from working. \r\n\r\nAs another possible workaround to avoid this problem and keep the behavior described above, you can change the Add method of the Region.cs class with the following code:\r\n\r\n        public virtual IRegionManager Add(object view, string viewName, bool createRegionManagerScope)\r\n        {\r\n            IRegionManager manager = ObtainAppropriateRegionManager(createRegionManagerScope, view);\r\n\r\n            this.InnerAdd(view, viewName, manager);\r\n\r\n            return manager;\r\n        }\r\n\r\nWhere the implementation of the ObtainAppropiateRegionManager method is:\r\n\r\n        private IRegionManager ObtainAppropriateRegionManager(bool createRegionManagerScope, object view)\r\n        {\r\n            IRegionManager formerRegionManager = null;\r\n            DependencyObject viewAsDependencyObject = view as DependencyObject;\r\n            if (viewAsDependencyObject != null)\r\n            {\r\n                formerRegionManager = Regions.RegionManager.GetRegionManager(viewAsDependencyObject);\r\n            }\r\n            \r\n            if (formerRegionManager != null)\r\n            {\r\n                if (!createRegionManagerScope)\r\n                {\r\n                    throw new InvalidOperationException(\"The view already has a its own scoped region manager. In order to add this view, set the createRegionManagerScope parameter to true\");\r\n                }\r\n                else\r\n                {\r\n                    return formerRegionManager;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                return createRegionManagerScope ? this.RegionManager.CreateRegionManager() : this.RegionManager;\r\n            }\r\n        }\r\n\r\nBy applying this changes, the result is that:\r\nIf the view doesn’t have a region manager attached, the ObtainAppropiateRegionManager return a new region manager or the region manager used by the hosting region according to the createRegionManagerScope parameter. This is the usual behavior of the Add method. However, if the view is a dependency object and it already has an attached scoped region manager, the ObtainAppropiateRegionManager method will return that region manager if the createRegionManagerScope is true and, if the createRegionManagerScope is false, it will throw an exception. \r\n\r\nWith this, if an already created view that has a scoped region manager is added in a region, you would obtain the scoped region manager that the view already has instead of modifying the attached properties of the view.\r\n\r\nWe run the test of the Prism library with the aforementioned modifications and found that they passed.\r\n\r\nI hope you find this useful,\r\n\r\nDamian Cherubini\r\nhttp://blogs.southworks.net/dcherubini",
      "PostedDate": "2011-09-30T10:26:14.493-07:00",
      "Id": 156333
    },
    {
      "Message": "I think the problem is caused by recursion in RegionManagerRegistrationBehavior.TryRegisterRegion. If you rearrange the code such that the attachedRegion is updated before removing & adding the region to the regionManager, then the exception goes away.\r\n\r\n        private void TryRegisterRegion()\r\n        {\r\n            DependencyObject targetElement = this.HostControl;\r\n            if (targetElement.CheckAccess())\r\n            {\r\n                IRegionManager regionManager = this.FindRegionManager(targetElement);\r\n\r\n                IRegionManager attachedRegionManager = this.GetAttachedRegionManager();\r\n\r\n                if (regionManager != attachedRegionManager)\r\n                {\r\n                    if (regionManager != null)\r\n                    {\r\n                        this.attachedRegionManagerWeakReference = new WeakReference( regionManager );\r\n                    }\r\n                    else\r\n                    {\r\n                        this.attachedRegionManagerWeakReference = null;\r\n                    }\r\n\r\n                    if (attachedRegionManager != null)\r\n                    {\r\n                        attachedRegionManager.Regions.Remove(this.Region.Name);\r\n                    }\r\n\r\n                    if (regionManager != null)\r\n                    {\r\n                        regionManager.Regions.Add(this.Region);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\nHowever, the recursion inside TryRegisterRegion (whereby Add/Remove regions to the regionManager causes UpdateRegions to be called again) should really be avoided, as it's likely to cause other problems, maybe infinite recursion in some circumstances.",
      "PostedDate": "2011-10-25T02:46:58.067-07:00",
      "Id": 156334
    },
    {
      "Message": "The exception occurs because removing the view from the old region causes recursion back into TryRegisterRegion (via UpdateRegions). The re-entry into TryRegisterRegion adds the view to the region. When we roll back out to the outer level, the new region already has the view in it, so the code explodes when it tries to add the new region a second time.\r\n\r\nThis is why rearranging the code in TryRegisterRegion fixes the problem, because the recursion into TryRegisterRegion will find nothing to do.",
      "PostedDate": "2011-10-25T02:54:26.37-07:00",
      "Id": 156335
    },
    {
      "Message": "A fix for this one appeared in a pre-release verison of Prism 4.1, but then vanished again in the release version. The fix was to provide a new function IRegion.MoveFrom().\r\n\r\nMaybe there was some problem with it - The fix worked for me, while it existed, though....",
      "PostedDate": "2012-02-28T10:41:17.813-08:00",
      "Id": 156336
    },
    {
      "Message": "Hi,\r\n\r\nFor those interested, you might find useful to know that as mentioned in this thread (http://compositewpf.codeplex.com/discussions/346426) it seems that the p&p team decided to remove the MoveFrom method in the Prism 4.1 final release, as this approach didn't appear to actually solve the issue described in the work item. \r\n\r\nAlthough, as mentioned by the user MarkGodwin, this worked for some scenarios, as this method provided a limited way to insert a view which already has a region manager attached to it.\r\n\r\nMoveFrom Method (Region.cs) can be found in Prism drop 64970 http://compositewpf.codeplex.com/SourceControl/changeset/changes/64970\r\n\r\nIn my opinion a more generic solution to tackle this kind of scenarios could be adding a method to the Region class for example like the one mentioned by the user rumzeus in the following work item (which adds the functionality to add a view using its own attached RegionManager):\r\n\r\nException in regionMgr.Regions[\"X\"]: \"Region with the given name is already registered: X\"\r\nhttp://compositewpf.codeplex.com/workitem/9272\r\n\r\nRegards,\r\n\r\nAgustin Adami\r\nhttp://blogs.southworks.net/aadami",
      "PostedDate": "2012-04-13T10:59:17.14-07:00",
      "Id": 156337
    }
  ]
}