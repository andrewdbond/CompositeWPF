{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "Hi,\r\n\r\nI'm closing this issue, as the context in which the suggestion is made has now changed, as of Prism v4, since the event aggregator classes have been placed in Microsoft.Practices.Prism, so the namespace in which they're placed has changed.\r\n\r\nThanks,\r\n\r\nGuido Leandro Maliandi\r\nhttp://blogs.southworks.net/gmaliandi",
    "ClosedDate": "2011-10-31T09:33:55.147-07:00",
    "CommentCount": 1,
    "Custom": "",
    "Description": "Hi,\nI've been reading CAL guide several times and I think it one of the best things I've seen.\nIt explain and demonstrate how to design an application (not just UI application) right.\n \nYesterday I decide to use CAL event aggregator in my project which is divided to several layers, I was surprised  to see that the only concrete implementation of the event class is in the presentation layer.\nIf I would to use that in my application I would have to add a reference to WindowsBase and maybe other UI libraries in project which are not in the UI layer.\nI look at the implementation of CompositePresentationEvent and the only reference to WPF specific types is the dispatcher.\nIt is very easy to replace the call to dispatcher.BeginInvoke with SynchornizationContext.Post and that's exactly what I did.\nI've post here the code I use to create a class called CompositeEvent which is the same as CompositePresentationEvent but in the core of CAL and allow layers of application which are not UI to use it, and still allow UI components to register with the request of marshaling the call to the UI thread.\n \nAnother option is to completely abstract out of the event class the subscription type and thus make the event system even more expandable.\n \nThank you,\nIdo.\n \n \n \n \n//===================================================================================\n// Microsoft patterns & practices\n// Composite Application Guidance for Windows Presentation Foundation and Silverlight\n//===================================================================================\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY\n// OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT\n// LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS FOR A PARTICULAR PURPOSE.\n//===================================================================================\n// The example companies, organizations, products, domain names,\n// e-mail addresses, logos, people, places, and events depicted\n// herein are fictitious.  No association with any real company,\n// organization, product, domain name, email address, logo, person,\n// places, or events is intended or should be inferred.\n//===================================================================================\nusing System;\nusing System.Linq;\nusing Microsoft.Practices.Composite.Events;\nusing System.Threading;\nusing System.ComponentModel;\n \nnamespace Microsoft.Practices.Composite.Events\n{\n    /// <summary>\n    /// Defines a class that manages publication and subscription to events.\n    /// </summary>\n    /// <typeparam name=\"TPayload\">The type of message that will be passed to the subscribers.</typeparam>\n    public class CompositeEvent<TPayload> : EventBase\n    {\n        /// <summary>\n        /// Subscribes a delegate to an event that will be published on the <see cref=\"ThreadOption.PublisherThread\"/>.\n        /// <see cref=\"CompositePresentationEvent{TPayload}\"/> will maintain a <seealso cref=\"WeakReference\"/> to the target of the supplied <paramref name=\"action\"/> delegate.\n        /// </summary>\n        /// <param name=\"action\">The delegate that gets executed when the event is published.</param>\n        /// <returns>A <see cref=\"SubscriptionToken\"/> that uniquely identifies the added subscription.</returns>\n        /// <remarks>\n        /// The CompositePresentationEvent collection is thread-safe.\n        /// </remarks>\n        public SubscriptionToken Subscribe(Action<TPayload> action)\n        {\n            return Subscribe(action, ThreadOption.PublisherThread);\n        }\n \n        /// <summary>\n        /// Subscribes a delegate to an event.\n        /// CompositePresentationEvent will maintain a <seealso cref=\"WeakReference\"/> to the Target of the supplied <paramref name=\"action\"/> delegate.\n        /// </summary>\n        /// <param name=\"action\">The delegate that gets executed when the event is raised.</param>\n        /// <param name=\"threadOption\">Specifies on which thread to receive the delegate callback.</param>\n        /// <returns>A <see cref=\"SubscriptionToken\"/> that uniquely identifies the added subscription.</returns>\n        /// <remarks>\n        /// The CompositePresentationEvent collection is thread-safe.\n        /// </remarks>\n        public SubscriptionToken Subscribe(Action<TPayload> action, ThreadOption threadOption)\n        {\n            return Subscribe(action, threadOption, false);\n        }\n \n        /// <summary>\n        /// Subscribes a delegate to an event that will be published on the <see cref=\"ThreadOption.PublisherThread\"/>.\n        /// </summary>\n        /// <param name=\"action\">The delegate that gets executed when the event is published.</param>\n        /// <param name=\"keepSubscriberReferenceAlive\">When <see langword=\"true\"/>, the <seealso cref=\"CompositePresentationEvent{TPayload}\"/> keeps a reference to the subscriber so it does not get garbage collected.</param>\n        /// <returns>A <see cref=\"SubscriptionToken\"/> that uniquely identifies the added subscription.</returns>\n        /// <remarks>\n        /// If <paramref name=\"keepSubscriberReferenceAlive\"/> is set to <see langword=\"false\" />, <see cref=\"CompositePresentationEvent{TPayload}\"/> will maintain a <seealso cref=\"WeakReference\"/> to the Target of the supplied <paramref name=\"action\"/> delegate.\n        /// If not using a WeakReference (<paramref name=\"keepSubscriberReferenceAlive\"/> is <see langword=\"true\" />), the user must explicitly call Unsubscribe for the event when disposing the subscriber in order to avoid memory leaks or unexepcted behavior.\n        /// \n        /// The CompositePresentationEvent collection is thread-safe.\n        /// </remarks>\n        public SubscriptionToken Subscribe(Action<TPayload> action, bool keepSubscriberReferenceAlive)\n        {\n            return Subscribe(action, ThreadOption.PublisherThread, keepSubscriberReferenceAlive);\n        }\n \n        /// <summary>\n        /// Subscribes a delegate to an event.\n        /// </summary>\n        /// <param name=\"action\">The delegate that gets executed when the event is published.</param>\n        /// <param name=\"threadOption\">Specifies on which thread to receive the delegate callback.</param>\n        /// <param name=\"keepSubscriberReferenceAlive\">When <see langword=\"true\"/>, the <seealso cref=\"CompositePresentationEvent{TPayload}\"/> keeps a reference to the subscriber so it does not get garbage collected.</param>\n        /// <returns>A <see cref=\"SubscriptionToken\"/> that uniquely identifies the added subscription.</returns>\n        /// <remarks>\n        /// If <paramref name=\"keepSubscriberReferenceAlive\"/> is set to <see langword=\"false\" />, <see cref=\"CompositePresentationEvent{TPayload}\"/> will maintain a <seealso cref=\"WeakReference\"/> to the Target of the supplied <paramref name=\"action\"/> delegate.\n        /// If not using a WeakReference (<paramref name=\"keepSubscriberReferenceAlive\"/> is <see langword=\"true\" />), the user must explicitly call Unsubscribe for the event when disposing the subscriber in order to avoid memory leaks or unexepcted behavior.\n        /// \n        /// The CompositePresentationEvent collection is thread-safe.\n        /// </remarks>\n        public SubscriptionToken Subscribe(Action<TPayload> action, ThreadOption threadOption, bool keepSubscriberReferenceAlive)\n        {\n            return Subscribe(action, threadOption, keepSubscriberReferenceAlive, null);\n        }\n \n        /// <summary>\n        /// Subscribes a delegate to an event.\n        /// </summary>\n        /// <param name=\"action\">The delegate that gets executed when the event is published.</param>\n        /// <param name=\"threadOption\">Specifies on which thread to receive the delegate callback.</param>\n        /// <param name=\"keepSubscriberReferenceAlive\">When <see langword=\"true\"/>, the <seealso cref=\"CompositePresentationEvent{TPayload}\"/> keeps a reference to the subscriber so it does not get garbage collected.</param>\n        /// <param name=\"filter\">Filter to evaluate if the subscriber should receive the event.</param>\n        /// <returns>A <see cref=\"SubscriptionToken\"/> that uniquely identifies the added subscription.</returns>\n        /// <remarks>\n        /// If <paramref name=\"keepSubscriberReferenceAlive\"/> is set to <see langword=\"false\" />, <see cref=\"CompositePresentationEvent{TPayload}\"/> will maintain a <seealso cref=\"WeakReference\"/> to the Target of the supplied <paramref name=\"action\"/> delegate.\n        /// If not using a WeakReference (<paramref name=\"keepSubscriberReferenceAlive\"/> is <see langword=\"true\" />), the user must explicitly call Unsubscribe for the event when disposing the subscriber in order to avoid memory leaks or unexepcted behavior.\n        /// \n        /// The CompositePresentationEvent collection is thread-safe.\n        /// </remarks>\n        public virtual SubscriptionToken Subscribe(Action<TPayload> action, ThreadOption threadOption, bool keepSubscriberReferenceAlive, Predicate<TPayload> filter)\n        {\n            IDelegateReference actionReference = new DelegateReference(action, keepSubscriberReferenceAlive);\n            IDelegateReference filterReference;\n            if (filter != null)\n            {\n                filterReference = new DelegateReference(filter, keepSubscriberReferenceAlive);\n            }\n            else\n            {\n                filterReference = new DelegateReference(new Predicate<TPayload>(delegate { return true; }), true);\n            }\n            EventSubscription<TPayload> subscription;\n            switch (threadOption)\n            {\n                case ThreadOption.PublisherThread:\n                    subscription = new EventSubscription<TPayload>(actionReference, filterReference);\n                    break;\n                case ThreadOption.BackgroundThread:\n                    subscription = new BackgroundEventSubscription<TPayload>(actionReference, filterReference);\n                    break;\n                case ThreadOption.UIThread:\n                    subscription = new DispatcherEventSubscription<TPayload>(actionReference, filterReference);\n                    break;\n                default:\n                    subscription = new EventSubscription<TPayload>(actionReference, filterReference);\n                    break;\n            }\n \n \n            return base.InternalSubscribe(subscription);\n        }\n \n \n \n        /// <summary>\n        /// Publishes the <see cref=\"CompositePresentationEvent{TPayload}\"/>.\n        /// </summary>\n        /// <param name=\"payload\">Message to pass to the subscribers.</param>\n        public virtual void Publish(TPayload payload)\n        {\n            base.InternalPublish(payload);\n        }\n \n        /// <summary>\n        /// Removes the first subscriber matching <seealso cref=\"Action{TPayload}\"/> from the subscribers' list.\n        /// </summary>\n        /// <param name=\"subscriber\">The <see cref=\"Action{TPayload}\"/> used when subscribing to the event.</param>\n        public virtual void Unsubscribe(Action<TPayload> subscriber)\n        {\n            lock (Subscriptions)\n            {\n                IEventSubscription eventSubscription = Subscriptions.Cast<EventSubscription<TPayload>>().FirstOrDefault(evt => evt.Action == subscriber);\n                if (eventSubscription != null)\n                {\n                    Subscriptions.Remove(eventSubscription);\n                }\n            }\n        }\n \n        /// <summary>\n        /// Returns <see langword=\"true\"/> if there is a subscriber matching <seealso cref=\"Action{TPayload}\"/>.\n        /// </summary>\n        /// <param name=\"subscriber\">The <see cref=\"Action{TPayload}\"/> used when subscribing to the event.</param>\n        /// <returns><see langword=\"true\"/> if there is an <seealso cref=\"Action{TPayload}\"/> that matches; otherwise <see langword=\"false\"/>.</returns>\n        public virtual bool Contains(Action<TPayload> subscriber)\n        {\n            IEventSubscription eventSubscription;\n            lock (Subscriptions)\n            {\n                eventSubscription = Subscriptions.Cast<EventSubscription<TPayload>>().FirstOrDefault(evt => evt.Action == subscriber);\n            }\n            return eventSubscription != null;\n        }\n \n    }\n \n\t\t/// <summary>\n\t\t/// Specifies on which thread a <see cref=\"CompositePresentationEvent{TPayload}\"/> subscriber will be called.\n\t\t/// </summary>\n\t\tpublic enum ThreadOption {\n\t\t\t/// <summary>\n\t\t\t/// The call is done on the same thread on which the <see cref=\"CompositePresentationEvent{TPayload}\"/> was published.\n\t\t\t/// </summary>\n\t\t\tPublisherThread,\n \n\t\t\t/// <summary>\n\t\t\t/// The call is done on the UI thread.\n\t\t\t/// </summary>\n\t\t\tUIThread,\n \n\t\t\t/// <summary>\n\t\t\t/// The call is done asynchronously on a background thread.\n\t\t\t/// </summary>\n\t\t\tBackgroundThread\n\t\t}\n \n\t\t///<summary>\n\t\t/// Extends <see cref=\"EventSubscription{TPayload}\"/> to invoke the <see cref=\"EventSubscription{TPayload}.Action\"/> delegate\n\t\t/// in a specific <see cref=\"Dispatcher\"/>.\n\t\t///</summary>\n\t\t/// <typeparam name=\"TPayload\">The type to use for the generic <see cref=\"System.Action{TPayload}\"/> and <see cref=\"Predicate{TPayload}\"/> types.</typeparam>\n\t\tpublic class DispatcherEventSubscription<TPayload> : EventSubscription<TPayload> {\n \n\t\t\tprivate SynchronizationContext syncContext;\n \n\t\t\t///<summary>\n\t\t\t/// Creates a new instance of <see cref=\"BackgroundEventSubscription{TPayload}\"/>.\n\t\t\t///</summary>\n\t\t\t///<param name=\"actionReference\">A reference to a delegate of type <see cref=\"System.Action{TPayload}\"/>.</param>\n\t\t\t///<param name=\"filterReference\">A reference to a delegate of type <see cref=\"Predicate{TPayload}\"/>.</param>\n\t\t\t///<exception cref=\"ArgumentNullException\">When <paramref name=\"actionReference\"/> or <see paramref=\"filterReference\"/> are <see langword=\"null\" />.</exception>\n\t\t\t///<exception cref=\"ArgumentException\">When the target of <paramref name=\"actionReference\"/> is not of type <see cref=\"System.Action{TPayload}\"/>,\n\t\t\t///or the target of <paramref name=\"filterReference\"/> is not of type <see cref=\"Predicate{TPayload}\"/>.</exception>\n\t\t\tpublic DispatcherEventSubscription(IDelegateReference actionReference, IDelegateReference filterReference)\n\t\t\t\t: base(actionReference, filterReference) {\n \n\t\t\t\tsyncContext = AsyncOperationManager.SynchronizationContext;\n\t\t\t}\n \n\t\t\t/// <summary>\n\t\t\t/// Invokes the specified <see cref=\"System.Action{TPayload}\"/> asynchronously in the specified <see cref=\"Dispatcher\"/>.\n\t\t\t/// </summary>\n\t\t\t/// <param name=\"action\">The action to execute.</param>\n\t\t\t/// <param name=\"argument\">The payload to pass <paramref name=\"action\"/> while invoking it.</param>\n\t\t\tpublic override void InvokeAction(Action<TPayload> action, TPayload argument) {\n\t\t\t\tsyncContext.Post((s) => action(argument), null);\n\t\t\t\t//dispatcher.BeginInvoke(action, argument);\n\t\t\t}\n\t\t}\n}",
    "LastUpdatedDate": "2013-05-16T05:28:56.53-07:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "CompositeWPF",
    "ReportedDate": "2009-07-27T23:43:22.53-07:00",
    "Status": {
      "Name": "Closed",
      "Id": 4
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Move CompositePresentationEvent to Microsoft.Practices.Composite.Events",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 4,
    "Id": 4663
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "Hi Ido,\r\nIt could be helpful to know that, as of Prism v4, the Microsoft.Practices.Composite.Presentation and Microsoft.Practices.Composite assemblies have been merged into Microsoft.Practices.Prism. Also, you might find the standalone Event Aggregator useful, as it shows a possibly way to isolate the Event Aggregator functionality in one assembly:\r\nhttp://blogs.southworks.net/dschenkelman/2009/05/08/putting-prism-v2-extensibility-to-test-the-standalone-silverlight-event-aggregator/\r\nThank you for your feedback.\r\n",
      "PostedDate": "2011-02-11T07:27:02.02-08:00",
      "Id": 156167
    }
  ]
}